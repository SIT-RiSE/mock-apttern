[
  {
    "variableName": "amqpTemplate",
    "variableType": "AmqpTemplate",
    "mockedClass": "AmqpTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\ChannelTests.java",
      "className": "ChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AmqpTemplate amqpTemplate = mock(AmqpTemplate.class);",
        "line": 169,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "channelDeclarationTests",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageConverter",
    "variableType": "MessageConverter",
    "mockedClass": "MessageConverter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\ChannelTests.java",
      "className": "ChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageConverter messageConverter = mock(MessageConverter.class);",
        "line": 247,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "messageConversionTests",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "declareOk",
    "variableType": "DeclareOk",
    "mockedClass": "DeclareOk",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\DispatcherHasNoSubscribersTests.java",
      "className": "DispatcherHasNoSubscribersTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DeclareOk declareOk = mock(DeclareOk.class);",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPtP",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(declareOk.getQueue()).thenReturn(\"noSubscribersChannel\");",
        "line": 62,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPtP",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "AmqpTemplate",
    "mockedClass": "AmqpTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\DispatcherHasNoSubscribersTests.java",
      "className": "DispatcherHasNoSubscribersTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AmqpTemplate amqpTemplate = mock(AmqpTemplate.class);",
        "line": 71,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPtP",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\DispatcherHasNoSubscribersTests.java",
      "className": "DispatcherHasNoSubscribersTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 67,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPtP",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connectionFactory.createConnection()).thenReturn(connection);",
        "line": 68,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPtP",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "Channel",
    "mockedClass": "Channel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\DispatcherHasNoSubscribersTests.java",
      "className": "DispatcherHasNoSubscribersTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final Channel channel = mock(Channel.class);",
        "line": 60,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPtP",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(channel.queueDeclare(anyString(), anyBoolean(), anyBoolean(), anyBoolean(), isNull())).thenReturn(declareOk);",
        "line": 63,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPtP",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "Connection",
    "mockedClass": "Connection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\DispatcherHasNoSubscribersTests.java",
      "className": "DispatcherHasNoSubscribersTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Connection connection = mock(Connection.class);",
        "line": 65,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPtP",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "AmqpTemplate",
    "mockedClass": "AmqpTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\DispatcherHasNoSubscribersTests.java",
      "className": "DispatcherHasNoSubscribersTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AmqpTemplate amqpTemplate = mock(AmqpTemplate.class);",
        "line": 95,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPubSub",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\DispatcherHasNoSubscribersTests.java",
      "className": "DispatcherHasNoSubscribersTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 91,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPubSub",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connectionFactory.createConnection()).thenReturn(connection);",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPubSub",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "Channel",
    "mockedClass": "Channel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\DispatcherHasNoSubscribersTests.java",
      "className": "DispatcherHasNoSubscribersTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final Channel channel = mock(Channel.class);",
        "line": 88,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPubSub",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "Connection",
    "mockedClass": "Connection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\DispatcherHasNoSubscribersTests.java",
      "className": "DispatcherHasNoSubscribersTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Connection connection = mock(Connection.class);",
        "line": 89,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPubSub",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\channel\\DispatcherHasNoSubscribersTests.java",
      "className": "DispatcherHasNoSubscribersTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log logger = mock(Log.class);",
        "line": 111,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "insertMockLoggerInListener",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isWarnEnabled()).thenReturn(true);",
        "line": 120,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "insertMockLoggerInListener",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpInboundGatewayParserTests.java",
      "className": "AmqpInboundGatewayParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate amqpTemplate = TestUtils.getPropertyValue(gateway, \"amqpTemplate\", RabbitTemplate.class);",
        "line": 111,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "verifyUsageWithHeaderMapper",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "amqpTemplate = Mockito.spy(amqpTemplate);",
        "line": 112,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "verifyUsageWithHeaderMapper",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(amqpTemplate, Mockito.times(1)).send(Mockito.any(String.class), Mockito.any(String.class), Mockito.any(Message.class), isNull());",
        "line": 140,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "verifyUsageWithHeaderMapper",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate amqpTemplate = TestUtils.getPropertyValue(endpoint, \"rabbitTemplate\", RabbitTemplate.class);",
        "line": 128,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperCustomHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "amqpTemplate = Mockito.spy(amqpTemplate);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperCustomHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(amqpTemplate, Mockito.times(1)).send(anyString(), isNull(), Mockito.any(org.springframework.amqp.core.Message.class), isNull());",
        "line": 155,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperCustomHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate amqpTemplate = TestUtils.getPropertyValue(endpoint, \"rabbitTemplate\", RabbitTemplate.class);",
        "line": 207,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "amqpOutboundChannelAdapterWithinChain",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "amqpTemplate = Mockito.spy(amqpTemplate);",
        "line": 208,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "amqpOutboundChannelAdapterWithinChain",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(amqpTemplate, Mockito.times(1)).send(Mockito.any(String.class), isNull(), Mockito.any(org.springframework.amqp.core.Message.class), isNull());",
        "line": 226,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "amqpOutboundChannelAdapterWithinChain",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "publisherCallbackChannel",
    "variableType": "PublisherCallbackChannelImpl",
    "mockedClass": "PublisherCallbackChannelImpl",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));",
        "line": 251,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773UseDefaultAmqpTemplateExchangeAndRoutingLey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockConnection",
    "variableType": "Connection",
    "mockedClass": "Connection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Connection mockConnection = mock(Connection.class);",
        "line": 247,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773UseDefaultAmqpTemplateExchangeAndRoutingLey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);",
        "line": 253,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773UseDefaultAmqpTemplateExchangeAndRoutingLey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockChannel",
    "variableType": "Channel",
    "mockedClass": "Channel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Channel mockChannel = mock(Channel.class);",
        "line": 248,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773UseDefaultAmqpTemplateExchangeAndRoutingLey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(\"default.test.exchange\"), Mockito.eq(\"default.routing.key\"), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));",
        "line": 257,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773UseDefaultAmqpTemplateExchangeAndRoutingLey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "publisherCallbackChannel",
    "variableType": "PublisherCallbackChannelImpl",
    "mockedClass": "PublisherCallbackChannelImpl",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));",
        "line": 269,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773WithDefaultAmqpTemplateExchangeAndRoutingKey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockConnection",
    "variableType": "Connection",
    "mockedClass": "Connection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Connection mockConnection = mock(Connection.class);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773WithDefaultAmqpTemplateExchangeAndRoutingKey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);",
        "line": 271,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773WithDefaultAmqpTemplateExchangeAndRoutingKey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockChannel",
    "variableType": "Channel",
    "mockedClass": "Channel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Channel mockChannel = mock(Channel.class);",
        "line": 266,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773WithDefaultAmqpTemplateExchangeAndRoutingKey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(\"\"), Mockito.eq(\"\"), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));",
        "line": 276,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773WithDefaultAmqpTemplateExchangeAndRoutingKey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "publisherCallbackChannel",
    "variableType": "PublisherCallbackChannelImpl",
    "mockedClass": "PublisherCallbackChannelImpl",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));",
        "line": 287,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773WithOverrideToDefaultAmqpTemplateExchangeAndRoutingLey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockConnection",
    "variableType": "Connection",
    "mockedClass": "Connection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Connection mockConnection = mock(Connection.class);",
        "line": 283,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773WithOverrideToDefaultAmqpTemplateExchangeAndRoutingLey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773WithOverrideToDefaultAmqpTemplateExchangeAndRoutingLey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockChannel",
    "variableType": "Channel",
    "mockedClass": "Channel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Channel mockChannel = mock(Channel.class);",
        "line": 284,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773WithOverrideToDefaultAmqpTemplateExchangeAndRoutingLey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(\"\"), Mockito.eq(\"\"), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));",
        "line": 293,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2773WithOverrideToDefaultAmqpTemplateExchangeAndRoutingLey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate amqpTemplate = spy(new RabbitTemplate());",
        "line": 320,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3430FailForNotLazyConnect",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(amqpTemplate.getConnectionFactory()).thenReturn(connectionFactory);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3430FailForNotLazyConnect",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 321,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3430FailForNotLazyConnect",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(handler, \"logger\", LogAccessor.class));",
        "line": 326,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3430FailForNotLazyConnect",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, never()).error(any(RuntimeException.class), anyString());",
        "line": 335,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3430FailForNotLazyConnect",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).error(toBeThrown, \"Failed to eagerly establish the connection.\");",
        "line": 338,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3430FailForNotLazyConnect",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "ApplicationContext",
    "mockedClass": "ApplicationContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundChannelAdapterParserTests.java",
      "className": "AmqpOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ApplicationContext context = mock(ApplicationContext.class);",
        "line": 329,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3430FailForNotLazyConnect",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundGatewayParserTests.java",
      "className": "AmqpOutboundGatewayParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate amqpTemplate = TestUtils.getPropertyValue(endpoint, \"rabbitTemplate\", RabbitTemplate.class);",
        "line": 114,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperCustomRequestResponse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "amqpTemplate = Mockito.spy(amqpTemplate);",
        "line": 115,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperCustomRequestResponse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(amqpTemplate, Mockito.times(1)).sendAndReceive(Mockito.any(String.class), Mockito.any(String.class), Mockito.any(org.springframework.amqp.core.Message.class), isNull());",
        "line": 141,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperCustomRequestResponse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundGatewayParserTests.java",
      "className": "AmqpOutboundGatewayParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate amqpTemplate = TestUtils.getPropertyValue(endpoint, \"rabbitTemplate\", RabbitTemplate.class);",
        "line": 177,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperCustomAndStandardResponse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "amqpTemplate = Mockito.spy(amqpTemplate);",
        "line": 178,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperCustomAndStandardResponse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(amqpTemplate, Mockito.times(1)).sendAndReceive(Mockito.any(String.class), Mockito.any(String.class), Mockito.any(org.springframework.amqp.core.Message.class), isNull());",
        "line": 202,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperCustomAndStandardResponse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundGatewayParserTests.java",
      "className": "AmqpOutboundGatewayParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate amqpTemplate = TestUtils.getPropertyValue(endpoint, \"rabbitTemplate\", RabbitTemplate.class);",
        "line": 226,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperNothingToMap",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "amqpTemplate = Mockito.spy(amqpTemplate);",
        "line": 227,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperNothingToMap",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(amqpTemplate, Mockito.times(1)).sendAndReceive(Mockito.any(String.class), Mockito.any(String.class), Mockito.any(org.springframework.amqp.core.Message.class), isNull());",
        "line": 249,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withHeaderMapperNothingToMap",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\AmqpOutboundGatewayParserTests.java",
      "className": "AmqpOutboundGatewayParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate amqpTemplate = TestUtils.getPropertyValue(endpoint, \"rabbitTemplate\", RabbitTemplate.class);",
        "line": 275,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "amqpOutboundGatewayWithinChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "amqpTemplate = Mockito.spy(amqpTemplate);",
        "line": 276,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "amqpOutboundGatewayWithinChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(amqpTemplate, Mockito.times(1)).sendAndReceive(Mockito.any(String.class), Mockito.any(String.class), Mockito.any(org.springframework.amqp.core.Message.class), isNull());",
        "line": 299,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "amqpOutboundGatewayWithinChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "template",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\OutboundGatewayTests.java",
      "className": "OutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate template = spy(new RabbitTemplate());",
        "line": 95,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExpressionsBeanResolver",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "ApplicationContext",
    "mockedClass": "ApplicationContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\config\\OutboundGatewayTests.java",
      "className": "OutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ApplicationContext context = mock(ApplicationContext.class);",
        "line": 82,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExpressionsBeanResolver",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.containsBean(IntegrationContextUtils.INTEGRATION_EVALUATION_CONTEXT_BEAN_NAME)).thenReturn(true);",
        "line": 84,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExpressionsBeanResolver",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getBean(SpelPropertyAccessorRegistrar.class)).thenThrow(NoSuchBeanDefinitionException.class);",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExpressionsBeanResolver",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getBean(IntegrationContextUtils.INTEGRATION_EVALUATION_CONTEXT_BEAN_NAME, StandardEvaluationContext.class)).thenReturn(evalContext);",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExpressionsBeanResolver",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "env",
    "variableType": "Environment",
    "mockedClass": "Environment",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\dsl\\AmqpTests.java",
      "className": "AmqpTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Environment env = mock(Environment.class);",
        "line": 282,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "streamContainer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(env.consumerBuilder()).willReturn(mock(ConsumerBuilder.class));",
        "line": 283,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "streamContainer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "customizer",
    "variableType": "ConsumerCustomizer",
    "mockedClass": "ConsumerCustomizer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\dsl\\AmqpTests.java",
      "className": "AmqpTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerCustomizer customizer = mock(ConsumerCustomizer.class);",
        "line": 285,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "streamContainer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(customizer).accept(any(), any());",
        "line": 288,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "streamContainer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\inbound\\AmqpMessageSourceTests.java",
      "className": "AmqpMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 68,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "Channel",
    "mockedClass": "Channel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\inbound\\AmqpMessageSourceTests.java",
      "className": "AmqpMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Channel channel = mock(Channel.class);",
        "line": 59,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(channel).basicAck(123L, false);",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(channel, times(2)).close();",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "Connection",
    "mockedClass": "Connection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\inbound\\AmqpMessageSourceTests.java",
      "className": "AmqpMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Connection connection = mock(Connection.class);",
        "line": 65,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection, times(2)).createChannel();",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection, times(2)).createChannel();",
        "line": 88,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection).close(30000);",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\inbound\\AmqpMessageSourceTests.java",
      "className": "AmqpMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 116,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackOrRequeue",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "Channel",
    "mockedClass": "Channel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\inbound\\AmqpMessageSourceTests.java",
      "className": "AmqpMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Channel channel = mock(Channel.class);",
        "line": 107,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackOrRequeue",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(channel).basicReject(123L, requeue);",
        "line": 125,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackOrRequeue",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(channel).close();",
        "line": 128,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackOrRequeue",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "Connection",
    "mockedClass": "Connection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\inbound\\AmqpMessageSourceTests.java",
      "className": "AmqpMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Connection connection = mock(Connection.class);",
        "line": 113,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackOrRequeue",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection).createChannel();",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackOrRequeue",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection).createChannel();",
        "line": 126,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackOrRequeue",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection).close(30000);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackOrRequeue",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "Channel",
    "mockedClass": "Channel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\inbound\\AmqpMessageSourceTests.java",
      "className": "AmqpMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Channel channel = mock(Channel.class);",
        "line": 144,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBatch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\inbound\\AmqpMessageSourceTests.java",
      "className": "AmqpMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 156,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBatch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "Connection",
    "mockedClass": "Connection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\inbound\\AmqpMessageSourceTests.java",
      "className": "AmqpMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Connection connection = mock(Connection.class);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBatch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "template",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\AmqpOutboundEndpointTests.java",
      "className": "AmqpOutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate template = spy(RabbitTemplate.class);",
        "line": 185,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "syncConfirmTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(template).send(isNull(), isNull(), any(), correlationCaptor.capture());",
        "line": 204,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "syncConfirmTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\AsyncAmqpGatewayTests.java",
      "className": "AsyncAmqpGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(gateway, \"logger\", LogAccessor.class));",
        "line": 108,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConfirmsAndReturns",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(logger.isDebugEnabled()).willReturn(true);",
        "line": 109,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConfirmsAndReturns",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "asyncTemplate",
    "variableType": "AsyncRabbitTemplate",
    "mockedClass": "AsyncRabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\AsyncAmqpGatewayTests.java",
      "className": "AsyncAmqpGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AsyncRabbitTemplate asyncTemplate = new AsyncRabbitTemplate(template, container);",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConfirmsAndReturns",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "asyncTemplate = mock(AsyncRabbitTemplate.class);",
        "line": 206,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConfirmsAndReturns",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "future",
    "variableType": "RabbitMessageFuture",
    "mockedClass": "RabbitMessageFuture",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\AsyncAmqpGatewayTests.java",
      "className": "AsyncAmqpGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitMessageFuture future = mock(RabbitMessageFuture.class);",
        "line": 202,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConfirmsAndReturns",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\OutboundEndpointTests.java",
      "className": "OutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate amqpTemplate = spy(new RabbitTemplate(connectionFactory));",
        "line": 67,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDelayExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(amqpTemplate).send(eq(\"foo\"), eq(\"bar\"), captor.capture(), isNull());",
        "line": 81,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDelayExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(amqpTemplate).sendAndReceive(eq(\"foo\"), eq(\"bar\"), captor.capture(), isNull());",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDelayExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(amqpTemplate).sendAndReceive(eq(\"foo\"), eq(\"baz\"), captor.capture(), isNull());",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDelayExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\OutboundEndpointTests.java",
      "className": "OutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 66,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDelayExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "AsyncRabbitTemplate",
    "mockedClass": "AsyncRabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\OutboundEndpointTests.java",
      "className": "OutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AsyncRabbitTemplate amqpTemplate = spy(new AsyncRabbitTemplate(new RabbitTemplate(connectionFactory), new SimpleMessageListenerContainer(connectionFactory), \"replyTo\"));",
        "line": 100,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAsyncDelayExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(amqpTemplate).sendAndReceive(eq(\"foo\"), eq(\"bar\"), captor.capture());",
        "line": 116,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAsyncDelayExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\OutboundEndpointTests.java",
      "className": "OutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 99,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAsyncDelayExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "RabbitTemplate",
    "mockedClass": "RabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\OutboundEndpointTests.java",
      "className": "OutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitTemplate amqpTemplate = spy(new RabbitTemplate(connectionFactory));",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHeaderMapperWinsAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\OutboundEndpointTests.java",
      "className": "OutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHeaderMapperWinsAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "TestRabbitTemplate",
    "mockedClass": "TestRabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\OutboundEndpointTests.java",
      "className": "OutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TestRabbitTemplate amqpTemplate = spy(new TestRabbitTemplate(connectionFactory));",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHeaderMapperWinsGateway",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\OutboundEndpointTests.java",
      "className": "OutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 141,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHeaderMapperWinsGateway",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "amqpTemplate",
    "variableType": "TestRabbitTemplate",
    "mockedClass": "TestRabbitTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\OutboundEndpointTests.java",
      "className": "OutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TestRabbitTemplate amqpTemplate = spy(new TestRabbitTemplate(connectionFactory));",
        "line": 169,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyHeadersWin",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\outbound\\OutboundEndpointTests.java",
      "className": "OutboundEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 168,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyHeadersWin",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.support",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\support\\BoundRabbitChannelAdviceIntegrationTests.java",
      "className": "BoundRabbitChannelAdviceIntegrationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log logger = spy(TestUtils.getPropertyValue(advice, \"logger\", Log.class));",
        "line": 69,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAdvice",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "template",
    "variableType": "RabbitOperations",
    "mockedClass": "RabbitOperations",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.support",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\support\\BoundRabbitChannelAdviceTests.java",
      "className": "BoundRabbitChannelAdviceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RabbitOperations template = mock(RabbitOperations.class);",
        "line": 79,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(template.getConnectionFactory()).willReturn(mock(org.springframework.amqp.rabbit.connection.ConnectionFactory.class));",
        "line": 80,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "cf",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.amqp.support",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-amqp\\src\\test\\java\\org\\springframework\\integration\\amqp\\support\\BoundRabbitChannelAdviceTests.java",
      "className": "Config"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory cf = mock(ConnectionFactory.class);",
        "line": 96,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "cf",
          "methodAnnotations": [
            "@Bean"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mgs",
    "variableType": "MessageGroupStore",
    "mockedClass": "MessageGroupStore",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\AbstractCorrelatingMessageHandlerTests.java",
      "className": "AbstractCorrelatingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageGroupStore mgs = TestUtils.getPropertyValue(handler, \"messageStore\", MessageGroupStore.class);",
        "line": 266,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDontReapIfAlreadyComplete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "mgs = spy(mgs);",
        "line": 269,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDontReapIfAlreadyComplete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(mgs, never()).getMessageGroup(\"foo\");",
        "line": 278,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDontReapIfAlreadyComplete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mgs",
    "variableType": "MessageGroupStore",
    "mockedClass": "MessageGroupStore",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\AbstractCorrelatingMessageHandlerTests.java",
      "className": "AbstractCorrelatingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageGroupStore mgs = TestUtils.getPropertyValue(handler, \"messageStore\", MessageGroupStore.class);",
        "line": 292,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDontReapIfAlreadyCompleteAfterRefetch",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "mgs = spy(mgs);",
        "line": 296,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDontReapIfAlreadyCompleteAfterRefetch",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(mgs).getMessageGroup(\"foo\");",
        "line": 307,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDontReapIfAlreadyCompleteAfterRefetch",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mgs",
    "variableType": "MessageGroupStore",
    "mockedClass": "MessageGroupStore",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\AbstractCorrelatingMessageHandlerTests.java",
      "className": "AbstractCorrelatingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageGroupStore mgs = TestUtils.getPropertyValue(handler, \"messageStore\", MessageGroupStore.class);",
        "line": 321,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDontReapIfNewGroupFoundDuringRefetch",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "mgs = spy(mgs);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDontReapIfNewGroupFoundDuringRefetch",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(mgs).getMessageGroup(\"foo\");",
        "line": 337,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDontReapIfNewGroupFoundDuringRefetch",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "groupStore",
    "variableType": "MessageGroupStore",
    "mockedClass": "MessageGroupStore",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\AbstractCorrelatingMessageHandlerTests.java",
      "className": "AbstractCorrelatingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageGroupStore groupStore = spy(new SimpleMessageStore());",
        "line": 512,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPurgeOrphanedGroupsScheduled",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(groupStore, atLeast(2)).expireMessageGroups(100);",
        "line": 529,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPurgeOrphanedGroupsScheduled",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\BarrierMessageHandlerTests.java",
      "className": "BarrierMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(handler, \"logger\", LogAccessor.class));",
        "line": 173,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLateReply",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).error(captor.capture());",
        "line": 178,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLateReply",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "releaseStrategy",
    "variableType": "ReleaseStrategy",
    "mockedClass": "ReleaseStrategy",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\CorrelatingMessageBarrierTests.java",
      "className": "CorrelatingMessageBarrierTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate ReleaseStrategy releaseStrategy;",
        "line": 54,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(releaseStrategy.canRelease(isA(MessageGroup.class))).thenReturn(true);",
        "line": 64,
        "locate": "@Before",
        "locationContext": {
          "methodName": "initializeBarrier",
          "methodAnnotations": [
            "@Before"
          ]
        }
      }
    ]
  },
  {
    "variableName": "correlationStrategy",
    "variableType": "CorrelationStrategy",
    "mockedClass": "CorrelationStrategy",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\CorrelatingMessageBarrierTests.java",
      "className": "CorrelatingMessageBarrierTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate CorrelationStrategy correlationStrategy;",
        "line": 51,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(correlationStrategy.getCorrelationKey(isA(Message.class))).thenReturn(\"foo\");",
        "line": 63,
        "locate": "@Before",
        "locationContext": {
          "methodName": "initializeBarrier",
          "methodAnnotations": [
            "@Before"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(correlationStrategy).getCorrelationKey(message);",
        "line": 79,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldRemoveKeyWithoutLockingOnEmptyQueue",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "releaseStrategy",
    "variableType": "ReleaseStrategy",
    "mockedClass": "ReleaseStrategy",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\CorrelatingMessageBarrierTests.java",
      "className": "CorrelatingMessageBarrierTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate ReleaseStrategy releaseStrategy;",
        "line": 54,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(releaseStrategy.canRelease(isA(MessageGroup.class))).thenReturn(true);",
        "line": 64,
        "locate": "@Before",
        "locationContext": {
          "methodName": "initializeBarrier",
          "methodAnnotations": [
            "@Before"
          ]
        }
      }
    ]
  },
  {
    "variableName": "correlationStrategy",
    "variableType": "CorrelationStrategy",
    "mockedClass": "CorrelationStrategy",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\CorrelatingMessageBarrierTests.java",
      "className": "CorrelatingMessageBarrierTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate CorrelationStrategy correlationStrategy;",
        "line": 51,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(correlationStrategy.getCorrelationKey(isA(Message.class))).thenReturn(\"foo\");",
        "line": 63,
        "locate": "@Before",
        "locationContext": {
          "methodName": "initializeBarrier",
          "methodAnnotations": [
            "@Before"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(correlationStrategy).getCorrelationKey(message);",
        "line": 79,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldRemoveKeyWithoutLockingOnEmptyQueue",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "discardChannel",
    "variableType": "MessageChannel",
    "mockedClass": "MessageChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\CorrelatingMessageHandlerIntegrationTests.java",
      "className": "CorrelatingMessageHandlerIntegrationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageChannel discardChannel = mock(MessageChannel.class);",
        "line": 72,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesAfterThreshold",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(discardChannel.send(any(Message.class))).thenReturn(true);",
        "line": 73,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesAfterThreshold",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(discardChannel).send(message2);",
        "line": 81,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesAfterThreshold",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "outputChannel",
    "variableType": "MessageChannel",
    "mockedClass": "MessageChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\CorrelatingMessageHandlerIntegrationTests.java",
      "className": "CorrelatingMessageHandlerIntegrationTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageChannel outputChannel = mock(MessageChannel.class);",
        "line": 46,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(outputChannel.send(isA(Message.class))).thenReturn(true);",
        "line": 54,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setupHandler",
          "methodAnnotations": [
            "@Before"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel).send(message);",
        "line": 66,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesSingleMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel).send(message1);",
        "line": 78,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesAfterThreshold",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel, never()).send(message2);",
        "line": 80,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesAfterThreshold",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel, never()).send(message3);",
        "line": 91,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesIfNoSequence",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel).send(message2);",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesIfNoSequence",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel, never()).send(message3);",
        "line": 95,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesIfNoSequence",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel, never()).send(message1);",
        "line": 106,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesWithoutReleasingIncompleteCorrelations",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel, never()).send(message2);",
        "line": 107,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesWithoutReleasingIncompleteCorrelations",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel).send(message1);",
        "line": 109,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesWithoutReleasingIncompleteCorrelations",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel).send(message1a);",
        "line": 110,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesWithoutReleasingIncompleteCorrelations",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel, never()).send(message2);",
        "line": 111,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesWithoutReleasingIncompleteCorrelations",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel, never()).send(message2a);",
        "line": 112,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesWithoutReleasingIncompleteCorrelations",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel).send(message2);",
        "line": 114,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesWithoutReleasingIncompleteCorrelations",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel).send(message2a);",
        "line": 115,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesWithoutReleasingIncompleteCorrelations",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel, never()).send(message1);",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesAfterSequenceComplete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel).send(message1);",
        "line": 125,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesAfterSequenceComplete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(outputChannel).send(message2);",
        "line": 126,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "completesAfterSequenceComplete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "outputChannel",
    "variableType": "MessageChannel",
    "mockedClass": "MessageChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\CorrelatingMessageHandlerTests.java",
      "className": "CorrelatingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private MessageChannel outputChannel;",
        "line": 62,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "outputChannel = mock(MessageChannel.class);",
        "line": 71,
        "locate": "@Before",
        "locationContext": {
          "methodName": "initializeSubject",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(outputChannel.send(any(Message.class), eq(30000L))).thenReturn(true);",
        "line": 87,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "bufferCompletesNormally",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(outputChannel.send(any(Message.class), eq(30000L))).thenReturn(true);",
        "line": 143,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldNotPruneWhileCompleting",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "processor",
    "variableType": "MessageGroupProcessor",
    "mockedClass": "MessageGroupProcessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\CorrelatingMessageHandlerTests.java",
      "className": "CorrelatingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private MessageGroupProcessor processor;",
        "line": 60,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "processor = mock(MessageGroupProcessor.class);",
        "line": 70,
        "locate": "@Before",
        "locationContext": {
          "methodName": "initializeSubject",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(processor.processMessageGroup(any(MessageGroup.class))).thenReturn(MessageBuilder.withPayload(\"grouped\").build());",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "bufferCompletesNormally",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(processor).processMessageGroup(isA(SimpleMessageGroup.class));",
        "line": 95,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "bufferCompletesNormally",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(processor).processMessageGroup(isA(SimpleMessageGroup.class));",
        "line": 124,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "bufferCompletesWithException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(processor.processMessageGroup(any(MessageGroup.class))).thenReturn(MessageBuilder.withPayload(\"grouped\").build());",
        "line": 141,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldNotPruneWhileCompleting",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "correlationStrategy",
    "variableType": "CorrelationStrategy",
    "mockedClass": "CorrelationStrategy",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\CorrelatingMessageHandlerTests.java",
      "className": "CorrelatingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private CorrelationStrategy correlationStrategy;",
        "line": 56,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "correlationStrategy = mock(CorrelationStrategy.class);",
        "line": 69,
        "locate": "@Before",
        "locationContext": {
          "methodName": "initializeSubject",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(correlationStrategy.getCorrelationKey(isA(Message.class))).thenReturn(correlationKey);",
        "line": 84,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "bufferCompletesNormally",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(correlationStrategy).getCorrelationKey(message1);",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "bufferCompletesNormally",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(correlationStrategy).getCorrelationKey(message2);",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "bufferCompletesNormally",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(correlationStrategy.getCorrelationKey(isA(Message.class))).thenReturn(correlationKey);",
        "line": 108,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "bufferCompletesWithException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(correlationStrategy).getCorrelationKey(message1);",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "bufferCompletesWithException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(correlationStrategy).getCorrelationKey(message2);",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "bufferCompletesWithException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(correlationStrategy.getCorrelationKey(isA(Message.class))).thenReturn(correlationKey);",
        "line": 140,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldNotPruneWhileCompleting",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(correlationStrategy.getCorrelationKey(isA(Message.class))).thenReturn(null);",
        "line": 162,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNullCorrelationKey",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "group",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\ExpressionEvaluatingMessageGroupProcessorTests.java",
      "className": "ExpressionEvaluatingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup group;",
        "line": 50,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(group.getMessages()).thenReturn(messages);",
        "line": 67,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessAndSendWithSizeExpressionEvaluated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(group.getMessages()).thenReturn(messages);",
        "line": 78,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessAndCheckHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(group.getMessages()).thenReturn(messages);",
        "line": 90,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessAndSendWithProjectionExpressionEvaluated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(group.getMessages()).thenReturn(messages);",
        "line": 108,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessAndSendWithFilterAndProjectionExpressionEvaluated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(group.getMessages()).thenReturn(messages);",
        "line": 124,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessAndSendWithFilterAndProjectionAndMethodInvokingExpressionEvaluated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageGroupMock",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.aggregator",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\aggregator\\MethodInvokingMessageGroupProcessorTests.java",
      "className": "MethodInvokingMessageGroupProcessorTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageGroup messageGroupMock;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodForMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(messageGroupMock.getMessages()).thenReturn(messagesUpForProcessing);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindListPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindAnnotatedPayloadsWithNoType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 241,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldUseAnnotatedPayloads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithCollection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithArray",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindSimpleAggregatorMethodWithIterator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodAmongMultipleUnannotated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldFindFittingMethodForIteratorOfMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.messageGroupMock.getMessages()).thenReturn(this.messagesUpForProcessing);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTwoMethodsWithSameParameterTypesAmbiguous",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\DirectChannelTests.java",
      "className": "DirectChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(channel, \"logger\", LogAccessor.class));",
        "line": 59,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isDebugEnabled()).thenReturn(true);",
        "line": 60,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, times(2)).debug(captor.capture());",
        "line": 73,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\ExecutorChannelTests.java",
      "className": "ExecutorChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 179,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "interceptorWithModifiedMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler).handleMessage(expected);",
        "line": 186,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "interceptorWithModifiedMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "expected",
    "variableType": "Message<?>",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\ExecutorChannelTests.java",
      "className": "ExecutorChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Message<?> expected = mock(Message.class);",
        "line": 180,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "interceptorWithModifiedMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\ExecutorChannelTests.java",
      "className": "ExecutorChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 199,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "interceptorWithException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler).handleMessage(message);",
        "line": 211,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "interceptorWithException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "ExecutorChannel",
    "mockedClass": "ExecutorChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\ExecutorChannelTests.java",
      "className": "ExecutorChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ExecutorChannel channel = new ExecutorChannel(mock(Executor.class));",
        "line": 218,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEarlySubscribe",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handlerC",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\MixedDispatcherConfigurationScenarioTests.java",
      "className": "MixedDispatcherConfigurationScenarioTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageHandler handlerC = mock(MessageHandler.class);",
        "line": 76,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(handlerC).handleMessage(message);",
        "line": 209,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerC, times(1)).handleMessage(message);",
        "line": 213,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerC, times(13)).handleMessage(message);",
        "line": 257,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerC, times(13)).handleMessage(message);",
        "line": 307,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancingWithExecutorConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerC, never()).handleMessage(message);",
        "line": 382,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerC, never()).handleMessage(message);",
        "line": 422,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancingWithExecutorConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handlerB",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\MixedDispatcherConfigurationScenarioTests.java",
      "className": "MixedDispatcherConfigurationScenarioTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageHandler handlerB = mock(MessageHandler.class);",
        "line": 74,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerB, times(0)).handleMessage(message);",
        "line": 103,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverNoLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerB, times(0)).handleMessage(message);",
        "line": 141,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverNoLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerB, times(0)).handleMessage(message);",
        "line": 178,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverNoLoadBalancingWithExecutorConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(handlerB).handleMessage(message);",
        "line": 203,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerB, times(1)).handleMessage(message);",
        "line": 212,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerB, times(13)).handleMessage(message);",
        "line": 256,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerB, times(13)).handleMessage(message);",
        "line": 306,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancingWithExecutorConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(handlerB).handleMessage(message);",
        "line": 327,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(handlerB).handleMessage(message);",
        "line": 335,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerB, times(2)).handleMessage(message);",
        "line": 338,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerB, times(TOTAL_EXECUTIONS)).handleMessage(message);",
        "line": 381,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerB, times(TOTAL_EXECUTIONS)).handleMessage(message);",
        "line": 421,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancingWithExecutorConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "exceptionRegistry",
    "variableType": "List<Exception>",
    "mockedClass": "List",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\MixedDispatcherConfigurationScenarioTests.java",
      "className": "MixedDispatcherConfigurationScenarioTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nprivate final List<Exception> exceptionRegistry = mock(List.class);",
        "line": 69,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(exceptionRegistry, times(TOTAL_EXECUTIONS)).add(any(Exception.class));",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverNoLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(exceptionRegistry, times(TOTAL_EXECUTIONS)).add(any(Exception.class));",
        "line": 179,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverNoLoadBalancingWithExecutorConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(exceptionRegistry, times(14)).add(any(Exception.class));",
        "line": 258,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(exceptionRegistry, times(14)).add(any(Exception.class));",
        "line": 308,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancingWithExecutorConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(exceptionRegistry, never()).add(any(Exception.class));",
        "line": 383,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handlerA",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\MixedDispatcherConfigurationScenarioTests.java",
      "className": "MixedDispatcherConfigurationScenarioTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageHandler handlerA = mock(MessageHandler.class);",
        "line": 72,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerA, times(2)).handleMessage(message);",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverNoLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerA, times(TOTAL_EXECUTIONS)).handleMessage(message);",
        "line": 140,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverNoLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerA, times(TOTAL_EXECUTIONS)).handleMessage(message);",
        "line": 177,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverNoLoadBalancingWithExecutorConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(handlerA).handleMessage(message);",
        "line": 197,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerA, times(1)).handleMessage(message);",
        "line": 211,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerA, times(14)).handleMessage(message);",
        "line": 255,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerA, times(14)).handleMessage(message);",
        "line": 305,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFailoverLoadBalancingWithExecutorConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(handlerA).handleMessage(message);",
        "line": 326,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(handlerA).handleMessage(message);",
        "line": 334,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerA, times(2)).handleMessage(message);",
        "line": 337,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerA, times(TOTAL_EXECUTIONS)).handleMessage(message);",
        "line": 380,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancingConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handlerA, times(TOTAL_EXECUTIONS)).handleMessage(message);",
        "line": 420,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverNoLoadBalancingWithExecutorConcurrent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— Other Methods\n\nVerification:\n— Other Methods",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\P2pChannelTests.java",
      "className": "P2pChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final LogAccessor logger = mock(LogAccessor.class);",
        "line": 57,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "verifySubscriptions",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isInfoEnabled()).thenReturn(true);",
        "line": 58,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "verifySubscriptions",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, times(4)).info(Mockito.anyString());",
        "line": 92,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "verifySubscriptions",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "handler2",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\P2pChannelTests.java",
      "className": "P2pChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler2 = mock(MessageHandler.class);",
        "line": 79,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "verifySubscriptions",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "handler1",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\P2pChannelTests.java",
      "className": "P2pChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler1 = mock(MessageHandler.class);",
        "line": 75,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "verifySubscriptions",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\P2pChannelTests.java",
      "className": "P2pChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final LogAccessor logger = mock(LogAccessor.class);",
        "line": 100,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExecutorChannelLoggingWithMoreThenOneSubscriber",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isInfoEnabled()).thenReturn(true);",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExecutorChannelLoggingWithMoreThenOneSubscriber",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, times(2)).info(Mockito.anyString());",
        "line": 110,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExecutorChannelLoggingWithMoreThenOneSubscriber",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "ExecutorChannel",
    "mockedClass": "ExecutorChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\P2pChannelTests.java",
      "className": "P2pChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final ExecutorChannel channel = new ExecutorChannel(mock(Executor.class));",
        "line": 97,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExecutorChannelLoggingWithMoreThenOneSubscriber",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\P2pChannelTests.java",
      "className": "P2pChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final LogAccessor logger = mock(LogAccessor.class);",
        "line": 118,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPubSubChannelLoggingWithMoreThenOneSubscriber",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isInfoEnabled()).thenReturn(true);",
        "line": 119,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPubSubChannelLoggingWithMoreThenOneSubscriber",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, times(2)).info(Mockito.anyString());",
        "line": 128,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPubSubChannelLoggingWithMoreThenOneSubscriber",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "PublishSubscribeChannel",
    "mockedClass": "PublishSubscribeChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\PublishSubscribeChannelTests.java",
      "className": "PublishSubscribeChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "PublishSubscribeChannel channel = new PublishSubscribeChannel(mock(Executor.class));",
        "line": 43,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEarlySubscribe",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "queue",
    "variableType": "Queue<Message<?>>",
    "mockedClass": "Queue<Message<?>>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\QueueChannelTests.java",
      "className": "QueueChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Queue<Message<?>> queue = spy(new ArrayDeque<>());",
        "line": 155,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBlockingReceiveWithTimeoutEmptyThenSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "queue",
    "variableType": "Queue<Message<?>>",
    "mockedClass": "Queue<Message<?>>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.channel",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\QueueChannelTests.java",
      "className": "QueueChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Queue<Message<?>> queue = spy(new ArrayDeque<>());",
        "line": 179,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBlockingReceiveNoTimeoutEmptyThenSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "testSubscriber",
    "variableType": "Subscriber<Message<?>>",
    "mockedClass": "Subscriber<Message<?>>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel.reactive",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\reactive\\ReactiveStreamsConsumerTests.java",
      "className": "ReactiveStreamsConsumerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Subscriber<Message<?>> testSubscriber = Mockito.spy(new Subscriber<Message<?>>() {\r\n\r\n    @Override\r\n    public void onSubscribe(Subscription subscription) {\r\n        subscription.request(1);\r\n    }\r\n\r\n    @Override\r\n    public void onNext(Message<?> message) {\r\n        messages.offer(message);\r\n    }\r\n\r\n    @Override\r\n    public void onError(Throwable t) {\r\n    }\r\n\r\n    @Override\r\n    public void onComplete() {\r\n    }\r\n});",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReactiveStreamsConsumerDirectChannel",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(testSubscriber, never()).onError(any(Throwable.class));",
        "line": 170,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReactiveStreamsConsumerDirectChannel",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(testSubscriber, never()).onComplete();",
        "line": 171,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReactiveStreamsConsumerDirectChannel",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "testSubscriber",
    "variableType": "Subscriber<Message<?>>",
    "mockedClass": "Subscriber<Message<?>>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.channel.reactive",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\reactive\\ReactiveStreamsConsumerTests.java",
      "className": "ReactiveStreamsConsumerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Subscriber<Message<?>> testSubscriber = (Subscriber<Message<?>>) Mockito.mock(Subscriber.class);",
        "line": 183,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReactiveStreamsConsumerPollableChannel",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(testSubscriber).onSubscribe(subscriptionArgumentCaptor.capture());",
        "line": 211,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReactiveStreamsConsumerPollableChannel",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(testSubscriber, times(2)).onSubscribe(subscriptionArgumentCaptor.capture());",
        "line": 226,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReactiveStreamsConsumerPollableChannel",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(testSubscriber, never()).onError(any(Throwable.class));",
        "line": 245,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReactiveStreamsConsumerPollableChannel",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(testSubscriber, never()).onComplete();",
        "line": 246,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReactiveStreamsConsumerPollableChannel",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.channel.registry",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\registry\\HeaderChannelRegistryTests.java",
      "className": "HeaderChannelRegistryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 209,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBFCRWithRegistry",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getBean(IntegrationContextUtils.INTEGRATION_HEADER_CHANNEL_REGISTRY_BEAN_NAME, HeaderChannelRegistry.class)).thenReturn(mock(HeaderChannelRegistry.class));",
        "line": 210,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBFCRWithRegistry",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.channel.registry",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\channel\\registry\\HeaderChannelRegistryTests.java",
      "className": "HeaderChannelRegistryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 226,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBFCRNoRegistry",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "log",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config.annotation",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\annotation\\CustomMessagingAnnotationTests.java",
      "className": "CustomMessagingAnnotationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor log = spy(TestUtils.getPropertyValue(this.loggingHandler, \"messageLogger\", LogAccessor.class));",
        "line": 79,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLogAnnotation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(log.isWarnEnabled()).willReturn(true);",
        "line": 81,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLogAnnotation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(log).warn(argumentCaptor.capture());",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLogAnnotation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "GenericApplicationContext",
    "mockedClass": "GenericApplicationContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config.annotation",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\annotation\\SubscriberOrderTests.java",
      "className": "SubscriberOrderTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "try (GenericApplicationContext context = TestUtils.createTestApplicationContext()) {\r\n    new IntegrationRegistrar().registerBeanDefinitions(mock(), context.getDefaultListableBeanFactory());\r\n    RootBeanDefinition channelDefinition = new RootBeanDefinition(DirectChannel.class);\r\n    context.registerBeanDefinition(\"input\", channelDefinition);\r\n    RootBeanDefinition testBeanDefinition = new RootBeanDefinition(TestBean.class);\r\n    testBeanDefinition.getConstructorArgumentValues().addGenericArgumentValue(1);\r\n    context.registerBeanDefinition(\"testBean\", testBeanDefinition);\r\n    context.refresh();\r\n    TestBean testBean = (TestBean) context.getBean(\"testBean\");\r\n    MessageChannel channel = (MessageChannel) context.getBean(\"input\");\r\n    channel.send(new GenericMessage<>(\"test-1\"));\r\n    channel.send(new GenericMessage<>(\"test-2\"));\r\n    channel.send(new GenericMessage<>(\"test-3\"));\r\n    channel.send(new GenericMessage<>(\"test-4\"));\r\n    channel.send(new GenericMessage<>(\"test-5\"));\r\n    List<Integer> calls = testBean.calls;\r\n    assertThat(calls.size()).isEqualTo(5);\r\n    assertThat(calls.get(0).intValue()).isEqualTo(1);\r\n    assertThat(calls.get(1).intValue()).isEqualTo(2);\r\n    assertThat(calls.get(2).intValue()).isEqualTo(3);\r\n    assertThat(calls.get(3).intValue()).isEqualTo(4);\r\n    assertThat(calls.get(4).intValue()).isEqualTo(5);\r\n}",
        "line": 50,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "directChannelAndFailoverDispatcherWithSingleCallPerMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "GenericApplicationContext",
    "mockedClass": "GenericApplicationContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config.annotation",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\annotation\\SubscriberOrderTests.java",
      "className": "SubscriberOrderTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "try (GenericApplicationContext context = TestUtils.createTestApplicationContext()) {\r\n    new IntegrationRegistrar().registerBeanDefinitions(mock(), context.getDefaultListableBeanFactory());\r\n    BeanDefinitionBuilder channelBuilder = BeanDefinitionBuilder.rootBeanDefinition(DirectChannel.class);\r\n    channelBuilder.addConstructorArgValue(null);\r\n    RootBeanDefinition channelDefinition = (RootBeanDefinition) channelBuilder.getBeanDefinition();\r\n    context.registerBeanDefinition(\"input\", channelDefinition);\r\n    RootBeanDefinition testBeanDefinition = new RootBeanDefinition(TestBean.class);\r\n    testBeanDefinition.getConstructorArgumentValues().addGenericArgumentValue(2);\r\n    context.registerBeanDefinition(\"testBean\", testBeanDefinition);\r\n    context.refresh();\r\n    TestBean testBean = (TestBean) context.getBean(\"testBean\");\r\n    MessageChannel channel = (MessageChannel) context.getBean(\"input\");\r\n    channel.send(new GenericMessage<>(\"test-1\"));\r\n    channel.send(new GenericMessage<>(\"test-2\"));\r\n    channel.send(new GenericMessage<>(\"test-3\"));\r\n    channel.send(new GenericMessage<>(\"test-4\"));\r\n    channel.send(new GenericMessage<>(\"test-5\"));\r\n    channel.send(new GenericMessage<>(\"test-6\"));\r\n    channel.send(new GenericMessage<>(\"test-7\"));\r\n    channel.send(new GenericMessage<>(\"test-8\"));\r\n    channel.send(new GenericMessage<>(\"test-9\"));\r\n    channel.send(new GenericMessage<>(\"test-10\"));\r\n    assertThat(testBean.calls.size()).isEqualTo(10);\r\n    assertThat(testBean.calls.get(0).intValue()).isEqualTo(1);\r\n    assertThat(testBean.calls.get(1).intValue()).isEqualTo(1);\r\n    assertThat(testBean.calls.get(2).intValue()).isEqualTo(2);\r\n    assertThat(testBean.calls.get(3).intValue()).isEqualTo(2);\r\n    assertThat(testBean.calls.get(4).intValue()).isEqualTo(3);\r\n    assertThat(testBean.calls.get(5).intValue()).isEqualTo(3);\r\n    assertThat(testBean.calls.get(6).intValue()).isEqualTo(4);\r\n    assertThat(testBean.calls.get(7).intValue()).isEqualTo(4);\r\n    assertThat(testBean.calls.get(8).intValue()).isEqualTo(5);\r\n    assertThat(testBean.calls.get(9).intValue()).isEqualTo(5);\r\n    testBean.reset();\r\n    channel.send(new GenericMessage<>(\"test-11\"));\r\n    assertThat(testBean.calls.size()).isEqualTo(1);\r\n    assertThat(testBean.calls.get(0).intValue()).isEqualTo(1);\r\n}",
        "line": 77,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "directChannelAndFailoverDispatcherWithMultipleCallsPerMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "GenericApplicationContext",
    "mockedClass": "GenericApplicationContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config.annotation",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\annotation\\SubscriberOrderTests.java",
      "className": "SubscriberOrderTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "try (GenericApplicationContext context = TestUtils.createTestApplicationContext()) {\r\n    new IntegrationRegistrar().registerBeanDefinitions(mock(), context.getDefaultListableBeanFactory());\r\n    RootBeanDefinition channelDefinition = new RootBeanDefinition(DirectChannel.class);\r\n    channelDefinition.getConstructorArgumentValues().addGenericArgumentValue(new RoundRobinLoadBalancingStrategy());\r\n    context.registerBeanDefinition(\"input\", channelDefinition);\r\n    RootBeanDefinition testBeanDefinition = new RootBeanDefinition(TestBean.class);\r\n    testBeanDefinition.getConstructorArgumentValues().addGenericArgumentValue(1000);\r\n    context.registerBeanDefinition(\"testBean\", testBeanDefinition);\r\n    context.refresh();\r\n    TestBean testBean = (TestBean) context.getBean(\"testBean\");\r\n    MessageChannel channel = (MessageChannel) context.getBean(\"input\");\r\n    channel.send(new GenericMessage<>(\"test-1\"));\r\n    channel.send(new GenericMessage<>(\"test-2\"));\r\n    channel.send(new GenericMessage<>(\"test-3\"));\r\n    channel.send(new GenericMessage<>(\"test-4\"));\r\n    channel.send(new GenericMessage<>(\"test-5\"));\r\n    List<Integer> calls = testBean.calls;\r\n    assertThat(calls.size()).isEqualTo(5);\r\n    assertThat(calls.get(0).intValue()).isEqualTo(1);\r\n    assertThat(calls.get(1).intValue()).isEqualTo(2);\r\n    assertThat(calls.get(2).intValue()).isEqualTo(3);\r\n    assertThat(calls.get(3).intValue()).isEqualTo(4);\r\n    assertThat(calls.get(4).intValue()).isEqualTo(5);\r\n}",
        "line": 119,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "directChannelAndRoundRobinDispatcher",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\ChainParserTests.java",
      "className": "ChainParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = mock(LogAccessor.class);",
        "line": 300,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "chainWithLoggingChannelAdapter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isWarnEnabled()).thenReturn(true);",
        "line": 302,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "chainWithLoggingChannelAdapter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channelInterceptor",
    "variableType": "ChannelInterceptor",
    "mockedClass": "ChannelInterceptor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\GlobalChannelInterceptorProcessorTests.java",
      "className": "GlobalChannelInterceptorProcessorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ChannelInterceptor channelInterceptor = Mockito.mock(ChannelInterceptor.class);",
        "line": 69,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorDefaultPattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "InterceptableChannel",
    "mockedClass": "InterceptableChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\GlobalChannelInterceptorProcessorTests.java",
      "className": "GlobalChannelInterceptorProcessorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InterceptableChannel channel = Mockito.mock(InterceptableChannel.class);",
        "line": 73,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorDefaultPattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(channel).addInterceptor(channelInterceptor);",
        "line": 84,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorDefaultPattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channelInterceptor",
    "variableType": "ChannelInterceptor",
    "mockedClass": "ChannelInterceptor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\GlobalChannelInterceptorProcessorTests.java",
      "className": "GlobalChannelInterceptorProcessorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ChannelInterceptor channelInterceptor = Mockito.mock(ChannelInterceptor.class);",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorMatchingPattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "InterceptableChannel",
    "mockedClass": "InterceptableChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\GlobalChannelInterceptorProcessorTests.java",
      "className": "GlobalChannelInterceptorProcessorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InterceptableChannel channel = Mockito.mock(InterceptableChannel.class);",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorMatchingPattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(channel).addInterceptor(channelInterceptor);",
        "line": 107,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorMatchingPattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channelInterceptor",
    "variableType": "ChannelInterceptor",
    "mockedClass": "ChannelInterceptor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\GlobalChannelInterceptorProcessorTests.java",
      "className": "GlobalChannelInterceptorProcessorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ChannelInterceptor channelInterceptor = Mockito.mock(ChannelInterceptor.class);",
        "line": 115,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorNotMatchingPattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "InterceptableChannel",
    "mockedClass": "InterceptableChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\GlobalChannelInterceptorProcessorTests.java",
      "className": "GlobalChannelInterceptorProcessorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InterceptableChannel channel = Mockito.mock(InterceptableChannel.class);",
        "line": 119,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorNotMatchingPattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(channel, Mockito.never()).addInterceptor(channelInterceptor);",
        "line": 131,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorNotMatchingPattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channelInterceptor",
    "variableType": "ChannelInterceptor",
    "mockedClass": "ChannelInterceptor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\GlobalChannelInterceptorProcessorTests.java",
      "className": "GlobalChannelInterceptorProcessorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ChannelInterceptor channelInterceptor = Mockito.mock(ChannelInterceptor.class);",
        "line": 139,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorMatchingNegativePattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "InterceptableChannel",
    "mockedClass": "InterceptableChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\GlobalChannelInterceptorProcessorTests.java",
      "className": "GlobalChannelInterceptorProcessorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InterceptableChannel channel = Mockito.mock(InterceptableChannel.class);",
        "line": 143,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorMatchingNegativePattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(channel, Mockito.never()).addInterceptor(channelInterceptor);",
        "line": 154,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProcessorWithInterceptorMatchingNegativePattern",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "TestApplicationContext",
    "mockedClass": "TestApplicationContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\ServiceActivatorAnnotationPostProcessorTests.java",
      "className": "ServiceActivatorAnnotationPostProcessorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "try (TestApplicationContext context = TestUtils.createTestApplicationContext()) {\r\n    new IntegrationRegistrar().registerBeanDefinitions(mock(), context.getDefaultListableBeanFactory());\r\n    context.registerBeanDefinition(\"testChannel\", new RootBeanDefinition(DirectChannel.class));\r\n    RootBeanDefinition beanDefinition = new RootBeanDefinition(SimpleServiceActivatorAnnotationTestBean.class);\r\n    beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(latch);\r\n    context.registerBeanDefinition(\"testBean\", beanDefinition);\r\n    context.refresh();\r\n    SimpleServiceActivatorAnnotationTestBean testBean = context.getBean(\"testBean\", SimpleServiceActivatorAnnotationTestBean.class);\r\n    assertThat(latch.getCount()).isEqualTo(1);\r\n    assertThat(testBean.getMessageText()).isNull();\r\n    MessageChannel testChannel = (MessageChannel) context.getBean(\"testChannel\");\r\n    testChannel.send(new GenericMessage<>(\"test-123\"));\r\n    assertThat(latch.await(1000, TimeUnit.MILLISECONDS)).isTrue();\r\n    assertThat(testBean.getMessageText()).isEqualTo(\"test-123\");\r\n}",
        "line": 45,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAnnotatedMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "txAdvice",
    "variableType": "MethodInterceptor",
    "mockedClass": "MethodInterceptor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\SourcePollingChannelAdapterFactoryBeanTests.java",
      "className": "SourcePollingChannelAdapterFactoryBeanTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final MethodInterceptor txAdvice = mock(MethodInterceptor.class);",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionalAdviceChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(txAdvice.invoke(any(MethodInvocation.class))).thenAnswer(invocation -> {\r\n    count.incrementAndGet();\r\n    return ((MethodInvocation) invocation.getArgument(0)).proceed();\r\n});",
        "line": 127,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionalAdviceChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "adapterLogger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\SourcePollingChannelAdapterFactoryBeanTests.java",
      "className": "SourcePollingChannelAdapterFactoryBeanTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor adapterLogger = TestUtils.getPropertyValue(pollingChannelAdapter, \"logger\", LogAccessor.class);",
        "line": 180,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInterrupted",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "adapterLogger = spy(adapterLogger);",
        "line": 181,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInterrupted",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(adapterLogger.isDebugEnabled()).thenReturn(true);",
        "line": 182,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInterrupted",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(adapterLogger).debug(ArgumentMatchers.<Supplier<String>>argThat(logMessage -> logMessage.get().contains(\"Poll interrupted - during stop()?\")));",
        "line": 195,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInterrupted",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "errorHandlerLogger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\SourcePollingChannelAdapterFactoryBeanTests.java",
      "className": "SourcePollingChannelAdapterFactoryBeanTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log errorHandlerLogger = TestUtils.getPropertyValue(errorHandler, \"logger\", Log.class);",
        "line": 169,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInterrupted",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "errorHandlerLogger = spy(errorHandlerLogger);",
        "line": 170,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInterrupted",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verifyNoInteractions(errorHandlerLogger);",
        "line": 194,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInterrupted",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "taskScheduler",
    "variableType": "TaskScheduler",
    "mockedClass": "TaskScheduler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\SourcePollingChannelAdapterFactoryBeanTests.java",
      "className": "SourcePollingChannelAdapterFactoryBeanTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TaskScheduler taskScheduler = mock(TaskScheduler.class);",
        "line": 202,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStartSourceBeforeRunPollingTask",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\SourcePollingChannelAdapterFactoryBeanTests.java",
      "className": "SourcePollingChannelAdapterFactoryBeanTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(pollingChannelAdapter, \"logger\", LogAccessor.class));",
        "line": 242,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testZeroForMaxMessagesPerPoll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, atLeastOnce()).info(\"Polling disabled while 'maxMessagesPerPoll == 0'\");",
        "line": 258,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testZeroForMaxMessagesPerPoll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config.xml",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\xml\\GatewayParserTests.java",
      "className": "GatewayParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(gateway, \"logger\", LogAccessor.class));",
        "line": 299,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomCompletableNoAsyncAttemptAsync",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isDebugEnabled()).thenReturn(true);",
        "line": 300,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomCompletableNoAsyncAttemptAsync",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).debug(ArgumentMatchers.<Supplier<String>>argThat(logMessage -> logMessage.get().equals(\"AsyncTaskExecutor submit*() return types are incompatible \" + \"with the method return type; \" + \"running on calling thread; the downstream flow must return the required Future: \" + \"MyCompletableFuture\")));",
        "line": 321,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomCompletableNoAsyncAttemptAsync",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.config.xml",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\xml\\PollerWithErrorChannelTests.java",
      "className": "PollerWithErrorChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 59,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithErrorChannelAsHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config.xml",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\xml\\PublishingInterceptorParserTests.java",
      "className": "PublishingInterceptorParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = Mockito.mock(MessageHandler.class);",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateDefaultChannelPublishing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(1)).handleMessage(any(Message.class));",
        "line": 69,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateDefaultChannelPublishing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.config.xml",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\config\\xml\\PublishingInterceptorParserTests.java",
      "className": "PublishingInterceptorParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = Mockito.mock(MessageHandler.class);",
        "line": 74,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateEchoChannelPublishing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(1)).handleMessage(any(Message.class));",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateEchoChannelPublishing",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.configuration",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\configuration\\EnableIntegrationTests.java",
      "className": "EnableIntegrationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(this.serviceActivatorEndpoint, \"logger\", LogAccessor.class));",
        "line": 331,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAnnotatedServiceActivator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isDebugEnabled()).thenReturn(true);",
        "line": 332,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAnnotatedServiceActivator",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageMock",
    "variableType": "Message<?>",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\BroadcastingDispatcherTests.java",
      "className": "BroadcastingDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final Message<?> messageMock = Mockito.mock(Message.class);",
        "line": 57,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "targetMock3",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\BroadcastingDispatcherTests.java",
      "className": "BroadcastingDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageHandler targetMock3 = Mockito.mock(MessageHandler.class);",
        "line": 63,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3).handleMessage(eq(messageMock));",
        "line": 98,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithoutTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3).handleMessage(eq(messageMock));",
        "line": 110,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3).handleMessage(eq(messageMock));",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureFirst",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3).handleMessage(eq(messageMock));",
        "line": 136,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureMiddle",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 149,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureLast",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 162,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsAllFail",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3).handleMessage(eq(messageMock));",
        "line": 185,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBeforeSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3, Mockito.times(2)).handleMessage(eq(messageMock));",
        "line": 199,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBetweenSends",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "targetMock2",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\BroadcastingDispatcherTests.java",
      "className": "BroadcastingDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageHandler targetMock2 = Mockito.mock(MessageHandler.class);",
        "line": 61,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2).handleMessage(eq(messageMock));",
        "line": 97,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithoutTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2).handleMessage(eq(messageMock));",
        "line": 109,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2).handleMessage(eq(messageMock));",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureFirst",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 135,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureMiddle",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2).handleMessage(eq(messageMock));",
        "line": 148,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureLast",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 161,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsAllFail",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 184,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBeforeSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2).handleMessage(eq(messageMock));",
        "line": 198,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBetweenSends",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "targetMock1",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\BroadcastingDispatcherTests.java",
      "className": "BroadcastingDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageHandler targetMock1 = Mockito.mock(MessageHandler.class);",
        "line": 59,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 78,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "singleTargetWithoutTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "singleTargetWithTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithoutTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 108,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 121,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureFirst",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 134,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureMiddle",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureLast",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 160,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsAllFail",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 172,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noDuplicateSubscription",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 183,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBeforeSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1, Mockito.times(2)).handleMessage(eq(messageMock));",
        "line": 197,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBetweenSends",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "taskExecutorMock",
    "variableType": "TaskExecutor",
    "mockedClass": "TaskExecutor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\BroadcastingDispatcherTests.java",
      "className": "BroadcastingDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final TaskExecutor taskExecutorMock = Mockito.mock(TaskExecutor.class);",
        "line": 55,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "messageMock",
    "variableType": "Message<?>",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\BroadcastingDispatcherTests.java",
      "className": "BroadcastingDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final Message<?> messageMock = Mockito.mock(Message.class);",
        "line": 57,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "targetMock3",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\BroadcastingDispatcherTests.java",
      "className": "BroadcastingDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageHandler targetMock3 = Mockito.mock(MessageHandler.class);",
        "line": 63,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3).handleMessage(eq(messageMock));",
        "line": 98,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithoutTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3).handleMessage(eq(messageMock));",
        "line": 110,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3).handleMessage(eq(messageMock));",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureFirst",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3).handleMessage(eq(messageMock));",
        "line": 136,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureMiddle",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 149,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureLast",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 162,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsAllFail",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3).handleMessage(eq(messageMock));",
        "line": 185,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBeforeSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock3, Mockito.times(2)).handleMessage(eq(messageMock));",
        "line": 199,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBetweenSends",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "targetMock2",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\BroadcastingDispatcherTests.java",
      "className": "BroadcastingDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageHandler targetMock2 = Mockito.mock(MessageHandler.class);",
        "line": 61,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2).handleMessage(eq(messageMock));",
        "line": 97,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithoutTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2).handleMessage(eq(messageMock));",
        "line": 109,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2).handleMessage(eq(messageMock));",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureFirst",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 135,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureMiddle",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2).handleMessage(eq(messageMock));",
        "line": 148,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureLast",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 161,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsAllFail",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 184,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBeforeSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock2).handleMessage(eq(messageMock));",
        "line": 198,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBetweenSends",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "targetMock1",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\BroadcastingDispatcherTests.java",
      "className": "BroadcastingDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageHandler targetMock1 = Mockito.mock(MessageHandler.class);",
        "line": 59,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 78,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "singleTargetWithoutTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "singleTargetWithTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithoutTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 108,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsWithTaskExecutor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 121,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureFirst",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 134,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureMiddle",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsPartialFailureLast",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1, Mockito.never()).handleMessage(eq(messageMock));",
        "line": 160,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleTargetsAllFail",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 172,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noDuplicateSubscription",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1).handleMessage(eq(messageMock));",
        "line": 183,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBeforeSend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(targetMock1, Mockito.times(2)).handleMessage(eq(messageMock));",
        "line": 197,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "removeConsumerBetweenSends",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "taskExecutorMock",
    "variableType": "TaskExecutor",
    "mockedClass": "TaskExecutor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\BroadcastingDispatcherTests.java",
      "className": "BroadcastingDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final TaskExecutor taskExecutorMock = Mockito.mock(TaskExecutor.class);",
        "line": 55,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "handler4",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\RoundRobinDispatcherConcurrentTests.java",
      "className": "RoundRobinDispatcherConcurrentTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageHandler handler4;",
        "line": 65,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler4, times(TOTAL_EXECUTIONS / 4)).handleMessage(message);",
        "line": 115,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noHandlerExhaustion",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler3",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\RoundRobinDispatcherConcurrentTests.java",
      "className": "RoundRobinDispatcherConcurrentTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageHandler handler3;",
        "line": 62,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler3, times(TOTAL_EXECUTIONS / 4)).handleMessage(message);",
        "line": 114,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noHandlerExhaustion",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler2",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\RoundRobinDispatcherConcurrentTests.java",
      "className": "RoundRobinDispatcherConcurrentTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageHandler handler2;",
        "line": 59,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler2, times(TOTAL_EXECUTIONS / 4)).handleMessage(message);",
        "line": 113,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noHandlerExhaustion",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler2, times(TOTAL_EXECUTIONS)).handleMessage(message);",
        "line": 177,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noHandlerSkipUnderConcurrentFailureWithFailover",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler1",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\RoundRobinDispatcherConcurrentTests.java",
      "className": "RoundRobinDispatcherConcurrentTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageHandler handler1;",
        "line": 56,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler1, times(TOTAL_EXECUTIONS / 4)).handleMessage(message);",
        "line": 112,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noHandlerExhaustion",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler1, times(TOTAL_EXECUTIONS / 2)).handleMessage(message);",
        "line": 176,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noHandlerSkipUnderConcurrentFailureWithFailover",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "message",
    "variableType": "Message<?>",
    "mockedClass": "Message<?>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\RoundRobinDispatcherConcurrentTests.java",
      "className": "RoundRobinDispatcherConcurrentTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate Message<?> message;",
        "line": 68,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      }
    ]
  },
  {
    "variableName": "log",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\RoundRobinDispatcherTests.java",
      "className": "RoundRobinDispatcherTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log log = (Log) spy(directFieldAccessor.getPropertyType(\"logger\"));",
        "line": 156,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailOverAndLogging",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(log.isDebugEnabled()).willReturn(true);",
        "line": 157,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailOverAndLogging",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(log).debug(startsWith(\"An exception was thrown by '\"), eq(testException));",
        "line": 165,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailOverAndLogging",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\RoundRobinDispatcherTests.java",
      "className": "RoundRobinDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageHandler handler;",
        "line": 57,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.handler).handleMessage(this.message);",
        "line": 76,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "dispatchMessageWithSingleHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.handler).handleMessage(this.message);",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "differentHandlerInvokedOnSecondMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.handler, times(4)).handleMessage(this.message);",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleCyclesThroughHandlers",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.handler, atLeast(18)).handleMessage(this.message);",
        "line": 109,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "currentHandlerIndexOverFlow",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.handler).handleMessage(this.message);",
        "line": 162,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailOverAndLogging",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "differentHandler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\RoundRobinDispatcherTests.java",
      "className": "RoundRobinDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageHandler differentHandler;",
        "line": 63,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.differentHandler).handleMessage(this.message);",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "differentHandlerInvokedOnSecondMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.differentHandler, times(3)).handleMessage(this.message);",
        "line": 97,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "multipleCyclesThroughHandlers",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.differentHandler, atLeast(18)).handleMessage(this.message);",
        "line": 110,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "currentHandlerIndexOverFlow",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.differentHandler).handleMessage(this.message);",
        "line": 163,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailOverAndLogging",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "message",
    "variableType": "Message<?>",
    "mockedClass": "Message<?>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.dispatcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\dispatcher\\RoundRobinDispatcherTests.java",
      "className": "RoundRobinDispatcherTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate Message<?> message;",
        "line": 60,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      }
    ]
  },
  {
    "variableName": "callback",
    "variableType": "AcknowledgmentCallback",
    "mockedClass": "AcknowledgmentCallback",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.endpoint",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\endpoint\\MessageSourcePollingTemplateTests.java",
      "className": "MessageSourcePollingTemplateTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AcknowledgmentCallback callback = mock(AcknowledgmentCallback.class);",
        "line": 47,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckNack",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(callback.isAutoAck()).willReturn(true);",
        "line": 48,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckNack",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(callback).acknowledge(Status.ACCEPT);",
        "line": 54,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckNack",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(callback).acknowledge(Status.REJECT);",
        "line": 64,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckNack",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "callback",
    "variableType": "AcknowledgmentCallback",
    "mockedClass": "AcknowledgmentCallback",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.endpoint",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\endpoint\\MessageSourcePollingTemplateTests.java",
      "className": "MessageSourcePollingTemplateTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AcknowledgmentCallback callback = mock(AcknowledgmentCallback.class);",
        "line": 69,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoAutoAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(callback.isAutoAck()).willReturn(false);",
        "line": 70,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoAutoAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(callback, never()).acknowledge(Status.ACCEPT);",
        "line": 76,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoAutoAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(callback, never()).acknowledge(Status.REJECT);",
        "line": 77,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoAutoAck",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "override",
    "variableType": "Trigger",
    "mockedClass": "Trigger",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.endpoint",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\endpoint\\PollerAdviceTests.java",
      "className": "PollerAdviceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Trigger override = spy(new PeriodicTrigger(Duration.ofMillis(5)));",
        "line": 341,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCompoundTriggerAdvice",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(override, atLeast(2)).nextExecution(any(TriggerContext.class));",
        "line": 364,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCompoundTriggerAdvice",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.endpoint",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\endpoint\\PollingLifecycleTests.java",
      "className": "PollingLifecycleTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "//Has to be an explicit implementation - Mockito cannot mock/spy lambdas\r\nMessageHandler handler = Mockito.spy(new MessageHandler() {\r\n\r\n    @Override\r\n    public void handleMessage(Message<?> message) throws MessagingException {\r\n        latch.countDown();\r\n    }\r\n});",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "ensurePollerTaskStops",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(handler, times(1)).handleMessage(Mockito.any(Message.class));",
        "line": 99,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "ensurePollerTaskStops",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(handler, atMost(1)).handleMessage(Mockito.any(Message.class));",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "ensurePollerTaskStops",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "source",
    "variableType": "MessageSource<String>",
    "mockedClass": "MessageSource<String>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.endpoint",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\endpoint\\PollingLifecycleTests.java",
      "className": "PollingLifecycleTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "//Has to be an explicit implementation - Mockito cannot mock/spy lambdas\r\nMessageSource<String> source = spy(new MessageSource<String>() {\r\n\r\n    @Override\r\n    public Message<String> receive() {\r\n        return new GenericMessage<>(\"hello\");\r\n    }\r\n});",
        "line": 118,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "ensurePollerTaskStopsForAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(source, times(1)).receive();",
        "line": 136,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "ensurePollerTaskStopsForAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "caughtInterrupted",
    "variableType": "Runnable",
    "mockedClass": "Runnable",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.endpoint",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\endpoint\\PollingLifecycleTests.java",
      "className": "PollingLifecycleTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final Runnable caughtInterrupted = mock(Runnable.class);",
        "line": 149,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "ensurePollerTaskStopsForAdapterWithInterruptible",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(caughtInterrupted, times(1)).run();",
        "line": 178,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "ensurePollerTaskStopsForAdapterWithInterruptible",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mock",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.endpoint",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\endpoint\\ServiceActivatorEndpointTests.java",
      "className": "ServiceActivatorEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory mock = mock(BeanFactory.class);",
        "line": 231,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBeanFactoryPopulation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayInterfaceTests.java",
      "className": "GatewayInterfaceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 223,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceAnnotatedMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(1)).handleMessage(Mockito.any(Message.class));",
        "line": 227,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceAnnotatedMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayInterfaceTests.java",
      "className": "GatewayInterfaceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 282,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceCastAsSuperclassAnnotatedMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(1)).handleMessage(Mockito.any(Message.class));",
        "line": 286,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceCastAsSuperclassAnnotatedMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayInterfaceTests.java",
      "className": "GatewayInterfaceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 295,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceCastAsSuperclassUnAnnotatedMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(1)).handleMessage(Mockito.any(Message.class));",
        "line": 299,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceCastAsSuperclassUnAnnotatedMethod",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayInterfaceTests.java",
      "className": "GatewayInterfaceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 308,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceHashcode",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(0)).handleMessage(Mockito.any(Message.class));",
        "line": 312,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceHashcode",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayInterfaceTests.java",
      "className": "GatewayInterfaceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 321,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceToString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(0)).handleMessage(Mockito.any(Message.class));",
        "line": 325,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceToString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayInterfaceTests.java",
      "className": "GatewayInterfaceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 334,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceEquals",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(0)).handleMessage(Mockito.any(Message.class));",
        "line": 346,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceEquals",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayInterfaceTests.java",
      "className": "GatewayInterfaceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 355,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceGetClass",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(0)).handleMessage(Mockito.any(Message.class));",
        "line": 359,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithServiceGetClass",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageHandler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayInterfaceTests.java",
      "className": "GatewayInterfaceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler messageHandler = mock(MessageHandler.class);",
        "line": 507,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIgnoredHeader",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(messageHandler).handleMessage(messageArgumentCaptor.capture());",
        "line": 514,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIgnoredHeader",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageHandler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayInterfaceTests.java",
      "className": "GatewayInterfaceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler messageHandler = mock(MessageHandler.class);",
        "line": 550,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "primaryMarkerWins",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(messageHandler).handleMessage(messageArgumentCaptor.capture());",
        "line": 558,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "primaryMarkerWins",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "stringToByteConverter",
    "variableType": "Converter<String,byte[]>",
    "mockedClass": "Converter<String,byte[]>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayProxyFactoryBeanTests.java",
      "className": "GatewayProxyFactoryBeanTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Converter<String, byte[]> stringToByteConverter = // Has to an interface (not lambda) to honor Mockito\r\nnew Converter<String, byte[]>() {\r\n\r\n    @Override\r\n    public byte[] convert(String source) {\r\n        return source.getBytes();\r\n    }\r\n};",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRequestReplyWithAnonymousChannelConvertedTypeViaConversionService",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "stringToByteConverter = spy(stringToByteConverter);",
        "line": 111,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRequestReplyWithAnonymousChannelConvertedTypeViaConversionService",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(stringToByteConverter, Mockito.times(1)).convert(Mockito.any(String.class));",
        "line": 124,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRequestReplyWithAnonymousChannelConvertedTypeViaConversionService",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\GatewayProxyFactoryBeanTests.java",
      "className": "GatewayProxyFactoryBeanTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 145,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOneWayIgnoreReply",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "replyChannel",
    "variableType": "PollableChannel",
    "mockedClass": "PollableChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\MessagingGatewayTests.java",
      "className": "MessagingGatewayTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final PollableChannel replyChannel = Mockito.mock(PollableChannel.class);",
        "line": 64,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(replyChannel.receive(30000L)).thenReturn(messageMock);",
        "line": 139,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(replyChannel).receive(30000L);",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(replyChannel.receive(30000L)).thenReturn(null);",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage_null",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(replyChannel).receive(30000L);",
        "line": 149,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage_null",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageMock",
    "variableType": "Message",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\MessagingGatewayTests.java",
      "className": "MessagingGatewayTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@SuppressWarnings(\"rawtypes\")\r\nprivate final Message messageMock = Mockito.mock(Message.class);",
        "line": 66,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(this.messageMock.getHeaders()).thenReturn(new MessageHeaders(Collections.emptyMap()));",
        "line": 81,
        "locate": "@Before",
        "locationContext": {
          "methodName": "initializeSample",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getHeaders()).thenReturn(new MessageHeaders(null));",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage_failure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"test\");",
        "line": 140,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"test\");",
        "line": 157,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendObjectAndReceiveObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getHeaders()).thenReturn(messageHeadersMock);",
        "line": 176,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"foo\");",
        "line": 177,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"foo\");",
        "line": 199,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendObjectAndReceiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getHeaders()).thenReturn(messageHeadersMock);",
        "line": 220,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"foo\");",
        "line": 221,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "requestChannel",
    "variableType": "MessageChannel",
    "mockedClass": "MessageChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\MessagingGatewayTests.java",
      "className": "MessagingGatewayTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageChannel requestChannel = Mockito.mock(MessageChannel.class);",
        "line": 62,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(requestChannel.send(messageMock, 30000L)).thenReturn(true);",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(requestChannel).send(messageMock, 30000L);",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(requestChannel.send(messageMock, 1000L)).thenReturn(false);",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage_failure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(requestChannel).send(Mockito.any(Message.class), Mockito.eq(30000L));",
        "line": 115,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "replyChannel",
    "variableType": "PollableChannel",
    "mockedClass": "PollableChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\MessagingGatewayTests.java",
      "className": "MessagingGatewayTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final PollableChannel replyChannel = Mockito.mock(PollableChannel.class);",
        "line": 64,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(replyChannel.receive(30000L)).thenReturn(messageMock);",
        "line": 139,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(replyChannel).receive(30000L);",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(replyChannel.receive(30000L)).thenReturn(null);",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage_null",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(replyChannel).receive(30000L);",
        "line": 149,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage_null",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageMock",
    "variableType": "Message",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\MessagingGatewayTests.java",
      "className": "MessagingGatewayTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@SuppressWarnings(\"rawtypes\")\r\nprivate final Message messageMock = Mockito.mock(Message.class);",
        "line": 66,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(this.messageMock.getHeaders()).thenReturn(new MessageHeaders(Collections.emptyMap()));",
        "line": 81,
        "locate": "@Before",
        "locationContext": {
          "methodName": "initializeSample",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getHeaders()).thenReturn(new MessageHeaders(null));",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage_failure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"test\");",
        "line": 140,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"test\");",
        "line": 157,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendObjectAndReceiveObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getHeaders()).thenReturn(messageHeadersMock);",
        "line": 176,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"foo\");",
        "line": 177,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"foo\");",
        "line": 199,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendObjectAndReceiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getHeaders()).thenReturn(messageHeadersMock);",
        "line": 220,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"foo\");",
        "line": 221,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "requestChannel",
    "variableType": "MessageChannel",
    "mockedClass": "MessageChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\MessagingGatewayTests.java",
      "className": "MessagingGatewayTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageChannel requestChannel = Mockito.mock(MessageChannel.class);",
        "line": 62,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(requestChannel.send(messageMock, 30000L)).thenReturn(true);",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(requestChannel).send(messageMock, 30000L);",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(requestChannel.send(messageMock, 1000L)).thenReturn(false);",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage_failure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(requestChannel).send(Mockito.any(Message.class), Mockito.eq(30000L));",
        "line": 115,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "replyChannel",
    "variableType": "PollableChannel",
    "mockedClass": "PollableChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\MessagingGatewayTests.java",
      "className": "MessagingGatewayTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final PollableChannel replyChannel = Mockito.mock(PollableChannel.class);",
        "line": 64,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(replyChannel.receive(30000L)).thenReturn(messageMock);",
        "line": 139,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(replyChannel).receive(30000L);",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(replyChannel.receive(30000L)).thenReturn(null);",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage_null",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(replyChannel).receive(30000L);",
        "line": 149,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage_null",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageMock",
    "variableType": "Message",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\MessagingGatewayTests.java",
      "className": "MessagingGatewayTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@SuppressWarnings(\"rawtypes\")\r\nprivate final Message messageMock = Mockito.mock(Message.class);",
        "line": 66,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(this.messageMock.getHeaders()).thenReturn(new MessageHeaders(Collections.emptyMap()));",
        "line": 81,
        "locate": "@Before",
        "locationContext": {
          "methodName": "initializeSample",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getHeaders()).thenReturn(new MessageHeaders(null));",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage_failure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"test\");",
        "line": 140,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"test\");",
        "line": 157,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendObjectAndReceiveObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getHeaders()).thenReturn(messageHeadersMock);",
        "line": 176,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"foo\");",
        "line": 177,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"foo\");",
        "line": 199,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendObjectAndReceiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getHeaders()).thenReturn(messageHeadersMock);",
        "line": 220,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageMock.getPayload()).thenReturn(\"foo\");",
        "line": 221,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessageAndReceiveMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "requestChannel",
    "variableType": "MessageChannel",
    "mockedClass": "MessageChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\gateway\\MessagingGatewayTests.java",
      "className": "MessagingGatewayTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final MessageChannel requestChannel = Mockito.mock(MessageChannel.class);",
        "line": 62,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(requestChannel.send(messageMock, 30000L)).thenReturn(true);",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(requestChannel).send(messageMock, 30000L);",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(requestChannel.send(messageMock, 1000L)).thenReturn(false);",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendMessage_failure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(requestChannel).send(Mockito.any(Message.class), Mockito.eq(30000L));",
        "line": 115,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendObject",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "MessageChannel",
    "mockedClass": "MessageChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\AbstractReplyProducingMessageHandlerTests.java",
      "className": "AbstractReplyProducingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private MessageChannel channel;",
        "line": 59,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "channel = mock(MessageChannel.class);",
        "line": 63,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(this.channel.send(this.message)).willReturn(false);",
        "line": 71,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "errorMessageShouldContainChannelName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(this.channel.toString()).willReturn(\"testChannel\");",
        "line": 72,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "errorMessageShouldContainChannelName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "methodInvocation",
    "variableType": "MethodInvocation",
    "mockedClass": "MethodInvocation",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.handler.advice",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\advice\\AdvisedMessageHandlerTests.java",
      "className": "AdvisedMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MethodInvocation methodInvocation = mock(MethodInvocation.class);",
        "line": 831,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "throwableProperlyPropagated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(methodInvocation.getMethod()).thenReturn(method);",
        "line": 835,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "throwableProperlyPropagated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(methodInvocation.getArguments()).thenReturn(new Object[] { new GenericMessage<>(\"foo\") });",
        "line": 836,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "throwableProperlyPropagated",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.handler.advice",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\advice\\AdvisedMessageHandlerTests.java",
      "className": "AdvisedMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(advice, \"logger\", LogAccessor.class));",
        "line": 905,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInappropriateAdvice",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isWarnEnabled()).thenReturn(Boolean.TRUE);",
        "line": 906,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInappropriateAdvice",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.handler.advice",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\advice\\IdempotentReceiverTests.java",
      "className": "IdempotentReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = Mockito.mock(BeanFactory.class);",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdempotentReceiverInterceptor",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "log",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Before\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\AsyncHandlerTests.java",
      "className": "AsyncHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log log = spy(logAccessor.getLog());",
        "line": 106,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler2",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Before\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\MessageHandlerChainTests.java",
      "className": "MessageHandlerChainTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler2 = mock(MessageHandler.class);",
        "line": 63,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler1",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Before\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\MessageHandlerChainTests.java",
      "className": "MessageHandlerChainTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler1 = mock(MessageHandler.class);",
        "line": 62,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      }
    ]
  },
  {
    "variableName": "outputChannel",
    "variableType": "MessageChannel",
    "mockedClass": "MessageChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\MessageHandlerChainTests.java",
      "className": "MessageHandlerChainTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private MessageChannel outputChannel;",
        "line": 49,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "outputChannel = mock(MessageChannel.class);",
        "line": 61,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(outputChannel.send(Mockito.any(Message.class), eq(30000L))).thenReturn(true);",
        "line": 65,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(outputChannel).send(Mockito.eq(message), eq(30000L));",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "chainWithOutputChannel",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(outputChannel).send(Mockito.any(Message.class), eq(30000L));",
        "line": 125,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "chainForwardsToReplyChannel",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(outputChannel).send(Mockito.eq(message), eq(30000L));",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "chainResolvesReplyChannelName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler3",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\MessageHandlerChainTests.java",
      "className": "MessageHandlerChainTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private MessageHandler handler3;",
        "line": 51,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "handler3 = mock(MessageHandler.class);",
        "line": 64,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      }
    ]
  },
  {
    "variableName": "outputChannel",
    "variableType": "MessageChannel",
    "mockedClass": "MessageChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\MessageHandlerChainTests.java",
      "className": "MessageHandlerChainTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private MessageChannel outputChannel;",
        "line": 49,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "outputChannel = mock(MessageChannel.class);",
        "line": 61,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(outputChannel.send(Mockito.any(Message.class), eq(30000L))).thenReturn(true);",
        "line": 65,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(outputChannel).send(Mockito.eq(message), eq(30000L));",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "chainWithOutputChannel",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(outputChannel).send(Mockito.any(Message.class), eq(30000L));",
        "line": 125,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "chainForwardsToReplyChannel",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(outputChannel).send(Mockito.eq(message), eq(30000L));",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "chainResolvesReplyChannelName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler3",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\MessageHandlerChainTests.java",
      "className": "MessageHandlerChainTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private MessageHandler handler3;",
        "line": 51,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "handler3 = mock(MessageHandler.class);",
        "line": 64,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      }
    ]
  },
  {
    "variableName": "bf",
    "variableType": "ConfigurableListableBeanFactory",
    "mockedClass": "ConfigurableListableBeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\handler\\MethodInvokingMessageProcessorTests.java",
      "className": "MethodInvokingMessageProcessorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConfigurableListableBeanFactory bf = mock(ConfigurableListableBeanFactory.class);",
        "line": 1029,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testUseSpelInvoker",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "listener",
    "variableType": "ApplicationListener<ApplicationEvent>",
    "mockedClass": "ApplicationListener<ApplicationEvent>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.history",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\history\\AnnotatedTests.java",
      "className": "AnnotatedTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ApplicationListener<ApplicationEvent> listener = new ApplicationListener<ApplicationEvent>() {\r\n\r\n    @Override\r\n    public void onApplicationEvent(ApplicationEvent event) {\r\n        MessageHistory history = MessageHistory.read((Message<?>) event.getSource());\r\n        Properties adapterHistory = history.get(1);\r\n        assertThat(adapterHistory.get(\"name\")).isEqualTo(\"myAdapter\");\r\n        assertThat(adapterHistory.get(\"type\")).isEqualTo(\"outbound-channel-adapter\");\r\n    }\r\n};",
        "line": 51,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHistoryWithAnnotatedComponents",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "listener = spy(listener);",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHistoryWithAnnotatedComponents",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(listener, times(1)).onApplicationEvent((ApplicationEvent) Mockito.any());",
        "line": 71,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHistoryWithAnnotatedComponents",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.history",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\history\\MessageHistoryIntegrationTests.java",
      "className": "MessageHistoryIntegrationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = Mockito.spy(new // Not a lambda: Mockito can't mock final classes\r\nMessageHandler() {\r\n\r\n    @Override\r\n    public void handleMessage(Message<?> message) {\r\n        Iterator<Properties> historyIterator = message.getHeaders().get(MessageHistory.HEADER_NAME, MessageHistory.class).iterator();\r\n        Properties event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"sampleGateway#echo(String)\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"gateway\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"bridgeInChannel\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"channel\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"testBridge\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"bridge\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"headerEnricherChannel\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"channel\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"testHeaderEnricher\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"header-enricher\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"chainChannel\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"channel\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"sampleChain\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"chain\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"sampleChain$child.service-activator-within-chain\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"service-activator\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"filterChannel\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"channel\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"testFilter\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"filter\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"splitterChannel\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"channel\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"testSplitter\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"splitter\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"aggregatorChannel\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"channel\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"testAggregator\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"aggregator\");\r\n        event = historyIterator.next();\r\n        assertThat(event.getProperty(MessageHistory.NAME_PROPERTY)).isEqualTo(\"endOfThePipeChannel\");\r\n        assertThat(event.getProperty(MessageHistory.TYPE_PROPERTY)).isEqualTo(\"channel\");\r\n        MessageChannel replyChannel = (MessageChannel) message.getHeaders().getReplyChannel();\r\n        replyChannel.send(message);\r\n    }\r\n});",
        "line": 72,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistoryWithHistoryWriter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(handler, Mockito.times(1)).handleMessage(Mockito.any(Message.class));",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistoryWithHistoryWriter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.history",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\history\\MessageHistoryIntegrationTests.java",
      "className": "MessageHistoryIntegrationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = Mockito.spy(new // Not a lambda: Mockito can't mock final classes\r\nMessageHandler() {\r\n\r\n    @Override\r\n    public void handleMessage(Message<?> message) {\r\n        assertThat(message.getHeaders().get(MessageHistory.HEADER_NAME, MessageHistory.class)).isNull();\r\n        MessageChannel replyChannel = (MessageChannel) message.getHeaders().getReplyChannel();\r\n        replyChannel.send(message);\r\n    }\r\n});",
        "line": 159,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistoryWithoutHistoryWriter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(handler, Mockito.times(1)).handleMessage(Mockito.any(Message.class));",
        "line": 170,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistoryWithoutHistoryWriter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.history",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\history\\MessageHistoryIntegrationTests.java",
      "className": "MessageHistoryIntegrationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = Mockito.spy(new // Not a lambda: Mockito can't mock final classes\r\nMessageHandler() {\r\n\r\n    @Override\r\n    public void handleMessage(Message<?> message) {\r\n        Iterator<Properties> historyIterator = message.getHeaders().get(MessageHistory.HEADER_NAME, MessageHistory.class).iterator();\r\n        assertThat(historyIterator.hasNext()).isTrue();\r\n        MessageChannel replyChannel = (MessageChannel) message.getHeaders().getReplyChannel();\r\n        replyChannel.send(message);\r\n    }\r\n});",
        "line": 180,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistoryParser",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(handler, Mockito.times(1)).handleMessage(Mockito.any(Message.class));",
        "line": 193,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistoryParser",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.history",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\history\\MessageHistoryIntegrationTests.java",
      "className": "MessageHistoryIntegrationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = Mockito.spy(new // Not a lambda: Mockito can't mock final classes\r\nMessageHandler() {\r\n\r\n    @Override\r\n    public void handleMessage(Message<?> message) {\r\n        Iterator<Properties> historyIterator = message.getHeaders().get(MessageHistory.HEADER_NAME, MessageHistory.class).iterator();\r\n        assertThat(historyIterator.hasNext()).isTrue();\r\n        Properties gatewayHistory = historyIterator.next();\r\n        assertThat(gatewayHistory.get(\"name\")).isEqualTo(\"sampleGateway#echo(String)\");\r\n        assertThat(historyIterator.hasNext()).isTrue();\r\n        Properties chainHistory = historyIterator.next();\r\n        assertThat(chainHistory.get(\"name\")).isEqualTo(\"sampleChain\");\r\n        assertThat(historyIterator.hasNext()).isFalse();\r\n        MessageChannel replyChannel = (MessageChannel) message.getHeaders().getReplyChannel();\r\n        replyChannel.send(message);\r\n    }\r\n});",
        "line": 203,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistoryParserWithNamePatterns",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(handler, Mockito.times(1)).handleMessage(Mockito.any(Message.class));",
        "line": 222,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistoryParserWithNamePatterns",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.json",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\json\\JsonToObjectTransformerParserTests.java",
      "className": "JsonToObjectTransformerParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = (LogAccessor) spy(dfa.getPropertyValue(\"logger\"));",
        "line": 81,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDefaultObjectMapper",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).debug(any(Exception.class), argumentCaptor.capture());",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDefaultObjectMapper",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.router.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\router\\config\\RouterParserTests.java",
      "className": "RouterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 230,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testErrorChannel",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(1)).handleMessage(Mockito.any(Message.class));",
        "line": 233,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testErrorChannel",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.router",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\router\\RecipientListRouterTests.java",
      "className": "RecipientListRouterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = Mockito.mock(BeanFactory.class);",
        "line": 432,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDefaultChannelResolutionFromName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getBean(Mockito.eq(\"defaultChannel\"), Mockito.eq(MessageChannel.class))).thenReturn(defaultChannel);",
        "line": 433,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDefaultChannelResolutionFromName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(beanFactory).getBean(Mockito.eq(\"defaultChannel\"), Mockito.eq(MessageChannel.class));",
        "line": 441,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDefaultChannelResolutionFromName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.router",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\router\\RouterConcurrencyTests.java",
      "className": "RouterConcurrencyTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 78,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "test",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "queue",
    "variableType": "MessageGroupQueue",
    "mockedClass": "MessageGroupQueue",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.store",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\store\\MessageGroupQueueTests.java",
      "className": "MessageGroupQueueTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageGroupQueue queue = spy(new MessageGroupQueue(new SimpleMessageStore(), \"FOO\"));",
        "line": 68,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollEmpty",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "m1",
    "variableType": "Message<?>",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.store",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\store\\SimpleMessageGroupTests.java",
      "className": "SimpleMessageGroupTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Message<?> m1 = mock(Message.class);",
        "line": 87,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldIgnoreNullValuesWhenInitializedWithCollectionContainingNulls",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "m2",
    "variableType": "Message<?>",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.store",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\store\\SimpleMessageGroupTests.java",
      "className": "SimpleMessageGroupTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Message<?> m2 = mock(Message.class);",
        "line": 89,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "shouldIgnoreNullValuesWhenInitializedWithCollectionContainingNulls",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "secondRegistry",
    "variableType": "LockRegistry",
    "mockedClass": "LockRegistry",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.support.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\support\\leader\\LockRegistryLeaderInitiatorTests.java",
      "className": "LockRegistryLeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "// set up second registry instance - this one will NOT be able to obtain lock initially\r\nLockRegistry secondRegistry = mock(LockRegistry.class);",
        "line": 184,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "competingWithLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(secondRegistry.obtain(anyString())).willReturn(secondLock);",
        "line": 186,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "competingWithLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "firstLock",
    "variableType": "Lock",
    "mockedClass": "Lock",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.support.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\support\\leader\\LockRegistryLeaderInitiatorTests.java",
      "className": "LockRegistryLeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Lock firstLock = mock(Lock.class);",
        "line": 168,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "competingWithLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(firstLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> firstLocked.get());",
        "line": 170,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "competingWithLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "firstRegistry",
    "variableType": "LockRegistry",
    "mockedClass": "LockRegistry",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.support.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\support\\leader\\LockRegistryLeaderInitiatorTests.java",
      "className": "LockRegistryLeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "// set up first registry instance - this one will be able to obtain lock initially\r\nLockRegistry firstRegistry = mock(LockRegistry.class);",
        "line": 167,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "competingWithLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(firstRegistry.obtain(anyString())).willReturn(firstLock);",
        "line": 169,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "competingWithLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "secondLock",
    "variableType": "Lock",
    "mockedClass": "Lock",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.support.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\support\\leader\\LockRegistryLeaderInitiatorTests.java",
      "className": "LockRegistryLeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Lock secondLock = mock(Lock.class);",
        "line": 185,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "competingWithLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(secondLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> !firstLocked.get());",
        "line": 187,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "competingWithLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "registry",
    "variableType": "LockRegistry",
    "mockedClass": "LockRegistry",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.support.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\support\\leader\\LockRegistryLeaderInitiatorTests.java",
      "className": "LockRegistryLeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LockRegistry registry = mock(LockRegistry.class);",
        "line": 226,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGracefulLeaderSelectorExit",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(registry.obtain(anyString())).willReturn(lock);",
        "line": 243,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGracefulLeaderSelectorExit",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "lock",
    "variableType": "Lock",
    "mockedClass": "Lock",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.support.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\support\\leader\\LockRegistryLeaderInitiatorTests.java",
      "className": "LockRegistryLeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Lock lock = spy(new ReentrantLock());",
        "line": 228,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGracefulLeaderSelectorExit",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockLock",
    "variableType": "Lock",
    "mockedClass": "Lock",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.support.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\support\\leader\\LockRegistryLeaderInitiatorTests.java",
      "className": "LockRegistryLeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Lock mockLock = mock(Lock.class);",
        "line": 266,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExceptionFromLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "ctx",
    "variableType": "ApplicationContext",
    "mockedClass": "ApplicationContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.support.management",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\support\\management\\IntegrationManagementConfigurerTests.java",
      "className": "IntegrationManagementConfigurerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ApplicationContext ctx = mock(ApplicationContext.class);",
        "line": 71,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDefaults",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ctx.getBeansOfType(IntegrationManagement.class)).thenReturn(beans);",
        "line": 76,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDefaults",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "lc2",
    "variableType": "SmartLifecycle",
    "mockedClass": "SmartLifecycle",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.support",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\support\\SmartLifecycleRoleControllerTests.java",
      "className": "SmartLifecycleRoleControllerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SmartLifecycle lc2 = mock(SmartLifecycle.class);",
        "line": 45,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOrder",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(lc2.getPhase()).thenReturn(1);",
        "line": 46,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOrder",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(lc2).start();",
        "line": 54,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOrder",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(lc2).stop();",
        "line": 57,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOrder",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "lc1",
    "variableType": "SmartLifecycle",
    "mockedClass": "SmartLifecycle",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.support",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\support\\SmartLifecycleRoleControllerTests.java",
      "className": "SmartLifecycleRoleControllerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SmartLifecycle lc1 = mock(SmartLifecycle.class);",
        "line": 43,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOrder",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(lc1.getPhase()).thenReturn(2);",
        "line": 44,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOrder",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(lc1).start();",
        "line": 55,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOrder",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(lc1).stop();",
        "line": 56,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOrder",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "spied",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.transformer",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\transformer\\AvroTests.java",
      "className": "AvroTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor spied = spy(TestUtils.getPropertyValue(config.in1(), \"logger\", LogAccessor.class));",
        "line": 59,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransformers",
          "methodAnnotations": [
            "@Test",
            "@LogLevels"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(spied, atLeastOnce()).debug(captor.capture());",
        "line": 74,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransformers",
          "methodAnnotations": [
            "@Test",
            "@LogLevels"
          ]
        }
      }
    ]
  },
  {
    "variableName": "conversionService",
    "variableType": "ConversionService",
    "mockedClass": "ConversionService",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.util",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\util\\BeanFactoryTypeConverterTests.java",
      "className": "BeanFactoryTypeConverterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConversionService conversionService = mock(ConversionService.class);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testObjectToStringIsConverted",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(conversionService.canConvert(any(TypeDescriptor.class), any(TypeDescriptor.class))).thenReturn(true);",
        "line": 154,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testObjectToStringIsConverted",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(conversionService.convert(any(), any(TypeDescriptor.class), any(TypeDescriptor.class))).thenReturn(\"foo\");",
        "line": 156,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testObjectToStringIsConverted",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "typeConverter",
    "variableType": "SimpleTypeConverter",
    "mockedClass": "SimpleTypeConverter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.util",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\util\\BeanFactoryTypeConverterTests.java",
      "className": "BeanFactoryTypeConverterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SimpleTypeConverter typeConverter = spy(new SimpleTypeConverter());",
        "line": 304,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "initialConcurrency",
          "methodAnnotations": [
            "@Test",
            "@Ignore"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "ConfigurableBeanFactory",
    "mockedClass": "ConfigurableBeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.util",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\util\\BeanFactoryTypeConverterTests.java",
      "className": "BeanFactoryTypeConverterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConfigurableBeanFactory beanFactory = mock(ConfigurableBeanFactory.class);",
        "line": 303,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "initialConcurrency",
          "methodAnnotations": [
            "@Test",
            "@Ignore"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getTypeConverter()).thenReturn(typeConverter);",
        "line": 305,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "initialConcurrency",
          "methodAnnotations": [
            "@Test",
            "@Ignore"
          ]
        }
      }
    ]
  },
  {
    "variableName": "conversionService",
    "variableType": "ConversionService",
    "mockedClass": "ConversionService",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.util",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-core\\src\\test\\java\\org\\springframework\\integration\\util\\BeanFactoryTypeConverterTests.java",
      "className": "BeanFactoryTypeConverterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "// can convert nothing so we drop down to\r\nConversionService conversionService = mock(ConversionService.class);",
        "line": 300,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "initialConcurrency",
          "methodAnnotations": [
            "@Test",
            "@Ignore"
          ]
        }
      }
    ]
  },
  {
    "variableName": "debeziumBuilderMock",
    "variableType": "DebeziumEngine.Builder<ChangeEvent<byte[],byte[]>>",
    "mockedClass": "DebeziumEngine.Builder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.debezium.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-debezium\\src\\test\\java\\org\\springframework\\integration\\debezium\\inbound\\DebeziumMessageProducerTests.java",
      "className": "DebeziumMessageProducerTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "DebeziumEngine.Builder<ChangeEvent<byte[], byte[]>> debeziumBuilderMock;",
        "line": 47,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "debeziumBuilderMock = mock(DebeziumEngine.Builder.class);",
        "line": 56,
        "locate": "@Before",
        "locationContext": {
          "methodName": "beforeEach",
          "methodAnnotations": [
            "@BeforeEach",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(debeziumBuilderMock.notifying(any(Consumer.class))).willReturn(debeziumBuilderMock);",
        "line": 58,
        "locate": "@Before",
        "locationContext": {
          "methodName": "beforeEach",
          "methodAnnotations": [
            "@BeforeEach",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(debeziumBuilderMock.build()).willReturn(debeziumEngineMock);",
        "line": 59,
        "locate": "@Before",
        "locationContext": {
          "methodName": "beforeEach",
          "methodAnnotations": [
            "@BeforeEach",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "debeziumEngineMock",
    "variableType": "DebeziumEngine<ChangeEvent<byte[],byte[]>>",
    "mockedClass": "DebeziumEngine",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.debezium.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-debezium\\src\\test\\java\\org\\springframework\\integration\\debezium\\inbound\\DebeziumMessageProducerTests.java",
      "className": "DebeziumMessageProducerTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "DebeziumEngine<ChangeEvent<byte[], byte[]>> debeziumEngineMock;",
        "line": 49,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "debeziumEngineMock = mock(DebeziumEngine.class);",
        "line": 57,
        "locate": "@Before",
        "locationContext": {
          "methodName": "beforeEach",
          "methodAnnotations": [
            "@BeforeEach",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.feed.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-feed\\src\\test\\java\\org\\springframework\\integration\\feed\\config\\FeedInboundChannelAdapterParserTests.java",
      "className": "FeedInboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = spy(message -> latch.countDown());",
        "line": 119,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulNewsRetrievalWithHttpUrl",
          "methodAnnotations": [
            "@Test",
            "@Disabled"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, atLeast(3)).handleMessage(Mockito.any(Message.class));",
        "line": 125,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulNewsRetrievalWithHttpUrl",
          "methodAnnotations": [
            "@Test",
            "@Disabled"
          ]
        }
      }
    ]
  },
  {
    "variableName": "fileListFilter",
    "variableType": "ResettableFileListFilter<File>",
    "mockedClass": "ResettableFileListFilter<File>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileInboundTransactionTests.java",
      "className": "FileInboundTransactionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nResettableFileListFilter<File> fileListFilter = spy(TestUtils.getPropertyValue(scanner, \"filter\", ResettableFileListFilter.class));",
        "line": 90,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoTx",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(fileListFilter).remove(new File(tmpDir.getRoot(), \"si-test1/foo\"));",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoTx",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "anotherFileMock",
    "variableType": "File",
    "mockedClass": "File",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileReadingMessageSourceTests.java",
      "className": "FileReadingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "File anotherFileMock = mock();",
        "line": 90,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "scanEachPoll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(anotherFileMock.toPath()).thenReturn(Path.of(\"[dir]/anotherFileMock\"));",
        "line": 91,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "scanEachPoll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "file2",
    "variableType": "File",
    "mockedClass": "File",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileReadingMessageSourceTests.java",
      "className": "FileReadingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "File file2 = mock();",
        "line": 138,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(file2.toPath()).thenReturn(Path.of(\"[dir]/file2\"));",
        "line": 139,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "file3",
    "variableType": "File",
    "mockedClass": "File",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileReadingMessageSourceTests.java",
      "className": "FileReadingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "File file3 = mock();",
        "line": 140,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(file3.toPath()).thenReturn(Path.of(\"[dir]/file3\"));",
        "line": 141,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "file1",
    "variableType": "File",
    "mockedClass": "File",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileReadingMessageSourceTests.java",
      "className": "FileReadingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "File file1 = mock();",
        "line": 136,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(file1.toPath()).thenReturn(Path.of(\"[dir]/file1\"));",
        "line": 137,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "comparator",
    "variableType": "Comparator<File>",
    "mockedClass": "Comparator<File>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileReadingMessageSourceTests.java",
      "className": "FileReadingMessageSourceTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final Comparator<File> comparator = mock();",
        "line": 52,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "// record the comparator to reverse order the files\r\nwhen(comparator.compare(file1, file2)).thenReturn(1);",
        "line": 144,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(comparator.compare(file1, file3)).thenReturn(1);",
        "line": 145,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(comparator.compare(file3, file2)).thenReturn(-1);",
        "line": 146,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "fileMock",
    "variableType": "File",
    "mockedClass": "File",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Other Methods\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileReadingMessageSourceTests.java",
      "className": "FileReadingMessageSourceTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final File fileMock = mock();",
        "line": 48,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(fileMock.toPath()).thenReturn(Path.of(\"[dir]/fileMock\"));",
        "line": 56,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "prepResource",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "inputDirectoryMock",
    "variableType": "File",
    "mockedClass": "File",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Other Methods\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileReadingMessageSourceTests.java",
      "className": "FileReadingMessageSourceTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final File inputDirectoryMock = mock();",
        "line": 46,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(inputDirectoryMock.toPath()).thenReturn(Path.of(\"[dir]\"));",
        "line": 55,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "prepResource",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(inputDirectoryMock.listFiles()).thenReturn(new File[] { fileMock });",
        "line": 72,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "straightProcess",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(inputDirectoryMock.listFiles()).thenReturn(new File[] { fileMock });",
        "line": 80,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "requeueOnFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(inputDirectoryMock).listFiles();",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "requeueOnFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(inputDirectoryMock.listFiles()).thenReturn(new File[] { fileMock, anotherFileMock });",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "scanEachPoll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(inputDirectoryMock, times(3)).listFiles();",
        "line": 97,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "scanEachPoll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(inputDirectoryMock.listFiles()).thenReturn(new File[] { fileMock });",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noDuplication",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(inputDirectoryMock, times(2)).listFiles();",
        "line": 107,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noDuplication",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(inputDirectoryMock.listFiles()).thenReturn(new File[] { fileMock });",
        "line": 118,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "lockIsAcquired",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(inputDirectoryMock.listFiles()).thenReturn(new File[] { fileMock });",
        "line": 127,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "lockedFilesAreIgnored",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(inputDirectoryMock.listFiles()).thenReturn(new File[] { file2, file3, file1 });",
        "line": 148,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(inputDirectoryMock, times(2)).listFiles();",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "orderedReception",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "locker",
    "variableType": "FileLocker",
    "mockedClass": "FileLocker",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Other Methods\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileReadingMessageSourceTests.java",
      "className": "FileReadingMessageSourceTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final FileLocker locker = mock();",
        "line": 50,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(locker.lock(isA(File.class))).thenReturn(true);",
        "line": 57,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "prepResource",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(locker).lock(fileMock);",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "lockIsAcquired",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(locker.lock(fileMock)).thenReturn(false);",
        "line": 128,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "lockedFilesAreIgnored",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(locker).lock(fileMock);",
        "line": 131,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "lockedFilesAreIgnored",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "FileWritingMessageHandler",
    "mockedClass": "FileWritingMessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileWritingMessageHandlerTests.java",
      "className": "FileWritingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FileWritingMessageHandler handler = new FileWritingMessageHandler(mock(Expression.class));",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "permissions",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileWritingMessageHandlerTests.java",
      "className": "FileWritingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(handler, \"logger\", LogAccessor.class));",
        "line": 548,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFlushAppend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isDebugEnabled()).thenReturn(true);",
        "line": 550,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "noFlushAppend",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "out",
    "variableType": "BufferedOutputStream",
    "mockedClass": "BufferedOutputStream",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\FileWritingMessageHandlerTests.java",
      "className": "FileWritingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final BufferedOutputStream out = spy(new BufferedOutputStream(baos));",
        "line": 572,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "lockForFlush",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(out).write(any(byte[].class), anyInt(), anyInt());",
        "line": 606,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "lockForFlush",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "fileMock",
    "variableType": "File",
    "mockedClass": "File",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.filters",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\filters\\CompositeFileListFilterTests.java",
      "className": "CompositeFileListFilterTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final File fileMock = mock(File.class);",
        "line": 49,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "fileFilterMock2",
    "variableType": "FileListFilter<File>",
    "mockedClass": "FileListFilter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.filters",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\filters\\CompositeFileListFilterTests.java",
      "className": "CompositeFileListFilterTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nprivate final FileListFilter<File> fileFilterMock2 = mock(FileListFilter.class);",
        "line": 46,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(fileFilterMock2.filterFiles(isA(File[].class))).thenReturn(returnedFiles);",
        "line": 58,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "forwardedToFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(fileFilterMock2).filterFiles(isA(File[].class));",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "forwardedToFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(fileFilterMock2.filterFiles(isA(File[].class))).thenReturn(returnedFiles);",
        "line": 72,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "forwardedToAddedFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(fileFilterMock2).filterFiles(isA(File[].class));",
        "line": 75,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "forwardedToAddedFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(fileFilterMock2.filterFiles(isA(File[].class))).thenReturn(new ArrayList<>());",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "negative",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(fileFilterMock2, never()).filterFiles(isA(File[].class));",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "excludeFromLaterFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "fileFilterMock1",
    "variableType": "FileListFilter<File>",
    "mockedClass": "FileListFilter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.filters",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\filters\\CompositeFileListFilterTests.java",
      "className": "CompositeFileListFilterTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nprivate final FileListFilter<File> fileFilterMock1 = mock(FileListFilter.class);",
        "line": 43,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(fileFilterMock1.filterFiles(isA(File[].class))).thenReturn(returnedFiles);",
        "line": 57,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "forwardedToFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(fileFilterMock1).filterFiles(isA(File[].class));",
        "line": 60,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "forwardedToFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(fileFilterMock1.filterFiles(isA(File[].class))).thenReturn(returnedFiles);",
        "line": 71,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "forwardedToAddedFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(fileFilterMock1).filterFiles(isA(File[].class));",
        "line": 74,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "forwardedToAddedFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(fileFilterMock1.filterFiles(isA(File[].class))).thenReturn(new ArrayList<>());",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "negative",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.fileFilterMock1.filterFiles(isA(File[].class))).thenReturn(noFiles);",
        "line": 97,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "excludeFromLaterFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(fileFilterMock1).filterFiles(isA(File[].class));",
        "line": 100,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "excludeFromLaterFilters",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 89,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBad",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBadFilterGet",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 107,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBadFilterRm",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 119,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/x/\")).thenReturn(files);",
        "line": 124,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 118,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 146,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMGetWildGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(new TestSession() {\r\n\r\n    int n;\r\n\r\n    @Override\r\n    public void read(String source, OutputStream outputStream) throws IOException {\r\n        if (n++ == 0) {\r\n            assertThat(source).isEqualTo(\"testremote/f1\");\r\n        } else {\r\n            assertThat(source).isEqualTo(\"testremote/f2\");\r\n        }\r\n        outputStream.write(\"testData\".getBytes());\r\n    }\r\n\r\n    @Override\r\n    public TestLsEntry[] list(String path) {\r\n        return new TestLsEntry[] { new TestLsEntry(path1.replaceFirst(\"testremote/\", \"\"), 123, false, false, 1234, \"-r--r--r--\"), new TestLsEntry(path2.replaceFirst(\"testremote/\", \"\"), 123, false, false, 1234, \"-r--r--r--\") };\r\n    }\r\n});",
        "line": 152,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMGetWildGuts",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 189,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMGetSingle",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(new TestSession() {\r\n\r\n    @Override\r\n    public void read(String source, OutputStream outputStream) throws IOException {\r\n        outputStream.write(\"testData\".getBytes());\r\n    }\r\n\r\n    @Override\r\n    public TestLsEntry[] list(String path) {\r\n        return new TestLsEntry[] { new TestLsEntry(\"f1\", 123, false, false, 1234, \"-r--r--r--\") };\r\n    }\r\n});",
        "line": 194,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMGetSingle",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 219,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMGetEmpty",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(new TestSession() {\r\n\r\n    @Override\r\n    public void read(String source, OutputStream outputStream) throws IOException {\r\n        outputStream.write(\"testData\".getBytes());\r\n    }\r\n});",
        "line": 226,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMGetEmpty",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<?>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<?> session = mock(Session.class);",
        "line": 245,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMove",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 242,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMove",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 252,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMove",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<?>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<?> session = mock(Session.class);",
        "line": 268,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMoveWithExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 264,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMoveWithExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 275,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMoveWithExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<?>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<?> session = mock(Session.class);",
        "line": 289,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMoveWithMkDirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 285,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMoveWithMkDirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 301,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMoveWithMkDirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 328,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/x/\")).thenReturn(files);",
        "line": 334,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 327,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 332,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 369,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/x/\")).thenReturn(level1);",
        "line": 377,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/x/d1/\")).thenReturn(level2);",
        "line": 378,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/x/d1/d2/\")).thenReturn(level3);",
        "line": 379,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 368,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 373,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 395,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R_dirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/x/\")).thenReturn(level1);",
        "line": 403,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R_dirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/x/d1/\")).thenReturn(level2);",
        "line": 404,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R_dirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/x/d1/d2/\")).thenReturn(level3);",
        "line": 405,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R_dirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 394,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R_dirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 399,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_f_R_dirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 423,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_None",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/\")).thenReturn(files);",
        "line": 428,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_None",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 422,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_None",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 426,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_None",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 439,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/\")).thenReturn(files);",
        "line": 445,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 438,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 443,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 458,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_f",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/\")).thenReturn(files);",
        "line": 464,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_f",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "//no sort\r\nSessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 457,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_f",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 462,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_f",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 476,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_dirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/\")).thenReturn(files);",
        "line": 482,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_dirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 475,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_dirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 480,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_dirs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 495,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_dirs_links",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/\")).thenReturn(files);",
        "line": 501,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_dirs_links",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 494,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_dirs_links",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 499,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_dirs_links",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 515,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_a_f_dirs_links",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/\")).thenReturn(files);",
        "line": 521,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_a_f_dirs_links",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 514,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_a_f_dirs_links",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 519,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_a_f_dirs_links",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 537,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_a_f_dirs_links_filtered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"testremote/\")).thenReturn(files);",
        "line": 544,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_a_f_dirs_links_filtered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 536,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_a_f_dirs_links_filtered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 542,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLs_1_a_f_dirs_links_filtered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 554,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGet",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(new TestSession() {\r\n\r\n    @Override\r\n    public TestLsEntry[] list(String path) {\r\n        return new TestLsEntry[] { new TestLsEntry(\"f1\", 1234, false, false, 12345, \"-rw-r--r--\") };\r\n    }\r\n\r\n    @Override\r\n    public void read(String source, OutputStream outputStream) throws IOException {\r\n        outputStream.write(\"testfile\".getBytes());\r\n    }\r\n});",
        "line": 559,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGet",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 588,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGetExists",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(new TestSession() {\r\n\r\n    @Override\r\n    public TestLsEntry[] list(String path) {\r\n        return new TestLsEntry[] { new TestLsEntry(\"f1\", 1234, false, false, 12345, \"-rw-r--r--\") };\r\n    }\r\n\r\n    @Override\r\n    public void read(String source, OutputStream outputStream) throws IOException {\r\n        outputStream.write(\"testfile\".getBytes());\r\n    }\r\n});",
        "line": 596,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGetExists",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<TestLsEntry>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nSessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);",
        "line": 652,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGetTempFileDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(new TestSession() {\r\n\r\n    @Override\r\n    public TestLsEntry[] list(String path) {\r\n        return new TestLsEntry[] { new TestLsEntry(\"f1\", 1234, false, false, 12345, \"-rw-r--r--\") };\r\n    }\r\n\r\n    @Override\r\n    public void read(String source, OutputStream outputStream) {\r\n        throw new RuntimeException(\"test remove .writing\");\r\n    }\r\n});",
        "line": 658,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGetTempFileDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 687,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGet_P",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(new TestSession() {\r\n\r\n    @Override\r\n    public TestLsEntry[] list(String path) {\r\n        return new TestLsEntry[] { new TestLsEntry(\"f1\", 1234, false, false, modified.getTime(), \"-rw-r--r--\") };\r\n    }\r\n\r\n    @Override\r\n    public void read(String source, OutputStream outputStream) throws IOException {\r\n        outputStream.write(\"testfile\".getBytes());\r\n    }\r\n});",
        "line": 696,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGet_P",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 727,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGet_create_dir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(new TestSession() {\r\n\r\n    @Override\r\n    public TestLsEntry[] list(String path) {\r\n        return new TestLsEntry[] { new TestLsEntry(\"f1\", 1234, false, false, 12345, \"-rw-r--r--\") };\r\n    }\r\n\r\n    @Override\r\n    public void read(String source, OutputStream outputStream) throws IOException {\r\n        outputStream.write(\"testfile\".getBytes());\r\n    }\r\n});",
        "line": 731,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGet_create_dir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 755,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRm",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.remove(\"testremote/x/f1\")).thenReturn(Boolean.TRUE);",
        "line": 759,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRm",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session).remove(\"testremote/x/f1\");",
        "line": 764,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRm",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory sessionFactory = mock(SessionFactory.class);",
        "line": 754,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRm",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 758,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRm",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<TestLsEntry>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nSession<TestLsEntry> session = mock(Session.class);",
        "line": 773,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPut",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session).write(any(InputStream.class), captor.capture());",
        "line": 799,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPut",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session).rename(\"foo/bar.txt.writing\", \"foo/bar.txt\");",
        "line": 801,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPut",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<TestLsEntry>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nSessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);",
        "line": 771,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPut",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 792,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPut",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<TestLsEntry>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nSession<TestLsEntry> session = mock(Session.class);",
        "line": 808,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPutExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session).write(any(InputStream.class), captor.capture());",
        "line": 832,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPutExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session).rename(\"foo/bar.txt.writing\", \"foo/bar.txt\");",
        "line": 834,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPutExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session, times(2)).write(any(InputStream.class), captor.capture());",
        "line": 846,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPutExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session, times(2)).rename(\"foo/bar.txt.writing\", \"foo/bar.txt\");",
        "line": 848,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPutExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session).append(any(InputStream.class), captor.capture());",
        "line": 854,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPutExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// no more writes/appends\r\nverify(session, times(2)).write(any(InputStream.class), anyString());",
        "line": 861,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPutExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session, times(1)).append(any(InputStream.class), anyString());",
        "line": 862,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPutExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<TestLsEntry>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nSessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);",
        "line": 806,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPutExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 823,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPutExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<TestLsEntry>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<TestLsEntry> session = mock(Session.class);",
        "line": 869,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMput",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<TestLsEntry>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);",
        "line": 868,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMput",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 876,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMput",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<TestLsEntry>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<TestLsEntry> session = mock(Session.class);",
        "line": 896,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMputRecursive",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<TestLsEntry>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);",
        "line": 895,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMputRecursive",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 904,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMputRecursive",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<TestLsEntry>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);",
        "line": 928,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRemoteFileTemplateImmutability",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<TestLsEntry>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<TestLsEntry> session = mock(Session.class);",
        "line": 940,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMputCollection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session).rename(\"foo/buz.txt.writing\", \"foo/buz.txt\");",
        "line": 965,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMputCollection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<TestLsEntry>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.gateway",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\gateway\\RemoteFileOutboundGatewayTests.java",
      "className": "RemoteFileOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);",
        "line": 939,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMputCollection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 944,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMputCollection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sf",
    "variableType": "SessionFactory<F>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<F> sf = mock(SessionFactory.class);",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRemoteDirWithEmptyString",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sf.getSession()).thenReturn(session);",
        "line": 64,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRemoteDirWithEmptyString",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<F>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<F> session = mock(Session.class);",
        "line": 62,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRemoteDirWithEmptyString",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());",
        "line": 76,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRemoteDirWithEmptyString",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sf",
    "variableType": "SessionFactory<F>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<F> sf = mock(SessionFactory.class);",
        "line": 82,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTemporaryRemoteDir",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sf.getSession()).thenReturn(session);",
        "line": 87,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTemporaryRemoteDir",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<F>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<F> session = mock(Session.class);",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTemporaryRemoteDir",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());",
        "line": 99,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTemporaryRemoteDir",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sf",
    "variableType": "SessionFactory<F>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<F> sf = mock(SessionFactory.class);",
        "line": 107,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRemoteDirWithNull",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sf.getSession()).thenReturn(session);",
        "line": 110,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRemoteDirWithNull",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<F>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<F> session = mock(Session.class);",
        "line": 108,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRemoteDirWithNull",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRemoteDirWithNull",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sf",
    "variableType": "SessionFactory<F>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<F> sf = mock(SessionFactory.class);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEmptyTemporaryFileSuffixCannotBeNull",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sf.getSession()).thenReturn(session);",
        "line": 131,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEmptyTemporaryFileSuffixCannotBeNull",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<F>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<F> session = mock(Session.class);",
        "line": 130,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEmptyTemporaryFileSuffixCannotBeNull",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sf",
    "variableType": "SessionFactory<F>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<F> sf = mock(SessionFactory.class);",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testUseTemporaryFileNameFalse",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sf.getSession()).thenReturn(session);",
        "line": 145,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testUseTemporaryFileNameFalse",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<F>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<F> session = mock(Session.class);",
        "line": 143,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testUseTemporaryFileNameFalse",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());",
        "line": 155,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testUseTemporaryFileNameFalse",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session, times(0)).rename(Mockito.anyString(), Mockito.anyString());",
        "line": 156,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testUseTemporaryFileNameFalse",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sf",
    "variableType": "SessionFactory<F>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<F> sf = mock(SessionFactory.class);",
        "line": 162,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testServerException",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sf.getSession()).thenReturn(session1, session2, session3);",
        "line": 169,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testServerException",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<F>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— Other Methods\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.handler",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\handler\\FileTransferringMessageHandlerTests.java",
      "className": "FileTransferringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nSession<F> session = mock(Session.class);",
        "line": 190,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "newSession",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.isOpen()).thenReturn(false);",
        "line": 193,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "newSession",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "comparator",
    "variableType": "Comparator<String>",
    "mockedClass": "Comparator",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\RemoteFileStreamingMessageSourceTests.java",
      "className": "RemoteFileStreamingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Comparator<String> comparator = mock(Comparator.class);",
        "line": 65,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "filterOutFilesNotAcceptedByFilter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<String>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\RemoteFileStreamingMessageSourceTests.java",
      "className": "RemoteFileStreamingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<String> session = mock(Session.class);",
        "line": 56,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "filterOutFilesNotAcceptedByFilter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.readRaw(anyString())).thenReturn(mock(InputStream.class));",
        "line": 57,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "filterOutFilesNotAcceptedByFilter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "remoteFileTemplate",
    "variableType": "RemoteFileTemplate<String>",
    "mockedClass": "RemoteFileTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\RemoteFileStreamingMessageSourceTests.java",
      "className": "RemoteFileStreamingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RemoteFileTemplate<String> remoteFileTemplate = mock(RemoteFileTemplate.class);",
        "line": 54,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "filterOutFilesNotAcceptedByFilter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(remoteFileTemplate.list(\"remoteDirectory\")).thenReturn(new String[] { \"file1\", \"file2\" });",
        "line": 55,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "filterOutFilesNotAcceptedByFilter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(remoteFileTemplate.getSession()).thenReturn(session);",
        "line": 58,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "filterOutFilesNotAcceptedByFilter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "fileListFilter",
    "variableType": "FileListFilter<String>",
    "mockedClass": "FileListFilter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\RemoteFileStreamingMessageSourceTests.java",
      "className": "RemoteFileStreamingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FileListFilter<String> fileListFilter = mock(FileListFilter.class);",
        "line": 60,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "filterOutFilesNotAcceptedByFilter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(fileListFilter.supportsSingleFileFiltering()).thenReturn(true);",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "filterOutFilesNotAcceptedByFilter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(fileListFilter.accept(\"file1\")).thenReturn(false);",
        "line": 62,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "filterOutFilesNotAcceptedByFilter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(fileListFilter.accept(\"file2\")).thenReturn(false);",
        "line": 63,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "filterOutFilesNotAcceptedByFilter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<String>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\RemoteFileStreamingMessageSourceTests.java",
      "className": "RemoteFileStreamingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<String> session = mock(Session.class);",
        "line": 80,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sessionReturnedToCacheProperlyOnDoReceive",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.readRaw(anyString())).thenThrow(IOException.class);",
        "line": 81,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sessionReturnedToCacheProperlyOnDoReceive",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.list(\"remoteDirectory\")).thenReturn(new String[] { \"file1\" });",
        "line": 82,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sessionReturnedToCacheProperlyOnDoReceive",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<String>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\RemoteFileStreamingMessageSourceTests.java",
      "className": "RemoteFileStreamingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<String> sessionFactory = mock(SessionFactory.class);",
        "line": 84,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sessionReturnedToCacheProperlyOnDoReceive",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sessionReturnedToCacheProperlyOnDoReceive",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<Object>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Before\n\nStubbing:\n— @Before\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\RemoteFileTemplateTests.java",
      "className": "RemoteFileTemplateTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<Object> sessionFactory = mock(SessionFactory.class);",
        "line": 73,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setUp",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(this.session);",
        "line": 79,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setUp",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@BeforeEach"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "SessionFactory<Object>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\session\\CachingSessionFactoryTests.java",
      "className": "CachingSessionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nSessionFactory<Object> factory = mock(SessionFactory.class);",
        "line": 80,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDirtySession",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getSession()).thenReturn(session);",
        "line": 84,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDirtySession",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<Object>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\session\\CachingSessionFactoryTests.java",
      "className": "CachingSessionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nSession<Object> session = mock(Session.class);",
        "line": 82,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDirtySession",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.readRaw(\"foo\")).thenReturn(new ByteArrayInputStream(\"\".getBytes()));",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDirtySession",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.finalizeRaw()).thenReturn(true);",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDirtySession",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session).close();",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDirtySession",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockSession",
    "variableType": "Session<String>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\session\\DelegatingSessionFactoryTests.java",
      "className": "TestSessionFactory"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nprivate final Session<String> mockSession = mock(Session.class);",
        "line": 195,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<String>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— @Override\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.file.remote",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-file\\src\\test\\java\\org\\springframework\\integration\\file\\remote\\StreamingInboundTests.java",
      "className": "StringSessionFactory"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<String> session = mock(Session.class);",
        "line": 351,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getSession",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(session.finalizeRaw()).willReturn(true);",
        "line": 368,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getSession",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "DefaultFtpSessionFactory",
    "mockedClass": "DefaultFtpSessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— @Override\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\config\\FtpInboundChannelAdapterParserTests.java",
      "className": "TestSessionFactoryBean"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DefaultFtpSessionFactory factory = mock(DefaultFtpSessionFactory.class);",
        "line": 171,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getSession()).thenReturn(session);",
        "line": 173,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "FtpSession",
    "mockedClass": "FtpSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\config\\FtpInboundChannelAdapterParserTests.java",
      "className": "TestSessionFactoryBean"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FtpSession session = mock(FtpSession.class);",
        "line": 172,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "DefaultFtpSessionFactory",
    "mockedClass": "DefaultFtpSessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— @Override\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\config\\FtpStreamingInboundChannelAdapterParserTests.java",
      "className": "TestSessionFactoryBean"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DefaultFtpSessionFactory factory = mock(DefaultFtpSessionFactory.class);",
        "line": 90,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getSession()).thenReturn(session);",
        "line": 92,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "FtpSession",
    "mockedClass": "FtpSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\config\\FtpStreamingInboundChannelAdapterParserTests.java",
      "className": "TestSessionFactoryBean"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FtpSession session = mock(FtpSession.class);",
        "line": 91,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "store",
    "variableType": "PropertiesPersistingMetadataStore",
    "mockedClass": "PropertiesPersistingMetadataStore",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\inbound\\FtpInboundRemoteFileSystemSynchronizerTests.java",
      "className": "FtpInboundRemoteFileSystemSynchronizerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "PropertiesPersistingMetadataStore store = spy(new PropertiesPersistingMetadataStore());",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCopyFileToLocalDir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(store).close();",
        "line": 165,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCopyFileToLocalDir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "synchronizer",
    "variableType": "FtpInboundFileSynchronizer",
    "mockedClass": "FtpInboundFileSynchronizer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\inbound\\FtpInboundRemoteFileSystemSynchronizerTests.java",
      "className": "FtpInboundRemoteFileSystemSynchronizerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FtpInboundFileSynchronizer synchronizer = spy(new FtpInboundFileSynchronizer(ftpSessionFactory));",
        "line": 89,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCopyFileToLocalDir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// two times because on the third receive (above) the internal queue will be empty, so it will attempt\r\nverify(synchronizer, times(2)).synchronizeToLocalDirectory(localDirectory, Integer.MIN_VALUE);",
        "line": 146,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCopyFileToLocalDir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(synchronizer).close();",
        "line": 164,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCopyFileToLocalDir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "synchronizer",
    "variableType": "FtpInboundFileSynchronizer",
    "mockedClass": "FtpInboundFileSynchronizer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\inbound\\FtpInboundRemoteFileSystemSynchronizerTests.java",
      "className": "FtpInboundRemoteFileSystemSynchronizerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FtpInboundFileSynchronizer synchronizer = spy(new FtpInboundFileSynchronizer(ftpSessionFactory));",
        "line": 180,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSyncRemoteFileOnlyOnceByDefault",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "ftpClient",
    "variableType": "FTPClient",
    "mockedClass": "FTPClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\inbound\\FtpInboundRemoteFileSystemSynchronizerTests.java",
      "className": "FtpInboundRemoteFileSystemSynchronizerTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private static FTPClient ftpClient = mock(FTPClient.class);",
        "line": 72,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.getReplyCode()).thenReturn(250);",
        "line": 244,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.login(\"kermit\", \"frog\")).thenReturn(true);",
        "line": 245,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.changeWorkingDirectory(Mockito.anyString())).thenReturn(true);",
        "line": 246,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.retrieveFile(Mockito.eq(\"remote-test-dir/\" + fileName), Mockito.any(OutputStream.class))).thenReturn(true);",
        "line": 250,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.listFiles(\"remote-test-dir\")).thenReturn(ftpFiles.toArray(new FTPFile[0]));",
        "line": 253,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.deleteFile(Mockito.anyString())).thenReturn(true);",
        "line": 255,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.getRemoteAddress()).thenReturn(InetAddress.getByName(\"localhost\"));",
        "line": 256,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.getRemotePort()).thenReturn(-1);",
        "line": 257,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "ftpClient",
    "variableType": "FTPClient",
    "mockedClass": "FTPClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\inbound\\FtpInboundRemoteFileSystemSynchronizerTests.java",
      "className": "FtpInboundRemoteFileSystemSynchronizerTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private static FTPClient ftpClient = mock(FTPClient.class);",
        "line": 72,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.getReplyCode()).thenReturn(250);",
        "line": 244,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.login(\"kermit\", \"frog\")).thenReturn(true);",
        "line": 245,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.changeWorkingDirectory(Mockito.anyString())).thenReturn(true);",
        "line": 246,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.retrieveFile(Mockito.eq(\"remote-test-dir/\" + fileName), Mockito.any(OutputStream.class))).thenReturn(true);",
        "line": 250,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.listFiles(\"remote-test-dir\")).thenReturn(ftpFiles.toArray(new FTPFile[0]));",
        "line": 253,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.deleteFile(Mockito.anyString())).thenReturn(true);",
        "line": 255,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.getRemoteAddress()).thenReturn(InetAddress.getByName(\"localhost\"));",
        "line": 256,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.getRemotePort()).thenReturn(-1);",
        "line": 257,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\outbound\\FtpOutboundTests.java",
      "className": "FtpOutboundTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log logger = spy(TestUtils.getPropertyValue(handler, \"remoteFileTemplate.logger\", Log.class));",
        "line": 157,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHandleMissingFileMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isWarnEnabled()).thenReturn(true);",
        "line": 158,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHandleMissingFileMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "ftpClient",
    "variableType": "FTPClient",
    "mockedClass": "FTPClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\outbound\\FtpOutboundTests.java",
      "className": "FtpOutboundTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private static FTPClient ftpClient;",
        "line": 71,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "ftpClient = mock(FTPClient.class);",
        "line": 77,
        "locate": "@Before",
        "locationContext": {
          "methodName": "prepare",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.getReplyCode()).thenReturn(250);",
        "line": 224,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.login(\"kermit\", \"frog\")).thenReturn(true);",
        "line": 225,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.changeWorkingDirectory(Mockito.anyString())).thenReturn(true);",
        "line": 226,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.printWorkingDirectory()).thenReturn(\"remote-target-dir\");",
        "line": 227,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.storeFile(Mockito.anyString(), any(InputStream.class))).thenAnswer(invocation -> {\r\n    String fileName = invocation.getArgument(0);\r\n    InputStream fis = invocation.getArgument(1);\r\n    FileCopyUtils.copy(fis, new FileOutputStream(fileName));\r\n    return true;\r\n});",
        "line": 228,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.rename(Mockito.anyString(), Mockito.anyString())).thenAnswer(invocation -> {\r\n    File file = new File((String) invocation.getArgument(0));\r\n    File renameToFile = new File((String) invocation.getArgument(1));\r\n    file.renameTo(renameToFile);\r\n    return true;\r\n});",
        "line": 234,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.retrieveFile(Mockito.eq(\"remote-test-dir/\" + fileName), any(OutputStream.class))).thenReturn(true);",
        "line": 248,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.listFiles(\"remote-test-dir/\")).thenReturn(ftpFiles.toArray(new FTPFile[0]));",
        "line": 251,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.getRemoteAddress()).thenReturn(InetAddress.getByName(\"127.0.0.1\"));",
        "line": 253,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "ftpClient",
    "variableType": "FTPClient",
    "mockedClass": "FTPClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\outbound\\FtpOutboundTests.java",
      "className": "FtpOutboundTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private static FTPClient ftpClient;",
        "line": 71,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "ftpClient = mock(FTPClient.class);",
        "line": 77,
        "locate": "@Before",
        "locationContext": {
          "methodName": "prepare",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.getReplyCode()).thenReturn(250);",
        "line": 224,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.login(\"kermit\", \"frog\")).thenReturn(true);",
        "line": 225,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.changeWorkingDirectory(Mockito.anyString())).thenReturn(true);",
        "line": 226,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.printWorkingDirectory()).thenReturn(\"remote-target-dir\");",
        "line": 227,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.storeFile(Mockito.anyString(), any(InputStream.class))).thenAnswer(invocation -> {\r\n    String fileName = invocation.getArgument(0);\r\n    InputStream fis = invocation.getArgument(1);\r\n    FileCopyUtils.copy(fis, new FileOutputStream(fileName));\r\n    return true;\r\n});",
        "line": 228,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.rename(Mockito.anyString(), Mockito.anyString())).thenAnswer(invocation -> {\r\n    File file = new File((String) invocation.getArgument(0));\r\n    File renameToFile = new File((String) invocation.getArgument(1));\r\n    file.renameTo(renameToFile);\r\n    return true;\r\n});",
        "line": 234,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.retrieveFile(Mockito.eq(\"remote-test-dir/\" + fileName), any(OutputStream.class))).thenReturn(true);",
        "line": 248,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.listFiles(\"remote-test-dir/\")).thenReturn(ftpFiles.toArray(new FTPFile[0]));",
        "line": 251,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(ftpClient.getRemoteAddress()).thenReturn(InetAddress.getByName(\"127.0.0.1\"));",
        "line": 253,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createClientInstance",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "FTPClient",
    "mockedClass": "FTPClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\outbound\\FtpServerOutboundTests.java",
      "className": "FtpServerOutboundTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FTPClient client = spy(TestUtils.getPropertyValue(session, \"client\", FTPClient.class));",
        "line": 399,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3088MPutNotRecursive",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).sendSiteCommand(\"chmod 600 ftpTarget/localSource1.txt\");",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3088MPutNotRecursive",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).sendSiteCommand(\"chmod 600 ftpTarget/localSource1.txt\");",
        "line": 418,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3088MPutNotRecursive",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "FTPClient",
    "mockedClass": "FTPClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\outbound\\FtpServerOutboundTests.java",
      "className": "FtpServerOutboundTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FTPClient client = spy(TestUtils.getPropertyValue(session, \"client\", FTPClient.class));",
        "line": 461,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3412FileMode",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, times(2)).sendSiteCommand(\"chmod 600 ftpTarget/appending.txt\");",
        "line": 482,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3412FileMode",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<FTPFile>",
    "mockedClass": "Session<FTPFile>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\outbound\\FtpServerOutboundTests.java",
      "className": "FtpServerOutboundTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<FTPFile> session = spy(this.ftpSessionFactory.getSession());",
        "line": 614,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "spyOnSession",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<FTPFile>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\session\\FtpRemoteFileTemplateTests.java",
      "className": "FtpRemoteFileTemplateTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nSessionFactory<FTPFile> sessionFactory = mock(SessionFactory.class);",
        "line": 104,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFileCloseOnBadConnect",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenThrow(new RuntimeException(\"bar\"));",
        "line": 106,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFileCloseOnBadConnect",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "FTPClient",
    "mockedClass": "FTPClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\session\\SessionFactoryTests.java",
      "className": "SessionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final FTPClient client = mock(FTPClient.class);",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFtpClientInteraction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).setConnectTimeout(123);",
        "line": 76,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFtpClientInteraction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).setDefaultTimeout(456);",
        "line": 77,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFtpClientInteraction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).setDataTimeout(Duration.ofMillis(789));",
        "line": 78,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFtpClientInteraction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).logout();",
        "line": 82,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFtpClientInteraction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).disconnect();",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFtpClientInteraction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).logout();",
        "line": 89,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFtpClientInteraction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, times(2)).disconnect();",
        "line": 90,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFtpClientInteraction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionB",
    "variableType": "Session<FTPFile>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\session\\SessionFactoryTests.java",
      "className": "SessionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<FTPFile> sessionB = Mockito.mock(Session.class);",
        "line": 150,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaleConnection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(sessionB.isOpen()).thenReturn(false);",
        "line": 152,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaleConnection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionA",
    "variableType": "Session<FTPFile>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\session\\SessionFactoryTests.java",
      "className": "SessionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<FTPFile> sessionA = Mockito.mock(Session.class);",
        "line": 149,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaleConnection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(sessionA.isOpen()).thenReturn(true);",
        "line": 151,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaleConnection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<FTPFile>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\session\\SessionFactoryTests.java",
      "className": "SessionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);",
        "line": 148,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaleConnection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(sessionFactory.getSession()).thenReturn(sessionA);",
        "line": 154,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaleConnection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(sessionFactory.getSession()).thenReturn(sessionB);",
        "line": 155,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaleConnection",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<FTPFile>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\session\\SessionFactoryTests.java",
      "className": "SessionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<FTPFile> session = Mockito.mock(Session.class);",
        "line": 171,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSameSessionFromThePool",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<FTPFile>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\session\\SessionFactoryTests.java",
      "className": "SessionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);",
        "line": 170,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSameSessionFromThePool",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(sessionFactory.getSession()).thenReturn(session);",
        "line": 172,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSameSessionFromThePool",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(sessionFactory, Mockito.times(2)).getSession();",
        "line": 182,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSameSessionFromThePool",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<FTPFile>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\session\\SessionFactoryTests.java",
      "className": "SessionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<FTPFile> session = Mockito.mock(Session.class);",
        "line": 189,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSessionWaitExpire",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<FTPFile>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ftp\\src\\test\\java\\org\\springframework\\integration\\ftp\\session\\SessionFactoryTests.java",
      "className": "SessionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);",
        "line": 188,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSessionWaitExpire",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(sessionFactory.getSession()).thenReturn(session);",
        "line": 190,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSessionWaitExpire",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "candidate",
    "variableType": "DefaultCandidate",
    "mockedClass": "DefaultCandidate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.hazelcast.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-hazelcast\\src\\test\\java\\org\\springframework\\integration\\hazelcast\\leader\\LeaderInitiatorTests.java",
      "className": "LeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DefaultCandidate candidate = spy(new DefaultCandidate());",
        "line": 184,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLeaderElections",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "candidate",
    "variableType": "Candidate",
    "mockedClass": "Candidate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.hazelcast.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-hazelcast\\src\\test\\java\\org\\springframework\\integration\\hazelcast\\leader\\LeaderInitiatorTests.java",
      "className": "LeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Candidate candidate = mock();",
        "line": 219,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(candidate.getRole()).willReturn(\"role\");",
        "line": 224,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "leaderEventPublisher",
    "variableType": "LeaderEventPublisher",
    "mockedClass": "LeaderEventPublisher",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.hazelcast.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-hazelcast\\src\\test\\java\\org\\springframework\\integration\\hazelcast\\leader\\LeaderInitiatorTests.java",
      "className": "LeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LeaderEventPublisher leaderEventPublisher = mock();",
        "line": 221,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// verify revoke event is published\r\nverify(leaderEventPublisher).publishOnRevoked(any(Object.class), any(Context.class), anyString());",
        "line": 258,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "fencedLock",
    "variableType": "FencedLock",
    "mockedClass": "FencedLock",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.hazelcast.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-hazelcast\\src\\test\\java\\org\\springframework\\integration\\hazelcast\\leader\\LeaderInitiatorTests.java",
      "className": "LeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FencedLock fencedLock = mock();",
        "line": 220,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(fencedLock.getGroupId()).willReturn(new CPGroupId() {\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"\";\r\n    }\r\n\r\n    @Override\r\n    public long getId() {\r\n        return 0;\r\n    }\r\n});",
        "line": 227,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "// Simulate that the lock is currently held by this thread\r\ngiven(fencedLock.isLockedByCurrentThread()).willReturn(true, false);",
        "line": 245,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "// Lock acquisition fails\r\ngiven(fencedLock.tryLock(anyLong(), any(TimeUnit.class))).willReturn(false);",
        "line": 246,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// Verify that revokeLeadership was called due to lock not being acquired\r\n// unlock is part of revokeLeadership\r\nverify(fencedLock).unlock();",
        "line": 256,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "hazelcastInstance",
    "variableType": "HazelcastInstance",
    "mockedClass": "HazelcastInstance",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.hazelcast.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-hazelcast\\src\\test\\java\\org\\springframework\\integration\\hazelcast\\leader\\LeaderInitiatorTests.java",
      "className": "LeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "// Initialize mocks and objects needed for the revoke leadership when fenced lock is no longer acquired\r\nHazelcastInstance hazelcastInstance = mock();",
        "line": 218,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(hazelcastInstance.getCPSubsystem()).willReturn(cpSubsystem);",
        "line": 225,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "cpSubsystem",
    "variableType": "CPSubsystem",
    "mockedClass": "CPSubsystem",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.hazelcast.leader",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-hazelcast\\src\\test\\java\\org\\springframework\\integration\\hazelcast\\leader\\LeaderInitiatorTests.java",
      "className": "LeaderInitiatorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "CPSubsystem cpSubsystem = mock(CPSubsystem.class);",
        "line": 223,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(cpSubsystem.getLock(anyString())).willReturn(fencedLock);",
        "line": 226,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRevokeLeadershipCalledWhenLockNotAcquiredButStillLeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "listener",
    "variableType": "MetadataStoreListener",
    "mockedClass": "MetadataStoreListener",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.hazelcast.metadata",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-hazelcast\\src\\test\\java\\org\\springframework\\integration\\hazelcast\\metadata\\HazelcastMetadataStoreTests.java",
      "className": "HazelcastMetadataStoreTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MetadataStoreListener listener = mock(MetadataStoreListener.class);",
        "line": 151,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testListener",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(listener).onAdd(\"foo\", \"bar\");",
        "line": 158,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testListener",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(listener).onUpdate(\"foo\", \"baz\");",
        "line": 159,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testListener",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(listener).onRemove(\"foo\", \"baz\");",
        "line": 160,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testListener",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "template",
    "variableType": "RestTemplate",
    "mockedClass": "RestTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.http",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-http\\src\\test\\java\\org\\springframework\\integration\\http\\HttpProxyScenarioTests.java",
      "className": "HttpProxyScenarioTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RestTemplate template = Mockito.spy(new RestTemplate());",
        "line": 119,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHttpProxyScenario",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "template",
    "variableType": "RestTemplate",
    "mockedClass": "RestTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.http",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-http\\src\\test\\java\\org\\springframework\\integration\\http\\HttpProxyScenarioTests.java",
      "className": "HttpProxyScenarioTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RestTemplate template = Mockito.spy(new RestTemplate());",
        "line": 178,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHttpMultipartProxyScenario",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "view",
    "variableType": "View",
    "mockedClass": "View",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.http.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-http\\src\\test\\java\\org\\springframework\\integration\\http\\inbound\\HttpRequestHandlingControllerTests.java",
      "className": "HttpRequestHandlingControllerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final View view = mock(View.class);",
        "line": 187,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "requestReplyViewExpressionView",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "multipartResolver",
    "variableType": "MultipartResolver",
    "mockedClass": "MultipartResolver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.http.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-http\\src\\test\\java\\org\\springframework\\integration\\http\\inbound\\HttpRequestHandlingMessagingGatewayTests.java",
      "className": "HttpRequestHandlingMessagingGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MultipartResolver multipartResolver = mock(MultipartResolver.class);",
        "line": 459,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMultipart",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(multipartResolver).isMultipart(any(HttpServletRequest.class));",
        "line": 473,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMultipart",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "request",
    "variableType": "HttpServletRequest",
    "mockedClass": "HttpServletRequest",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.http.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-http\\src\\test\\java\\org\\springframework\\integration\\http\\inbound\\MultipartAsRawByteArrayTests.java",
      "className": "MultipartAsRawByteArrayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "HttpServletRequest request = mock(HttpServletRequest.class);",
        "line": 63,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMultiPass",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(request.getInputStream()).thenReturn(sis);",
        "line": 66,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMultiPass",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(request.getMethod()).thenReturn(\"POST\");",
        "line": 67,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMultiPass",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(request.getHeaderNames()).thenReturn(mock(Enumeration.class));",
        "line": 68,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMultiPass",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(request.getContentType()).thenReturn(\"multipart/form-data\");",
        "line": 69,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMultiPass",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(request.getRequestURL()).thenReturn(new StringBuffer(\"foo\"));",
        "line": 70,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMultiPass",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sis",
    "variableType": "ServletInputStream",
    "mockedClass": "ServletInputStream",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.http.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-http\\src\\test\\java\\org\\springframework\\integration\\http\\inbound\\MultipartAsRawByteArrayTests.java",
      "className": "MultipartAsRawByteArrayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ServletInputStream sis = mock(ServletInputStream.class);",
        "line": 64,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMultiPass",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mock",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\config\\ParserUnitTests.java",
      "className": "Config"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory mock = mock(AbstractClientConnectionFactory.class);",
        "line": 704,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockClientCf",
          "methodAnnotations": [
            "@Bean"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(mock.isSingleUse()).willReturn(true);",
        "line": 705,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockClientCf",
          "methodAnnotations": [
            "@Bean"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factSupp",
    "variableType": "TcpSocketFactorySupport",
    "mockedClass": "TcpSocketFactorySupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\dsl\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketFactorySupport factSupp = mock(TcpSocketFactorySupport.class);",
        "line": 104,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "netCustomServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sockSupp",
    "variableType": "TcpSocketSupport",
    "mockedClass": "TcpSocketSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\dsl\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "netCustomServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "conSupp",
    "variableType": "TcpNetConnectionSupport",
    "mockedClass": "TcpNetConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\dsl\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpNetConnectionSupport conSupp = mock(TcpNetConnectionSupport.class);",
        "line": 103,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "netCustomServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sockSupp",
    "variableType": "TcpSocketSupport",
    "mockedClass": "TcpSocketSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\dsl\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);",
        "line": 117,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "nioCustomServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "conSupp",
    "variableType": "TcpNioConnectionSupport",
    "mockedClass": "TcpNioConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\dsl\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpNioConnectionSupport conSupp = mock(TcpNioConnectionSupport.class);",
        "line": 118,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "nioCustomServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factSupp",
    "variableType": "TcpSocketFactorySupport",
    "mockedClass": "TcpSocketFactorySupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\dsl\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketFactorySupport factSupp = mock(TcpSocketFactorySupport.class);",
        "line": 133,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "netCustomClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sockSupp",
    "variableType": "TcpSocketSupport",
    "mockedClass": "TcpSocketSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\dsl\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);",
        "line": 131,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "netCustomClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "conSupp",
    "variableType": "TcpNetConnectionSupport",
    "mockedClass": "TcpNetConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\dsl\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpNetConnectionSupport conSupp = mock(TcpNetConnectionSupport.class);",
        "line": 132,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "netCustomClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sockSupp",
    "variableType": "TcpSocketSupport",
    "mockedClass": "TcpSocketSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\dsl\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);",
        "line": 146,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "nioCustomClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "conSupp",
    "variableType": "TcpNioConnectionSupport",
    "mockedClass": "TcpNioConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\dsl\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpNioConnectionSupport conSupp = mock(TcpNioConnectionSupport.class);",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "nioCustomClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);",
        "line": 132,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.isRunning()).thenReturn(true);",
        "line": 133,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2);",
        "line": 136,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log logger = spy(TestUtils.getPropertyValue(cachedConn1, \"logger\", Log.class));",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isDebugEnabled()).thenReturn(true);",
        "line": 143,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).debug(captor.capture());",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuse",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);",
        "line": 162,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuseNoLimit",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.isRunning()).thenReturn(true);",
        "line": 163,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuseNoLimit",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2);",
        "line": 166,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuseNoLimit",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);",
        "line": 182,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuseClosed",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.isRunning()).thenReturn(true);",
        "line": 183,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuseClosed",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2).thenReturn(mockConn1).thenReturn(mockConn2);",
        "line": 187,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReuseClosed",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);",
        "line": 211,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLimit",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.isRunning()).thenReturn(true);",
        "line": 212,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLimit",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLimit",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);",
        "line": 232,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStop",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.isRunning()).thenReturn(true);",
        "line": 233,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStop",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2).thenReturn(makeMockConnection(\"conn\" + (i++)));",
        "line": 237,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStop",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.isRunning()).thenReturn(false);",
        "line": 253,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStop",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.isRunning()).thenReturn(true);",
        "line": 260,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStop",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);",
        "line": 270,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEnlargePool",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.isRunning()).thenReturn(true);",
        "line": 271,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEnlargePool",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getConnection()).thenReturn(mockConn1, mockConn2, mockConn3, mockConn4);",
        "line": 276,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEnlargePool",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);",
        "line": 299,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReducePool",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.isRunning()).thenReturn(true);",
        "line": 300,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReducePool",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2).thenReturn(mockConn3).thenReturn(mockConn4);",
        "line": 305,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReducePool",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);",
        "line": 368,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createCCCFWith2Connections",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.isRunning()).thenReturn(true);",
        "line": 369,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createCCCFWith2Connections",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getConnection()).thenReturn(conn1, conn2);",
        "line": 370,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createCCCFWith2Connections",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "stream",
    "variableType": "OutputStream",
    "mockedClass": "OutputStream",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "OutputStream stream = mock(OutputStream.class);",
        "line": 380,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockedTcpNetConnection",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 378,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockedTcpNetConnection",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "// closed when next retrieved\r\nwhen(socket.isClosed()).thenReturn(true);",
        "line": 379,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockedTcpNetConnection",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getOutputStream()).thenReturn(stream);",
        "line": 382,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockedTcpNetConnection",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "socketChannel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel socketChannel = mock(SocketChannel.class);",
        "line": 391,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockedTcpNioConnection",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socketChannel.socket()).thenReturn(mock(Socket.class));",
        "line": 394,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockedTcpNioConnection",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "mockConn1",
    "variableType": "TcpConnectionSupport",
    "mockedClass": "TcpConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnectionSupport mockConn1 = mock(TcpConnectionSupport.class);",
        "line": 407,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "makeMockConnection",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(mockConn1.getConnectionId()).thenReturn(name);",
        "line": 408,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "makeMockConnection",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(mockConn1.toString()).thenReturn(name);",
        "line": 409,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "makeMockConnection",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(mockConn1.isOpen()).thenReturn(true);",
        "line": 410,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "makeMockConnection",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "factory2",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);",
        "line": 504,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCachedFailover",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.getConnection()).thenReturn(mockConn2);",
        "line": 511,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCachedFailover",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.isActive()).thenReturn(true);",
        "line": 513,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCachedFailover",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory1",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "// Failover\r\nAbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);",
        "line": 503,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCachedFailover",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.getConnection()).thenReturn(mockConn1);",
        "line": 510,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCachedFailover",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.isActive()).thenReturn(true);",
        "line": 512,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCachedFailover",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(gate, \"logger\", LogAccessor.class));",
        "line": 737,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGatewayRelease",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isDebugEnabled()).thenReturn(true);",
        "line": 739,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGatewayRelease",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, never()).error(anyString());",
        "line": 772,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGatewayRelease",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final AbstractClientConnectionFactory factory = new TcpNetClientConnectionFactory(\"\", 0) {\r\n\r\n    @Override\r\n    protected Socket createSocket(String host, int port) throws IOException {\r\n        Socket mock = mock(Socket.class);\r\n        when(mock.getInputStream()).thenReturn(new ByteArrayInputStream(\"foo\\r\\n\".getBytes()));\r\n        return mock;\r\n    }\r\n\r\n    @Override\r\n    public boolean isActive() {\r\n        return true;\r\n    }\r\n};",
        "line": 780,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEarlyReceive",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mock",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket mock = mock(Socket.class);",
        "line": 784,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSocket",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(mock.getInputStream()).thenReturn(new ByteArrayInputStream(\"foo\\r\\n\".getBytes()));",
        "line": 785,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSocket",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnectionSupport",
    "mockedClass": "TcpConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\CachingClientConnectionFactoryTests.java",
      "className": "CachingClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnectionSupport connection = mock(TcpConnectionSupport.class);",
        "line": 815,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "makeMockConnection",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.isOpen()).thenReturn(true);",
        "line": 816,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "makeMockConnection",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "serializer",
    "variableType": "Serializer<Object>",
    "mockedClass": "Serializer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\ConnectionEventTests.java",
      "className": "ConnectionEventTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "/*\r\n\t\t *  Open is not published by the connection itself; the factory publishes it after initialization.\r\n\t\t *  See ConnectionToConnectionTests.\r\n\t\t */\r\n@SuppressWarnings(\"unchecked\")\r\nSerializer<Object> serializer = mock(Serializer.class);",
        "line": 97,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConnectionEvents",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\ConnectionEventTests.java",
      "className": "ConnectionEventTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 78,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConnectionEvents",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\ConnectionEventTests.java",
      "className": "ConnectionEventTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(factory, \"logger\", LogAccessor.class));",
        "line": 285,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testServerExceptionGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).error(throwableCaptor.capture(), reasonCaptor.capture());",
        "line": 298,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testServerExceptionGuts",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "bf",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory bf = mock(BeanFactory.class);",
        "line": 165,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testObtainConnectionIds",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(bf.containsBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)).thenReturn(true);",
        "line": 166,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testObtainConnectionIds",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(bf.getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)).thenReturn(scheduler);",
        "line": 167,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testObtainConnectionIds",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "event",
    "variableType": "FooEvent",
    "mockedClass": "FooEvent",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FooEvent event = new FooEvent(client, \"foo\");",
        "line": 201,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testObtainConnectionIds",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "event = new FooEvent(mock(TcpConnectionSupport.class), \"foo\");",
        "line": 208,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testObtainConnectionIds",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\ConnectionFactoryTests.java",
      "className": "ConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log logger = spy(logAccessor.getLog());",
        "line": 239,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEarlyClose",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isInfoEnabled()).thenReturn(true);",
        "line": 244,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEarlyClose",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isDebugEnabled()).thenReturn(true);",
        "line": 245,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEarlyClose",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, atLeast(1)).debug(captor.capture());",
        "line": 269,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEarlyClose",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "factory2",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);",
        "line": 97,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverGood",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.getConnection()).thenReturn(conn2);",
        "line": 104,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverGood",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.isActive()).thenReturn(true);",
        "line": 106,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverGood",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory1",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverGood",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.getConnection()).thenReturn(conn1);",
        "line": 103,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverGood",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.isActive()).thenReturn(true);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverGood",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory2",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);",
        "line": 134,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRefreshShared",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.getConnection()).thenReturn(conn1, conn2);",
        "line": 145,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRefreshShared",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.getConnection()).thenReturn(conn1);",
        "line": 148,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRefreshShared",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.isActive()).thenReturn(true);",
        "line": 151,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRefreshShared",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(factory2).getConnection();",
        "line": 160,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRefreshShared",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(factory2).getConnection();",
        "line": 168,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRefreshShared",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "factory1",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);",
        "line": 133,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRefreshShared",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.isActive()).thenReturn(true);",
        "line": 150,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRefreshShared",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(factory1).getConnection();",
        "line": 159,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRefreshShared",
          "methodAnnotations": []
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(factory1).getConnection();",
        "line": 167,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRefreshShared",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "factory2",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);",
        "line": 185,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.getConnection()).thenReturn(conn2);",
        "line": 192,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.isActive()).thenReturn(true);",
        "line": 194,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory1",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);",
        "line": 184,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.getConnection()).thenReturn(conn1);",
        "line": 191,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.isActive()).thenReturn(true);",
        "line": 193,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "cf2",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory cf2 = mock(AbstractClientConnectionFactory.class);",
        "line": 222,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "failoverAllDeadAfterSuccess",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory2",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);",
        "line": 247,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDeadButOriginalOkAgain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.getConnection()).thenReturn(conn2);",
        "line": 254,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDeadButOriginalOkAgain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.isActive()).thenReturn(true);",
        "line": 256,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDeadButOriginalOkAgain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory1",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);",
        "line": 246,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDeadButOriginalOkAgain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.getConnection()).thenReturn(conn1);",
        "line": 253,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDeadButOriginalOkAgain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.isActive()).thenReturn(true);",
        "line": 255,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverAllDeadButOriginalOkAgain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory2",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);",
        "line": 278,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectNone",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException(\"fail\")));",
        "line": 283,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectNone",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.isActive()).thenReturn(true);",
        "line": 285,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectNone",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory1",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);",
        "line": 277,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectNone",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException(\"fail\")));",
        "line": 282,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectNone",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.isActive()).thenReturn(true);",
        "line": 284,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectNone",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory2",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);",
        "line": 296,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectToFirstAfterTriedAll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException(\"fail\")));",
        "line": 305,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectToFirstAfterTriedAll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.isActive()).thenReturn(true);",
        "line": 308,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectToFirstAfterTriedAll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory1",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);",
        "line": 295,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectToFirstAfterTriedAll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException(\"fail\"))).thenReturn(conn1);",
        "line": 302,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectToFirstAfterTriedAll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.isActive()).thenReturn(true);",
        "line": 307,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverConnectToFirstAfterTriedAll",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory2",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);",
        "line": 319,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOkAgainAfterCompleteFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.getConnection()).thenReturn(conn2);",
        "line": 326,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOkAgainAfterCompleteFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory2.isActive()).thenReturn(true);",
        "line": 328,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOkAgainAfterCompleteFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory1",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);",
        "line": 318,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOkAgainAfterCompleteFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.getConnection()).thenReturn(conn1);",
        "line": 325,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOkAgainAfterCompleteFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.isActive()).thenReturn(true);",
        "line": 327,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOkAgainAfterCompleteFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnectionSupport",
    "mockedClass": "TcpConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\FailoverClientConnectionFactoryTests.java",
      "className": "FailoverClientConnectionFactoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnectionSupport connection = mock(TcpConnectionSupport.class);",
        "line": 349,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "makeMockConnection",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.isOpen()).thenReturn(true);",
        "line": 350,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "makeMockConnection",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "SocketFactory",
    "mockedClass": "SocketFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketFactory factory = Mockito.mock(SocketFactory.class);",
        "line": 74,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.createSocket()).thenReturn(socket);",
        "line": 82,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socketSupport",
    "variableType": "TcpSocketSupport",
    "mockedClass": "TcpSocketSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(socketSupport).postProcessSocket(socket);",
        "line": 91,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factorySupport",
    "variableType": "TcpSocketFactorySupport",
    "mockedClass": "TcpSocketFactorySupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);",
        "line": 73,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factorySupport.getSocketFactory()).thenReturn(factory);",
        "line": 75,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "is",
    "variableType": "InputStream",
    "mockedClass": "InputStream",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InputStream is = mock(InputStream.class);",
        "line": 77,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(is.read()).thenReturn(-1);",
        "line": 78,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 76,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getInputStream()).thenReturn(is);",
        "line": 79,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getInetAddress()).thenReturn(inetAddress);",
        "line": 81,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClient",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "SocketFactory",
    "mockedClass": "SocketFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketFactory factory = Mockito.mock(SocketFactory.class);",
        "line": 98,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClientSocketTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.createSocket()).thenReturn(socket);",
        "line": 106,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClientSocketTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socketSupport",
    "variableType": "TcpSocketSupport",
    "mockedClass": "TcpSocketSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);",
        "line": 108,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClientSocketTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factorySupport",
    "variableType": "TcpSocketFactorySupport",
    "mockedClass": "TcpSocketFactorySupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);",
        "line": 97,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClientSocketTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factorySupport.getSocketFactory()).thenReturn(factory);",
        "line": 99,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClientSocketTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "is",
    "variableType": "InputStream",
    "mockedClass": "InputStream",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InputStream is = mock(InputStream.class);",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClientSocketTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(is.read()).thenReturn(-1);",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClientSocketTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 100,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClientSocketTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getInputStream()).thenReturn(is);",
        "line": 103,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClientSocketTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getInetAddress()).thenReturn(inetAddress);",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetClientSocketTimeout",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "ServerSocketFactory",
    "mockedClass": "ServerSocketFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ServerSocketFactory factory = mock(ServerSocketFactory.class);",
        "line": 125,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.createServerSocket(0, 5)).thenReturn(serverSocket);",
        "line": 143,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket1",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket1 = mock(Socket.class);",
        "line": 128,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket1.getInputStream()).thenReturn(is);",
        "line": 132,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket1.getInetAddress()).thenReturn(inetAddress);",
        "line": 135,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socketSupport",
    "variableType": "TcpSocketSupport",
    "mockedClass": "TcpSocketSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketSupport socketSupport = mock(TcpSocketSupport.class);",
        "line": 155,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(socketSupport).postProcessServerSocket(serverSocket);",
        "line": 164,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(socketSupport).postProcessSocket(socket);",
        "line": 165,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factorySupport",
    "variableType": "TcpSocketFactorySupport",
    "mockedClass": "TcpSocketFactorySupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);",
        "line": 124,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factorySupport.getServerSocketFactory()).thenReturn(factory);",
        "line": 126,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "serverSocket",
    "variableType": "ServerSocket",
    "mockedClass": "ServerSocket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ServerSocket serverSocket = mock(ServerSocket.class);",
        "line": 136,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(serverSocket.getInetAddress()).thenReturn(inetAddress);",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(serverSocket.accept()).thenReturn(socket).then(invocation -> {\r\n    if (closed.get()) {\r\n        throw new SocketException();\r\n    }\r\n    latch1.countDown();\r\n    latch2.await(10, TimeUnit.SECONDS);\r\n    Thread.sleep(50);\r\n    return socket1;\r\n});",
        "line": 146,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "is",
    "variableType": "InputStream",
    "mockedClass": "InputStream",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InputStream is = mock(InputStream.class);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(is.read()).thenReturn(-1);",
        "line": 130,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\SocketSupportTests.java",
      "className": "SocketSupportTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 127,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getInputStream()).thenReturn(is);",
        "line": 131,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getInetAddress()).thenReturn(inetAddress);",
        "line": 134,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNetServer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mock",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpConnectionEventListenerTests.java",
      "className": "TcpConnectionEventListenerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory mock = mock(BeanFactory.class);",
        "line": 48,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoFilter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(mock.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class)).willReturn(mock(ApplicationEventMulticaster.class));",
        "line": 49,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoFilter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnectionSupport",
    "mockedClass": "TcpConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpConnectionEventListenerTests.java",
      "className": "TcpConnectionEventListenerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnectionSupport connection = Mockito.mock(TcpConnectionSupport.class);",
        "line": 55,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoFilter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mock",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpConnectionEventListenerTests.java",
      "className": "TcpConnectionEventListenerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory mock = mock(BeanFactory.class);",
        "line": 88,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFilter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(mock.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class)).willReturn(mock(ApplicationEventMulticaster.class));",
        "line": 89,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFilter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnectionSupport",
    "mockedClass": "TcpConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpConnectionEventListenerTests.java",
      "className": "TcpConnectionEventListenerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnectionSupport connection = Mockito.mock(TcpConnectionSupport.class);",
        "line": 95,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFilter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnection",
    "mockedClass": "TcpConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnection connection = mock(TcpConnection.class);",
        "line": 77,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPayload()).thenReturn(TEST_PAYLOAD.getBytes());",
        "line": 82,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostName()).thenReturn(\"MyHost\");",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostAddress()).thenReturn(\"1.1.1.1\");",
        "line": 84,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPort()).thenReturn(1234);",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getSocketInfo()).thenReturn(info);",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 78,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getLocalAddress()).thenReturn(local);",
        "line": 81,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "local",
    "variableType": "InetAddress",
    "mockedClass": "InetAddress",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InetAddress local = mock(InetAddress.class);",
        "line": 79,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnection",
    "mockedClass": "TcpConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnection connection = mock(TcpConnection.class);",
        "line": 100,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPayload()).thenReturn(TEST_PAYLOAD.getBytes());",
        "line": 105,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostName()).thenReturn(\"MyHost\");",
        "line": 106,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostAddress()).thenReturn(\"1.1.1.1\");",
        "line": 107,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPort()).thenReturn(1234);",
        "line": 108,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getSocketInfo()).thenReturn(info);",
        "line": 109,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getLocalAddress()).thenReturn(local);",
        "line": 104,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "local",
    "variableType": "InetAddress",
    "mockedClass": "InetAddress",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InetAddress local = mock(InetAddress.class);",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnection",
    "mockedClass": "TcpConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnection connection = mock(TcpConnection.class);",
        "line": 127,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithCustomContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPayload()).thenReturn(TEST_PAYLOAD.getBytes());",
        "line": 132,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithCustomContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostName()).thenReturn(\"MyHost\");",
        "line": 133,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithCustomContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostAddress()).thenReturn(\"1.1.1.1\");",
        "line": 134,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithCustomContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPort()).thenReturn(1234);",
        "line": 135,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithCustomContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getSocketInfo()).thenReturn(info);",
        "line": 136,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithCustomContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 128,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithCustomContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getLocalAddress()).thenReturn(local);",
        "line": 131,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithCustomContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "local",
    "variableType": "InetAddress",
    "mockedClass": "InetAddress",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InetAddress local = mock(InetAddress.class);",
        "line": 129,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testToMessageWithCustomContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnection",
    "mockedClass": "TcpConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnection connection = mock(TcpConnection.class);",
        "line": 369,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingInboundJson",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPayload()).thenReturn(map);",
        "line": 370,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingInboundJson",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostName()).thenReturn(\"someHost\");",
        "line": 371,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingInboundJson",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostAddress()).thenReturn(\"1.1.1.1\");",
        "line": 372,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingInboundJson",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPort()).thenReturn(1234);",
        "line": 373,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingInboundJson",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getConnectionId()).thenReturn(\"someId\");",
        "line": 374,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingInboundJson",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnection",
    "mockedClass": "TcpConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnection connection = mock(TcpConnection.class);",
        "line": 399,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPayload()).thenReturn(map);",
        "line": 400,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostName()).thenReturn(\"someHost\");",
        "line": 401,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostAddress()).thenReturn(\"1.1.1.1\");",
        "line": 402,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPort()).thenReturn(1234);",
        "line": 403,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getConnectionId()).thenReturn(\"someId\");",
        "line": 404,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMapMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnection",
    "mockedClass": "TcpConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnection connection = mock(TcpConnection.class);",
        "line": 423,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCodecMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPayload()).thenReturn(bytes);",
        "line": 424,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCodecMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostName()).thenReturn(\"someHost\");",
        "line": 425,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCodecMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostAddress()).thenReturn(\"1.1.1.1\");",
        "line": 426,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCodecMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPort()).thenReturn(1234);",
        "line": 427,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCodecMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getConnectionId()).thenReturn(\"someId\");",
        "line": 428,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCodecMessageConvertingBothWaysJava",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnection",
    "mockedClass": "TcpConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpMessageMapperTests.java",
      "className": "TcpMessageMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnection connection = mock(TcpConnection.class);",
        "line": 447,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithBytesMapper",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPayload()).thenReturn(bytes);",
        "line": 448,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithBytesMapper",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostName()).thenReturn(\"someHost\");",
        "line": 449,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithBytesMapper",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getHostAddress()).thenReturn(\"1.1.1.1\");",
        "line": 450,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithBytesMapper",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getPort()).thenReturn(1234);",
        "line": 451,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithBytesMapper",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.getConnectionId()).thenReturn(\"someId\");",
        "line": 452,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithBytesMapper",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "stream",
    "variableType": "InputStream",
    "mockedClass": "InputStream",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNetConnectionTests.java",
      "className": "TcpNetConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "InputStream stream = mock(InputStream.class);",
        "line": 69,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testErrorLog",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(stream.read()).thenReturn((int) 'x');",
        "line": 71,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testErrorLog",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNetConnectionTests.java",
      "className": "TcpNetConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log logger = mock(Log.class);",
        "line": 76,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testErrorLog",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(logger.isErrorEnabled()).willReturn(true);",
        "line": 77,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testErrorLog",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNetConnectionTests.java",
      "className": "TcpNetConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 68,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testErrorLog",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getInputStream()).thenReturn(stream);",
        "line": 70,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testErrorLog",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socketChannel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNetConnectionTests.java",
      "className": "TcpNetConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel socketChannel = mock(SocketChannel.class);",
        "line": 95,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBinary",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socketChannel.socket()).thenReturn(socket);",
        "line": 97,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBinary",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNetConnectionTests.java",
      "className": "TcpNetConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBinary",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "inSocket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNetConnectionTests.java",
      "className": "TcpNetConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket inSocket = mock(Socket.class);",
        "line": 108,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transferHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(inSocket.getInputStream()).thenReturn(pipe);",
        "line": 110,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transferHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "outSocket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNetConnectionTests.java",
      "className": "TcpNetConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket outSocket = mock(Socket.class);",
        "line": 120,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transferHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(outSocket.getOutputStream()).thenReturn(baos);",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transferHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "conn3",
    "variableType": "TcpNioConnection",
    "mockedClass": "TcpNioConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpNioConnection conn3 = mock(TcpNioConnection.class);",
        "line": 260,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCleanup",
          "methodAnnotations": [
            "@Test",
            "@DisabledIfEnvironmentVariable"
          ]
        }
      }
    ]
  },
  {
    "variableName": "conn2",
    "variableType": "TcpNioConnection",
    "mockedClass": "TcpNioConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpNioConnection conn2 = mock(TcpNioConnection.class);",
        "line": 259,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCleanup",
          "methodAnnotations": [
            "@Test",
            "@DisabledIfEnvironmentVariable"
          ]
        }
      }
    ]
  },
  {
    "variableName": "chan3",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel chan3 = mock(SocketChannel.class);",
        "line": 257,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCleanup",
          "methodAnnotations": [
            "@Test",
            "@DisabledIfEnvironmentVariable"
          ]
        }
      }
    ]
  },
  {
    "variableName": "conn1",
    "variableType": "TcpNioConnection",
    "mockedClass": "TcpNioConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpNioConnection conn1 = mock(TcpNioConnection.class);",
        "line": 258,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCleanup",
          "methodAnnotations": [
            "@Test",
            "@DisabledIfEnvironmentVariable"
          ]
        }
      }
    ]
  },
  {
    "variableName": "chan2",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel chan2 = mock(SocketChannel.class);",
        "line": 256,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCleanup",
          "methodAnnotations": [
            "@Test",
            "@DisabledIfEnvironmentVariable"
          ]
        }
      }
    ]
  },
  {
    "variableName": "selector",
    "variableType": "Selector",
    "mockedClass": "Selector",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Selector selector = mock(Selector.class);",
        "line": 267,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCleanup",
          "methodAnnotations": [
            "@Test",
            "@DisabledIfEnvironmentVariable"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(selector.selectedKeys()).thenReturn(keys);",
        "line": 269,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCleanup",
          "methodAnnotations": [
            "@Test",
            "@DisabledIfEnvironmentVariable"
          ]
        }
      }
    ]
  },
  {
    "variableName": "chan1",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel chan1 = mock(SocketChannel.class);",
        "line": 255,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCleanup",
          "methodAnnotations": [
            "@Test",
            "@DisabledIfEnvironmentVariable"
          ]
        }
      }
    ]
  },
  {
    "variableName": "future",
    "variableType": "Future<Object>",
    "mockedClass": "Future<Object>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Future<Object> future = exec.submit(() -> {\r\n    SocketChannel channel = mock(SocketChannel.class);\r\n    Socket socket = mock(Socket.class);\r\n    Mockito.when(channel.socket()).thenReturn(socket);\r\n    doAnswer(invocation -> {\r\n        ByteBuffer buffer = invocation.getArgument(0);\r\n        buffer.position(1);\r\n        return 1;\r\n    }).when(channel).read(Mockito.any(ByteBuffer.class));\r\n    when(socket.getReceiveBufferSize()).thenReturn(1024);\r\n    final TcpNioConnection connection = new TcpNioConnection(channel, false, false, nullPublisher, null);\r\n    connection.setTaskExecutor(exec);\r\n    connection.setPipeTimeout(200);\r\n    Method method = TcpNioConnection.class.getDeclaredMethod(\"doRead\");\r\n    method.setAccessible(true);\r\n    // Nobody reading, should timeout on 6th write.\r\n    try {\r\n        for (int i = 0; i < 6; i++) {\r\n            method.invoke(connection);\r\n        }\r\n    } catch (Exception e) {\r\n        logger.debug(\"Expected timeout\", e);\r\n        throw (Exception) e.getCause();\r\n    } finally {\r\n        connection.setPipeTimeout(15);\r\n        connection.close();\r\n    }\r\n    return null;\r\n});",
        "line": 308,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInsufficientThreads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel channel = mock(SocketChannel.class);",
        "line": 309,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInsufficientThreads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(channel.socket()).thenReturn(socket);",
        "line": 311,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInsufficientThreads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 310,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInsufficientThreads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socket.getReceiveBufferSize()).thenReturn(1024);",
        "line": 317,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInsufficientThreads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "future",
    "variableType": "Future<Object>",
    "mockedClass": "Future<Object>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Future<Object> future = exec.submit(() -> {\r\n    SocketChannel channel = mock(SocketChannel.class);\r\n    Socket socket = mock(Socket.class);\r\n    Mockito.when(channel.socket()).thenReturn(socket);\r\n    doAnswer(invocation -> {\r\n        ByteBuffer buffer = invocation.getArgument(0);\r\n        buffer.position(1025);\r\n        buffer.put((byte) '\\r');\r\n        buffer.put((byte) '\\n');\r\n        return 1027;\r\n    }).when(channel).read(Mockito.any(ByteBuffer.class));\r\n    final TcpNioConnection connection = new TcpNioConnection(channel, false, false, null, null);\r\n    connection.setTaskExecutor(exec);\r\n    connection.registerListener(message -> {\r\n        messageLatch.countDown();\r\n        return false;\r\n    });\r\n    connection.setMapper(new TcpMessageMapper());\r\n    connection.setDeserializer(new ByteArrayCrLfSerializer());\r\n    Method method = TcpNioConnection.class.getDeclaredMethod(\"doRead\");\r\n    method.setAccessible(true);\r\n    try {\r\n        for (int i = 0; i < 20; i++) {\r\n            method.invoke(connection);\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        throw (Exception) e.getCause();\r\n    }\r\n    return null;\r\n});",
        "line": 355,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSufficientThreads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel channel = mock(SocketChannel.class);",
        "line": 356,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSufficientThreads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(channel.socket()).thenReturn(socket);",
        "line": 358,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSufficientThreads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSufficientThreads",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socketChannel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel socketChannel = mock(SocketChannel.class);",
        "line": 396,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socketChannel.socket()).thenReturn(socket);",
        "line": 398,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 397,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socketChannel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel socketChannel = mock(SocketChannel.class);",
        "line": 415,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayReadMulti",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socketChannel.socket()).thenReturn(socket);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayReadMulti",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 416,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayReadMulti",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socketChannel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel socketChannel = mock(SocketChannel.class);",
        "line": 431,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayReadWithOffset",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socketChannel.socket()).thenReturn(socket);",
        "line": 433,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayReadWithOffset",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 432,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayReadWithOffset",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socketChannel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel socketChannel = mock(SocketChannel.class);",
        "line": 446,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayReadWithBadArgs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socketChannel.socket()).thenReturn(socket);",
        "line": 448,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayReadWithBadArgs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 447,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayReadWithBadArgs",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socketChannel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel socketChannel = mock(SocketChannel.class);",
        "line": 472,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayBlocksForZeroRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(socketChannel.socket()).thenReturn(socket);",
        "line": 474,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayBlocksForZeroRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "socket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket socket = mock(Socket.class);",
        "line": 473,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testByteArrayBlocksForZeroRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "inChannel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel inChannel = mock(SocketChannel.class);",
        "line": 499,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transferHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(inChannel.socket()).thenReturn(inSocket);",
        "line": 500,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transferHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "inSocket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket inSocket = mock(Socket.class);",
        "line": 498,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transferHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "outSocket",
    "variableType": "Socket",
    "mockedClass": "Socket",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Socket outSocket = mock(Socket.class);",
        "line": 519,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transferHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "outChannel",
    "variableType": "SocketChannel",
    "mockedClass": "SocketChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SocketChannel outChannel = mock(SocketChannel.class);",
        "line": 520,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transferHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(outChannel.socket()).thenReturn(outSocket);",
        "line": 521,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transferHeaders",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log logger = spy(TestUtils.getPropertyValue(connection, \"logger\", Log.class));",
        "line": 755,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "int3453RaceTest",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "cis",
    "variableType": "ChannelInputStream",
    "mockedClass": "ChannelInputStream",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ChannelInputStream cis = spy(TestUtils.getPropertyValue(connection, \"channelInputStream\", ChannelInputStream.class));",
        "line": 759,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "int3453RaceTest",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "nullPublisher",
    "variableType": "ApplicationEventPublisher",
    "mockedClass": "ApplicationEventPublisher",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp.connection",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\connection\\TcpNioConnectionTests.java",
      "className": "TcpNioConnectionTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "private final ApplicationEventPublisher nullPublisher = mock(ApplicationEventPublisher.class);",
        "line": 110,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "bf",
    "variableType": "BeanFactory",
    "mockedClass": "ConfigurableBeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\TcpInboundGatewayTests.java",
      "className": "TcpInboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory bf = mock(ConfigurableBeanFactory.class);",
        "line": 316,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCloseStream",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "remoteTimeoutExpression",
    "variableType": "Expression",
    "mockedClass": "Expression",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\TcpOutboundGatewayTests.java",
      "className": "TcpOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Expression remoteTimeoutExpression = Mockito.mock(Expression.class);",
        "line": 404,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGoodNetGWTimeoutGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(remoteTimeoutExpression.getValue(any(EvaluationContext.class), any(Message.class), Mockito.eq(Long.class))).thenReturn(50L, 60000L);",
        "line": 406,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGoodNetGWTimeoutGuts",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "factory1",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\TcpOutboundGatewayTests.java",
      "className": "TcpOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "// Failover\r\nAbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);",
        "line": 493,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCachingFailover",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.getConnection()).thenReturn(mockConn1);",
        "line": 495,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCachingFailover",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory1",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\TcpOutboundGatewayTests.java",
      "className": "TcpOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "// Cache\r\nAbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);",
        "line": 575,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverCached",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.getConnection()).thenReturn(mockConn1);",
        "line": 577,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverCached",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory1.isSingleUse()).thenReturn(true);",
        "line": 578,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFailoverCached",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnectionSupport",
    "mockedClass": "TcpConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\TcpOutboundGatewayTests.java",
      "className": "TcpOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnectionSupport connection = mock(TcpConnectionSupport.class);",
        "line": 621,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "makeMockConnection",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.isOpen()).thenReturn(true);",
        "line": 622,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "makeMockConnection",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "ccf",
    "variableType": "AbstractClientConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\TcpOutboundGatewayTests.java",
      "className": "TcpOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractClientConnectionFactory ccf = mock(AbstractClientConnectionFactory.class);",
        "line": 1092,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "semaphoreIsReleasedOnAsyncSendFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "TcpConnection",
    "mockedClass": "TcpConnectionSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\TcpOutboundGatewayTests.java",
      "className": "TcpOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TcpConnection connection = mock(TcpConnectionSupport.class);",
        "line": 1094,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "semaphoreIsReleasedOnAsyncSendFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(connection.getConnectionId()).willReturn(\"testId\");",
        "line": 1096,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "semaphoreIsReleasedOnAsyncSendFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockCcf",
    "variableType": "AbstractConnectionFactory",
    "mockedClass": "AbstractClientConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ip.tcp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ip\\src\\test\\java\\org\\springframework\\integration\\ip\\tcp\\TcpSendingMessageHandlerTests.java",
      "className": "TcpSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractConnectionFactory mockCcf = mock(AbstractClientConnectionFactory.class);",
        "line": 1186,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConnectionException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\config\\JdbcOutboundGatewayParserTests.java",
      "className": "JdbcOutboundGatewayParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log logger = spy(TestUtils.getPropertyValue(handlerJdbcTemplate, \"logger\", Log.class));",
        "line": 124,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testKeyGeneration",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(logger.isDebugEnabled()).willReturn(true);",
        "line": 126,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testKeyGeneration",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).debug(\"Executing prepared SQL statement [insert into bars (status, name) values (0, ?)]\");",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testKeyGeneration",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\config\\JdbcOutboundGatewayParserTests.java",
      "className": "JdbcOutboundGatewayParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log logger = spy(TestUtils.getPropertyValue(pollerJdbcTemplate, \"logger\", Log.class));",
        "line": 168,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithPoller",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(logger.isDebugEnabled()).willReturn(true);",
        "line": 170,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithPoller",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).debug(\"Executing prepared SQL statement [select * from bazz where id=?]\");",
        "line": 189,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithPoller",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "transactionSynchronization",
    "variableType": "TransactionSynchronization",
    "mockedClass": "TransactionSynchronization",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc.lock",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\lock\\DefaultLockRepositoryTests.java",
      "className": "DefaultLockRepositoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "TransactionSynchronization transactionSynchronization = spy(TransactionSynchronization.class);",
        "line": 60,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNewTransactionIsStartedWhenTransactionIsAlreadyActive",
          "methodAnnotations": [
            "@Transactional",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// And was suspended for each invocation of @Transactional methods of DefaultLockRepository,\r\n// that confirms that these methods were called in a separate transaction each.\r\nverify(transactionSynchronization, times(6)).suspend();",
        "line": 74,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNewTransactionIsStartedWhenTransactionIsAlreadyActive",
          "methodAnnotations": [
            "@Transactional",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "repository",
    "variableType": "LockRepository",
    "mockedClass": "LockRepository",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— @Before\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc.lock",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\lock\\JdbcLockRegistryDelegateTests.java",
      "className": "JdbcLockRegistryDelegateTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private LockRepository repository;",
        "line": 48,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "repository = mock(LockRepository.class);",
        "line": 52,
        "locate": "@Before",
        "locationContext": {
          "methodName": "clear",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(repository.acquire(anyString())).thenReturn(true);",
        "line": 55,
        "locate": "@Before",
        "locationContext": {
          "methodName": "clear",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mgs",
    "variableType": "MessageGroupStore",
    "mockedClass": "MessageGroupStore",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\MessageGroupQueueTests.java",
      "className": "MessageGroupQueueTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageGroupStore mgs = Mockito.mock(MessageGroupStore.class);",
        "line": 265,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMgqInterruptionStoreLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(mgs.getMessageGroup(Mockito.any())).thenReturn(mg);",
        "line": 272,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMgqInterruptionStoreLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mg",
    "variableType": "MessageGroup",
    "mockedClass": "MessageGroup",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\MessageGroupQueueTests.java",
      "className": "MessageGroupQueueTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageGroup mg = Mockito.mock(MessageGroup.class);",
        "line": 271,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMgqInterruptionStoreLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(mg.size()).thenReturn(0);",
        "line": 273,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMgqInterruptionStoreLock",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 59,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoredProcExecutorWithNullProcedureName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 71,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoredProcExecutorWithEmptyProcedureName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 82,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGetStoredProcedureNameExpressionAsString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 100,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGetStoredProcedureNameExpressionAsString2",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 113,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetReturningResultSetRowMappersWithNullMap",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetReturningResultSetRowMappersWithMapContainingNullValues",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 137,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetReturningResultSetRowMappersWithEmptyMap",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 150,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetSqlParameterSourceFactoryWithNullParameter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 167,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetSqlParametersWithNullValueInList",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 180,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetSqlParametersWithEmptyList",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 192,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetSqlParametersWithNullList",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 202,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetProcedureParametersWithNullValueInList",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetProcedureParametersWithEmptyList",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DataSource datasource = mock(DataSource.class);",
        "line": 228,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetProcedureParametersWithNullList",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "datasource",
    "variableType": "DataSource",
    "mockedClass": "DataSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jdbc",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jdbc\\src\\test\\java\\org\\springframework\\integration\\jdbc\\StoredProcExecutorTests.java",
      "className": "StoredProcExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final DataSource datasource = mock(DataSource.class);",
        "line": 238,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoredProcExecutorWithNonResolvingExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\ChannelPublishingJmsMessageListenerTests.java",
      "className": "ChannelPublishingJmsMessageListenerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(listener, \"logger\", LogAccessor.class));",
        "line": 75,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBadConversion",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "template",
    "variableType": "JmsTemplate",
    "mockedClass": "JmsTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.jms.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\config\\JmsChannelHistoryTests.java",
      "className": "JmsChannelHistoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "JmsTemplate template = mock(JmsTemplate.class);",
        "line": 58,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistory",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(template, times(1)).convertAndSend(Mockito.any(Message.class));",
        "line": 71,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistory",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mlContainer",
    "variableType": "AbstractMessageListenerContainer",
    "mockedClass": "AbstractMessageListenerContainer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\config\\JmsChannelHistoryTests.java",
      "className": "JmsChannelHistoryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractMessageListenerContainer mlContainer = mock(AbstractMessageListenerContainer.class);",
        "line": 57,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistory",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\DefaultJmsHeaderMapperTests.java",
      "className": "DefaultJmsHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = Mockito.mock(Session.class);",
        "line": 536,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testJsonHeaderMapping",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\JmsOutboundGatewayTests.java",
      "className": "JmsOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = mock(Session.class);",
        "line": 113,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyContainerRecovery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.createConsumer(any(Destination.class), isNull())).thenReturn(consumer);",
        "line": 116,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyContainerRecovery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.createTemporaryQueue()).thenReturn(mock(TemporaryQueue.class));",
        "line": 117,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyContainerRecovery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "message",
    "variableType": "Message",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\JmsOutboundGatewayTests.java",
      "className": "JmsOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final Message message = mock(Message.class);",
        "line": 118,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyContainerRecovery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(message.getJMSCorrelationID()).thenReturn(\"foo\");",
        "line": 133,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyContainerRecovery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connectionFactory",
    "variableType": "ConnectionFactory",
    "mockedClass": "ConnectionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\JmsOutboundGatewayTests.java",
      "className": "JmsOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConnectionFactory connectionFactory = mock(ConnectionFactory.class);",
        "line": 87,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyContainerRecovery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "Connection",
    "mockedClass": "Connection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\JmsOutboundGatewayTests.java",
      "className": "JmsOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final Connection connection = mock(Connection.class);",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyContainerRecovery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(connection.createSession(false, 1)).thenReturn(session);",
        "line": 114,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyContainerRecovery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "MessageConsumer",
    "mockedClass": "MessageConsumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\JmsOutboundGatewayTests.java",
      "className": "JmsOutboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageConsumer consumer = mock(MessageConsumer.class);",
        "line": 115,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReplyContainerRecovery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\OutboundGatewayConnectionTests.java",
      "className": "OutboundGatewayConnectionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 62,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestBrokenConnection",
          "methodAnnotations": [
            "@Test",
            "@Disabled"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.containsBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)).thenReturn(true);",
        "line": 63,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestBrokenConnection",
          "methodAnnotations": [
            "@Test",
            "@Disabled"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)).thenReturn(scheduler);",
        "line": 66,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestBrokenConnection",
          "methodAnnotations": [
            "@Test",
            "@Disabled"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\OutboundGatewayFunctionTests.java",
      "className": "OutboundGatewayFunctionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 75,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDest",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.containsBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)).thenReturn(true);",
        "line": 76,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDest",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)).thenReturn(scheduler);",
        "line": 79,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDest",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\OutboundGatewayFunctionTests.java",
      "className": "OutboundGatewayFunctionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 121,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestNoCorrelation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.containsBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)).thenReturn(true);",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestNoCorrelation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)).thenReturn(scheduler);",
        "line": 125,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestNoCorrelation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\OutboundGatewayFunctionTests.java",
      "className": "OutboundGatewayFunctionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 169,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.containsBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)).thenReturn(true);",
        "line": 170,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)).thenReturn(scheduler);",
        "line": 173,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestName",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\OutboundGatewayFunctionTests.java",
      "className": "OutboundGatewayFunctionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestNameNoCorrelation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.containsBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)).thenReturn(true);",
        "line": 216,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestNameNoCorrelation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)).thenReturn(scheduler);",
        "line": 219,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithDestNameNoCorrelation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\OutboundGatewayFunctionTests.java",
      "className": "OutboundGatewayFunctionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 263,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithTemporary",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.containsBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)).thenReturn(true);",
        "line": 264,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithTemporary",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)).thenReturn(scheduler);",
        "line": 267,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithTemporary",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\OutboundGatewayFunctionTests.java",
      "className": "OutboundGatewayFunctionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 309,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithTemporaryNoCorrelation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.containsBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)).thenReturn(true);",
        "line": 310,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithTemporaryNoCorrelation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)).thenReturn(scheduler);",
        "line": 313,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testContainerWithTemporaryNoCorrelation",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "beanFactory",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\OutboundGatewayFunctionTests.java",
      "className": "OutboundGatewayFunctionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory beanFactory = mock(BeanFactory.class);",
        "line": 356,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLazyContainerWithDest",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.containsBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)).thenReturn(true);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLazyContainerWithDest",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(beanFactory.getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)).thenReturn(scheduler);",
        "line": 360,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testLazyContainerWithDest",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "interceptor",
    "variableType": "ChannelInterceptor",
    "mockedClass": "ChannelInterceptor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\PollableJmsChannelTests.java",
      "className": "PollableJmsChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ChannelInterceptor interceptor = spy(new SampleInterceptor(false));",
        "line": 116,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "queueNameWithFalsePreReceiveInterceptors",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(interceptor, times(1)).preReceive(Mockito.any(MessageChannel.class));",
        "line": 126,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "queueNameWithFalsePreReceiveInterceptors",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(interceptor, times(0)).postReceive(Mockito.any(Message.class), Mockito.any(MessageChannel.class));",
        "line": 127,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "queueNameWithFalsePreReceiveInterceptors",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "interceptor",
    "variableType": "ChannelInterceptor",
    "mockedClass": "ChannelInterceptor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\PollableJmsChannelTests.java",
      "className": "PollableJmsChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ChannelInterceptor interceptor = spy(new SampleInterceptor(true));",
        "line": 139,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "queueNameWithTruePreReceiveInterceptors",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(interceptor, times(1)).preReceive(Mockito.any(MessageChannel.class));",
        "line": 149,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "queueNameWithTruePreReceiveInterceptors",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(interceptor, times(1)).postReceive(Mockito.any(Message.class), Mockito.any(MessageChannel.class));",
        "line": 150,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "queueNameWithTruePreReceiveInterceptors",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jms",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jms\\src\\test\\java\\org\\springframework\\integration\\jms\\SubscribableJmsChannelTests.java",
      "className": "SubscribableJmsChannelTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log logger = mock(Log.class);",
        "line": 297,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "insertMockLoggerInListener",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isWarnEnabled()).thenReturn(true);",
        "line": 306,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "insertMockLoggerInListener",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.jmx.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jmx\\src\\test\\java\\org\\springframework\\integration\\jmx\\config\\OperationInvokingChannelAdapterParserTests.java",
      "className": "OperationInvokingChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(this.operationWithNonNullReturnHandler, \"logger\", LogAccessor.class));",
        "line": 100,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOutboundAdapterWithNonNullReturn",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).warn(\"This component doesn't expect a reply. \" + \"The MBean operation 'testWithReturn' result '[test1]' for \" + \"'org.springframework.integration.jmx.config:type=TestBean,name=testBeanAdapter' is ignored.\");",
        "line": 113,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOutboundAdapterWithNonNullReturn",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.jmx.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jmx\\src\\test\\java\\org\\springframework\\integration\\jmx\\config\\OperationInvokingChannelAdapterParserTests.java",
      "className": "OperationInvokingChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(this.operationWithinChainWithNonNullReturnHandler, \"logger\", LogAccessor.class));",
        "line": 136,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOperationWithinChainWithNonNullReturn",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).warn(\"This component doesn't expect a reply. \" + \"The MBean operation 'testWithReturn' result '[test1]' for \" + \"'org.springframework.integration.jmx.config:type=TestBean,name=testBeanAdapter' is ignored.\");",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOperationWithinChainWithNonNullReturn",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "requestParameterSourceFactory",
    "variableType": "ParameterSourceFactory",
    "mockedClass": "ParameterSourceFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.core",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\core\\HibernateJpaOperationsTests.java",
      "className": "HibernateJpaOperationsTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ParameterSourceFactory requestParameterSourceFactory = new ExpressionEvaluatingParameterSourceFactory(mock(BeanFactory.class));",
        "line": 89,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExecuteUpdate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "requestParameterSourceFactory",
    "variableType": "ParameterSourceFactory",
    "mockedClass": "ParameterSourceFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.core",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\core\\HibernateJpaOperationsTests.java",
      "className": "HibernateJpaOperationsTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ParameterSourceFactory requestParameterSourceFactory = new ExpressionEvaluatingParameterSourceFactory(mock(BeanFactory.class));",
        "line": 108,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExecuteUpdateWithNamedQuery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "requestParameterSourceFactory",
    "variableType": "ExpressionEvaluatingParameterSourceFactory",
    "mockedClass": "ExpressionEvaluatingParameterSourceFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.core",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\core\\HibernateJpaOperationsTests.java",
      "className": "HibernateJpaOperationsTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ExpressionEvaluatingParameterSourceFactory requestParameterSourceFactory = new ExpressionEvaluatingParameterSourceFactory(mock(BeanFactory.class));",
        "line": 124,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExecuteUpdateWithNativeQuery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "requestParameterSourceFactory",
    "variableType": "ParameterSourceFactory",
    "mockedClass": "ParameterSourceFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.core",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\core\\HibernateJpaOperationsTests.java",
      "className": "HibernateJpaOperationsTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ParameterSourceFactory requestParameterSourceFactory = new ExpressionEvaluatingParameterSourceFactory(mock(BeanFactory.class));",
        "line": 186,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExecuteUpdateWithNativeNamedQuery",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "jpaExecutor",
    "variableType": "JpaExecutor",
    "mockedClass": "JpaExecutor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.core",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\core\\JpaExecutorTests.java",
      "className": "JpaExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "JpaExecutor jpaExecutor = new JpaExecutor(mock(EntityManager.class));",
        "line": 70,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExecutePollWithNoEntityClassSpecified",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "executor",
    "variableType": "JpaExecutor",
    "mockedClass": "JpaExecutor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.core",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\core\\JpaExecutorTests.java",
      "className": "JpaExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final JpaExecutor executor = new JpaExecutor(mock(EntityManager.class));",
        "line": 90,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetMultipleQueryTypes",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "executor2",
    "variableType": "JpaExecutor",
    "mockedClass": "JpaExecutor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.core",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\core\\JpaExecutorTests.java",
      "className": "JpaExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final JpaExecutor executor2 = new JpaExecutor(mock(EntityManager.class));",
        "line": 106,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSetMultipleQueryTypes",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "ExpressionEvaluatingParameterSourceFactory",
    "mockedClass": "ExpressionEvaluatingParameterSourceFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.core",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\core\\JpaExecutorTests.java",
      "className": "JpaExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ExpressionEvaluatingParameterSourceFactory factory = new ExpressionEvaluatingParameterSourceFactory(mock(BeanFactory.class));",
        "line": 163,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "getJpaExecutorForMessageAsParamSource",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "ExpressionEvaluatingParameterSourceFactory",
    "mockedClass": "ExpressionEvaluatingParameterSourceFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.core",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\core\\JpaExecutorTests.java",
      "className": "JpaExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ExpressionEvaluatingParameterSourceFactory factory = new ExpressionEvaluatingParameterSourceFactory(mock(BeanFactory.class));",
        "line": 178,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "getJpaExecutorForPayloadAsParamSource",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "jpaExecutor",
    "variableType": "JpaExecutor",
    "mockedClass": "JpaExecutor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.core",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\core\\JpaExecutorTests.java",
      "className": "JpaExecutorTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final JpaExecutor jpaExecutor = new JpaExecutor(mock(EntityManager.class));",
        "line": 245,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "withNullMaxResultsExpression",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "jpaExecutor",
    "variableType": "JpaExecutor",
    "mockedClass": "JpaExecutor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\inbound\\JpaPollingChannelAdapterUnitTests.java",
      "className": "JpaPollingChannelAdapterUnitTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "JpaExecutor jpaExecutor = mock(JpaExecutor.class);",
        "line": 38,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReceiveNull",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(jpaExecutor.poll()).thenReturn(null);",
        "line": 40,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReceiveNull",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "jpaExecutor",
    "variableType": "JpaExecutor",
    "mockedClass": "JpaExecutor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\inbound\\JpaPollingChannelAdapterUnitTests.java",
      "className": "JpaPollingChannelAdapterUnitTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "JpaExecutor jpaExecutor = mock(JpaExecutor.class);",
        "line": 48,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReceiveNotNull",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(jpaExecutor.poll()).thenReturn(\"Spring\");",
        "line": 50,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testReceiveNotNull",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "jpaExecutor",
    "variableType": "JpaExecutor",
    "mockedClass": "JpaExecutor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\inbound\\JpaPollingChannelAdapterUnitTests.java",
      "className": "JpaPollingChannelAdapterUnitTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "JpaExecutor jpaExecutor = mock(JpaExecutor.class);",
        "line": 59,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testGetComponentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "ExpressionEvaluatingParameterSourceFactory",
    "mockedClass": "ExpressionEvaluatingParameterSourceFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Declaration Attribute\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.jpa.support.parametersource",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-jpa\\src\\test\\java\\org\\springframework\\integration\\jpa\\support\\parametersource\\ExpressionEvaluatingParameterSourceFactoryTests.java",
      "className": "ExpressionEvaluatingParameterSourceFactoryTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private final ExpressionEvaluatingParameterSourceFactory factory = new ExpressionEvaluatingParameterSourceFactory(mock(BeanFactory.class));",
        "line": 42,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "pf",
    "variableType": "ProducerFactory<Integer,String>",
    "mockedClass": "ProducerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.config.xml",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\config\\xml\\KafkaOutboundAdapterParserTests.java",
      "className": "KafkaOutboundAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nProducerFactory<Integer, String> pf = mock(ProducerFactory.class);",
        "line": 113,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSyncMode",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.createProducer()).willReturn(mockProducer);",
        "line": 115,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSyncMode",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.getConfigurationProperties()).willReturn(props);",
        "line": 118,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSyncMode",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "template",
    "variableType": "KafkaTemplate",
    "mockedClass": "KafkaTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— Other Methods\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.config.xml",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\config\\xml\\KafkaOutboundGatewayParserTests.java",
      "className": "EMS"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "KafkaTemplate template = mock(KafkaTemplate.class);",
        "line": 95,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "template",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Bean"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(template.getProducerFactory()).willReturn(pf);",
        "line": 96,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "template",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Bean"
          ]
        }
      }
    ]
  },
  {
    "variableName": "pf",
    "variableType": "ProducerFactory",
    "mockedClass": "ProducerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— Other Methods\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.config.xml",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\config\\xml\\KafkaOutboundGatewayParserTests.java",
      "className": "EMS"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerFactory pf = mock(ProducerFactory.class);",
        "line": 92,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "template",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Bean"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.getConfigurationProperties()).willReturn(props);",
        "line": 94,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "template",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Bean"
          ]
        }
      }
    ]
  },
  {
    "variableName": "cf",
    "variableType": "ConsumerFactory<Integer,String>",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageDrivenAdapterTests.java",
      "className": "MessageDrivenAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory<Integer, String> cf = mock(ConsumerFactory.class);",
        "line": 580,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPauseResume",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(cf.createConsumer(eq(\"testPauseResumeGroup\"), eq(\"clientId\"), isNull(), any())).willReturn(consumer);",
        "line": 582,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPauseResume",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "Consumer<Integer,String>",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageDrivenAdapterTests.java",
      "className": "MessageDrivenAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer<Integer, String> consumer = mock(Consumer.class);",
        "line": 581,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPauseResume",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumer.poll(any(Duration.class))).willAnswer(i -> {\r\n    Thread.sleep(50);\r\n    return first.getAndSet(false) ? consumerRecords : emptyRecords;\r\n});",
        "line": 590,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPauseResume",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumer.assignment()).willReturn(records.keySet());",
        "line": 599,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPauseResume",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumer.paused()).willReturn(records.keySet());",
        "line": 600,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPauseResume",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(consumer, times(2)).commitSync(anyMap(), any());",
        "line": 621,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPauseResume",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory consumerFactory = mock(ConsumerFactory.class);",
        "line": 103,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIllegalArgs",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory consumerFactory = mock(ConsumerFactory.class);",
        "line": 121,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumerAwareRebalanceListener",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);",
        "line": 124,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumerAwareRebalanceListener",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "Consumer",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer consumer = mock(Consumer.class);",
        "line": 112,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumerAwareRebalanceListener",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory consumerFactory = mock(ConsumerFactory.class);",
        "line": 173,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRebalanceListener",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);",
        "line": 176,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRebalanceListener",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "Consumer",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer consumer = mock(Consumer.class);",
        "line": 162,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRebalanceListener",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).pause(new LinkedHashSet<>(assigned2));",
        "line": 215,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRebalanceListener",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any());",
        "line": 216,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRebalanceListener",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).pause(new LinkedHashSet<>(temp));",
        "line": 218,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRebalanceListener",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory consumerFactory = mock(ConsumerFactory.class);",
        "line": 276,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);",
        "line": 279,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "Consumer",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer consumer = mock(Consumer.class);",
        "line": 238,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5);",
        "line": 275,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));",
        "line": 323,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 324,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 326,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 328,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 330,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 332,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).pause(partitions.getAllValues().get(0));",
        "line": 333,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 334,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).resume(partitions.getAllValues().get(1));",
        "line": 335,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 336,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).close(any());",
        "line": 337,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckCommon",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "Consumer",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer consumer = mock(Consumer.class);",
        "line": 369,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5, cr6, cr7);",
        "line": 413,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));",
        "line": 446,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 447,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).paused();",
        "line": 448,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 449,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).paused();",
        "line": 450,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 451,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).paused();",
        "line": 452,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 453,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).paused();",
        "line": 454,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(3L)));",
        "line": 455,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(6L)));",
        "line": 456,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 457,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).close(any());",
        "line": 458,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory consumerFactory = mock(ConsumerFactory.class);",
        "line": 414,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);",
        "line": 417,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAckOutOfOrder",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory consumerFactory = mock(ConsumerFactory.class);",
        "line": 490,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);",
        "line": 493,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "Consumer",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer consumer = mock(Consumer.class);",
        "line": 465,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumer.poll(any(Duration.class))).willReturn(cr1, cr1, cr2, cr2, cr3);",
        "line": 489,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 518,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// rollback\r\ninOrder.verify(consumer).seek(topicPartition, 0L);",
        "line": 519,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 520,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)), Duration.ofSeconds(30));",
        "line": 521,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 523,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// rollback\r\ninOrder.verify(consumer).seek(topicPartition, 1L);",
        "line": 524,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 525,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)), Duration.ofSeconds(30));",
        "line": 526,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 528,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).close(any());",
        "line": 529,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNack",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory consumerFactory = mock(ConsumerFactory.class);",
        "line": 561,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);",
        "line": 564,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "log2",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log log2 = spy(KafkaTestUtils.getPropertyValue(ack2, \"logger.log\", Log.class));",
        "line": 579,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(log2.isWarnEnabled()).willReturn(true);",
        "line": 581,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(log2).isWarnEnabled();",
        "line": 606,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(log2).warn(captor.capture());",
        "line": 608,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "Consumer",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer consumer = mock(Consumer.class);",
        "line": 536,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr1, cr2, cr3);",
        "line": 560,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 596,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).paused();",
        "line": 597,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 598,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// rollback\r\ninOrder.verify(consumer).seek(topicPartition, 0L);",
        "line": 599,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 612,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));",
        "line": 613,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 614,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));",
        "line": 615,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 616,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).close(any());",
        "line": 617,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "log1",
    "variableType": "Log",
    "mockedClass": "Log",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Log log1 = spy(KafkaTestUtils.getPropertyValue(ack1, \"logger.log\", Log.class));",
        "line": 572,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(log1.isWarnEnabled()).willReturn(true);",
        "line": 574,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(log1).isWarnEnabled();",
        "line": 600,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(log1).warn(captor.capture());",
        "line": 602,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNackWithLaterInflight",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory consumerFactory = mock(ConsumerFactory.class);",
        "line": 665,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);",
        "line": 668,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "Consumer",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer consumer = mock(Consumer.class);",
        "line": 644,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumer.poll(Duration.of(20 * 5000, ChronoUnit.MILLIS))).willReturn(cr1, ConsumerRecords.EMPTY);",
        "line": 658,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumer.poll(Duration.of(5000, ChronoUnit.MILLIS))).willReturn(cr2, ConsumerRecords.EMPTY);",
        "line": 664,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));",
        "line": 693,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// assignTimeout used on initial poll (before partition assigned)\r\ninOrder.verify(consumer).poll(Duration.of(20 * 5000, ChronoUnit.MILLIS));",
        "line": 695,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));",
        "line": 696,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// pollTimeout used on subsequent polls\r\ninOrder.verify(consumer).poll(Duration.of(5000, ChronoUnit.MILLIS));",
        "line": 698,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));",
        "line": 699,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// assignTimeout used after partitions revoked\r\ninOrder.verify(consumer).poll(Duration.of(20 * 5000, ChronoUnit.MILLIS));",
        "line": 701,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPollTimeouts",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory consumerFactory = mock(ConsumerFactory.class);",
        "line": 731,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);",
        "line": 734,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "Consumer",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer consumer = mock(Consumer.class);",
        "line": 707,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2);",
        "line": 730,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));",
        "line": 762,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 763,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));",
        "line": 764,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));",
        "line": 765,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(3L)));",
        "line": 766,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(4L)));",
        "line": 767,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 768,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).close(any());",
        "line": 769,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAllowMulti",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory<String,String>",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory<String, String> consumerFactory = mock(ConsumerFactory.class);",
        "line": 788,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTopicPatternBasedMessageSource",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);",
        "line": 791,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTopicPatternBasedMessageSource",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumer",
    "variableType": "MockConsumer<String,String>",
    "mockedClass": "MockConsumer<String,String>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MockConsumer<String, String> consumer = spy(new MockConsumer<>(OffsetResetStrategy.EARLIEST));",
        "line": 837,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).assign(anyCollection());",
        "line": 934,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).seekToBeginning(anyCollection());",
        "line": 935,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer, times(2)).seekToEnd(anyCollection());",
        "line": 936,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).position(negativeRelativeToCurrent);",
        "line": 937,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).seek(negativeRelativeToCurrent, 2L);",
        "line": 938,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).position(positiveRelativeToCurrent);",
        "line": 939,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).seek(positiveRelativeToCurrent, 2L);",
        "line": 940,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 941,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 942,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).pause(anyCollection());",
        "line": 943,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 944,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).resume(anyCollection());",
        "line": 945,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).poll(any(Duration.class));",
        "line": 946,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(consumer).close(any());",
        "line": 947,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "consumerFactory",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\inbound\\MessageSourceTests.java",
      "className": "MessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory consumerFactory = mock(ConsumerFactory.class);",
        "line": 860,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);",
        "line": 863,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStaticPartitionAssignment",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "pf",
    "variableType": "ProducerFactory",
    "mockedClass": "ProducerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerFactory pf = mock(ProducerFactory.class);",
        "line": 357,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "immediateFailure",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.createProducer()).willReturn(producer);",
        "line": 358,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "immediateFailure",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "producer",
    "variableType": "Producer",
    "mockedClass": "Producer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Producer producer = mock(Producer.class);",
        "line": 352,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "immediateFailure",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(producer.send(any(), any())).willReturn(cf);",
        "line": 356,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "immediateFailure",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "pf",
    "variableType": "ProducerFactory",
    "mockedClass": "ProducerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerFactory pf = mock(ProducerFactory.class);",
        "line": 506,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.transactionCapable()).willReturn(true);",
        "line": 507,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.createProducer(isNull())).willReturn(producer);",
        "line": 509,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "producer",
    "variableType": "Producer",
    "mockedClass": "Producer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Producer producer = mock(Producer.class);",
        "line": 508,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).beginTransaction();",
        "line": 520,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));",
        "line": 521,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).commitTransaction();",
        "line": 522,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "cf",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory cf = mock(ConsumerFactory.class);",
        "line": 549,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockConsumer",
    "variableType": "Consumer",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer mockConsumer = mock(Consumer.class);",
        "line": 528,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(mockConsumer.groupMetadata()).willReturn(meta);",
        "line": 548,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "pf",
    "variableType": "ProducerFactory",
    "mockedClass": "ProducerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerFactory pf = mock(ProducerFactory.class);",
        "line": 558,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.transactionCapable()).willReturn(true);",
        "line": 559,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(pf, times(2)).createProducer(isNull());",
        "line": 594,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "producer",
    "variableType": "Producer",
    "mockedClass": "Producer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Producer producer = mock(Producer.class);",
        "line": 551,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(producer.send(any(), any())).willReturn(mock(Future.class));",
        "line": 552,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).beginTransaction();",
        "line": 580,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(0)), meta);",
        "line": 581,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).commitTransaction();",
        "line": 583,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).close(any());",
        "line": 584,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).beginTransaction();",
        "line": 585,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).send(captor.capture(), any(Callback.class));",
        "line": 587,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1)), meta);",
        "line": 589,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).commitTransaction();",
        "line": 591,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).close(any());",
        "line": 592,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verifyNoMoreInteractions(producer);",
        "line": 595,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransaction",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "producer",
    "variableType": "Producer",
    "mockedClass": "Producer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Producer producer = mock(Producer.class);",
        "line": 601,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).beginTransaction();",
        "line": 624,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));",
        "line": 625,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).commitTransaction();",
        "line": 626,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "pf",
    "variableType": "ProducerFactory",
    "mockedClass": "ProducerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerFactory pf = mock(ProducerFactory.class);",
        "line": 634,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionSynch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.transactionCapable()).willReturn(true);",
        "line": 635,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionSynch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.createProducer(isNull())).willReturn(producer);",
        "line": 636,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionSynch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "producer",
    "variableType": "Producer",
    "mockedClass": "Producer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Producer producer = mock(Producer.class);",
        "line": 633,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionSynch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(producer).beginTransaction();",
        "line": 653,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionSynch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(producer).send(any(ProducerRecord.class), any(Callback.class));",
        "line": 654,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionSynch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(producer).abortTransaction();",
        "line": 655,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionSynch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(producer).close(any());",
        "line": 656,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionSynch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verifyNoMoreInteractions(producer);",
        "line": 657,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTransactionSynch",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "cf",
    "variableType": "ConsumerFactory",
    "mockedClass": "ConsumerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ConsumerFactory cf = mock(ConsumerFactory.class);",
        "line": 684,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockConsumer",
    "variableType": "Consumer",
    "mockedClass": "Consumer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Consumer mockConsumer = mock(Consumer.class);",
        "line": 663,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(mockConsumer.groupMetadata()).willReturn(meta);",
        "line": 683,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "producer",
    "variableType": "Producer",
    "mockedClass": "Producer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Producer producer = mock(Producer.class);",
        "line": 686,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(producer.send(any(), any())).willReturn(mock(Future.class));",
        "line": 687,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).beginTransaction();",
        "line": 725,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(0)), meta);",
        "line": 726,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).commitTransaction();",
        "line": 728,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).close(any());",
        "line": 729,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).beginTransaction();",
        "line": 730,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).send(captor.capture(), any(Callback.class));",
        "line": 732,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1)), meta);",
        "line": 734,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).commitTransaction();",
        "line": 736,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).close(any());",
        "line": 737,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verifyNoMoreInteractions(producer);",
        "line": 739,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testConsumeAndProduceTransactionTxIdOverride",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "template",
    "variableType": "KafkaTemplate<String,String>",
    "mockedClass": "KafkaTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "KafkaTemplate<String, String> template = mock(KafkaTemplate.class);",
        "line": 746,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTxNonTx",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(template.isTransactional()).willReturn(true);",
        "line": 747,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTxNonTx",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(template.inTransaction()).willReturn(false);",
        "line": 748,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTxNonTx",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(template.isAllowNonTransactional()).willReturn(true);",
        "line": 749,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTxNonTx",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(template.getProducerFactory()).willReturn(mock(ProducerFactory.class));",
        "line": 750,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTxNonTx",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(template, never()).executeInTransaction(any());",
        "line": 754,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTxNonTx",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(template).send(any(ProducerRecord.class));",
        "line": 755,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTxNonTx",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "pf",
    "variableType": "ProducerFactory",
    "mockedClass": "ProducerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerFactory pf = mock(ProducerFactory.class);",
        "line": 761,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFlush",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.createProducer()).willReturn(producer);",
        "line": 763,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFlush",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "producer",
    "variableType": "Producer",
    "mockedClass": "Producer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Producer producer = mock(Producer.class);",
        "line": 762,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFlush",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).send(captor.capture(), any(Callback.class));",
        "line": 775,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFlush",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).flush();",
        "line": 776,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testFlush",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "pf",
    "variableType": "ProducerFactory",
    "mockedClass": "ProducerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerFactory pf = mock(ProducerFactory.class);",
        "line": 784,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoFlush",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.createProducer()).willReturn(producer);",
        "line": 786,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoFlush",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "producer",
    "variableType": "Producer",
    "mockedClass": "Producer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Producer producer = mock(Producer.class);",
        "line": 785,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoFlush",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));",
        "line": 796,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoFlush",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "inOrder.verify(producer, never()).flush();",
        "line": 797,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoFlush",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "creator",
    "variableType": "ProducerRecordCreator",
    "mockedClass": "ProducerRecordCreator",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerRecordCreator creator = mock(ProducerRecordCreator.class);",
        "line": 816,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(creator.create(any(), any(), any(), any(), any(), any(), any())).willReturn(recordFromCreator);",
        "line": 818,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "recordFromCreator",
    "variableType": "ProducerRecord",
    "mockedClass": "ProducerRecord",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerRecord recordFromCreator = mock(ProducerRecord.class);",
        "line": 817,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "pf",
    "variableType": "ProducerFactory",
    "mockedClass": "ProducerFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerFactory pf = mock(ProducerFactory.class);",
        "line": 804,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(pf.createProducer()).willReturn(producer);",
        "line": 806,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "converter",
    "variableType": "RecordMessageConverter",
    "mockedClass": "RecordMessageConverter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "RecordMessageConverter converter = mock(RecordMessageConverter.class);",
        "line": 809,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(converter.fromMessage(any(), any())).willReturn(recordFromConverter);",
        "line": 811,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "recordFromConverter",
    "variableType": "ProducerRecord",
    "mockedClass": "ProducerRecord",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ProducerRecord recordFromConverter = mock(ProducerRecord.class);",
        "line": 810,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "producer",
    "variableType": "Producer",
    "mockedClass": "Producer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.kafka.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-kafka\\src\\test\\java\\org\\springframework\\integration\\kafka\\outbound\\KafkaProducerMessageHandlerTests.java",
      "className": "KafkaProducerMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Producer producer = mock(Producer.class);",
        "line": 805,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(producer).send(captor.capture(), any(Callback.class));",
        "line": 824,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(producer, times(2)).send(captor.capture(), any(Callback.class));",
        "line": 828,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "conversion",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\config\\ImapIdleIntegrationTests.java",
      "className": "ImapIdleIntegrationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 75,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithTransactionSynchronization",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(folder.isOpen()).thenReturn(true);",
        "line": 76,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithTransactionSynchronization",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "ImapMailReceiver",
    "mockedClass": "ImapMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\config\\ImapIdleIntegrationTests.java",
      "className": "ImapIdleIntegrationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ImapMailReceiver receiver = TestUtils.getPropertyValue(adapter, \"mailReceiver\", ImapMailReceiver.class);",
        "line": 57,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithTransactionSynchronization",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "// setup mock scenario\r\nreceiver = spy(receiver);",
        "line": 60,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithTransactionSynchronization",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "m1",
    "variableType": "Message",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\config\\ImapIdleIntegrationTests.java",
      "className": "ImapIdleIntegrationTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Message m1 = mock(Message.class);",
        "line": 72,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithTransactionSynchronization",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "ClassPathXmlApplicationContext",
    "mockedClass": "ClassPathXmlApplicationContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\config\\MailToStringTransformerParserTests.java",
      "className": "MailToStringTransformerParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "try (ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"mailToStringTransformerParserTests.xml\", getClass())) {\r\n    MessageChannel input = new BeanFactoryChannelResolver(context).resolveDestination(\"input\");\r\n    PollableChannel output = (PollableChannel) new BeanFactoryChannelResolver(context).resolveDestination(\"output\");\r\n    MimeMessage mimeMessage = Mockito.mock(MimeMessage.class);\r\n    Mockito.when(mimeMessage.getContent()).thenReturn(\"hello\");\r\n    input.send(new GenericMessage<jakarta.mail.Message>(mimeMessage));\r\n    Message<?> result = output.receive(10_000);\r\n    assertThat(result).isNotNull();\r\n    assertThat(result.getPayload()).isEqualTo(\"hello\");\r\n    Mockito.verify(mimeMessage).getContent();\r\n}",
        "line": 43,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "topLevelTransformer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mimeMessage",
    "variableType": "MimeMessage",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\config\\MailToStringTransformerParserTests.java",
      "className": "MailToStringTransformerParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MimeMessage mimeMessage = Mockito.mock(MimeMessage.class);",
        "line": 49,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "topLevelTransformer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(mimeMessage.getContent()).thenReturn(\"hello\");",
        "line": 50,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "topLevelTransformer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(mimeMessage).getContent();",
        "line": 55,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "topLevelTransformer",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "ClassPathXmlApplicationContext",
    "mockedClass": "ClassPathXmlApplicationContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\config\\MailToStringTransformerParserTests.java",
      "className": "MailToStringTransformerParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "try (ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"mailToStringTransformerWithinChain.xml\", getClass())) {\r\n    MessageChannel input = new BeanFactoryChannelResolver(context).resolveDestination(\"input\");\r\n    PollableChannel output = (PollableChannel) new BeanFactoryChannelResolver(context).resolveDestination(\"output\");\r\n    MimeMessage mimeMessage = Mockito.mock(MimeMessage.class);\r\n    Mockito.when(mimeMessage.getContent()).thenReturn(\"foo\");\r\n    input.send(new GenericMessage<jakarta.mail.Message>(mimeMessage));\r\n    Message<?> result = output.receive(0);\r\n    assertThat(result).isNotNull();\r\n    assertThat(result.getPayload()).isEqualTo(\"FOO!!!\");\r\n    Mockito.verify(mimeMessage).getContent();\r\n}",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transformerWithinChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mimeMessage",
    "variableType": "MimeMessage",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\config\\MailToStringTransformerParserTests.java",
      "className": "MailToStringTransformerParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MimeMessage mimeMessage = Mockito.mock(MimeMessage.class);",
        "line": 67,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transformerWithinChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(mimeMessage.getContent()).thenReturn(\"foo\");",
        "line": 68,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transformerWithinChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(mimeMessage).getContent();",
        "line": 73,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "transformerWithinChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sender",
    "variableType": "JavaMailSender",
    "mockedClass": "JavaMailSender",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\config\\MessageWithContentTypeTests.java",
      "className": "MessageWithContentTypeTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "JavaMailSender sender = mock(JavaMailSender.class);",
        "line": 70,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageConversionWithHtmlAndContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "// MOCKS\r\nwhen(sender.createMimeMessage()).thenReturn(mMessage);",
        "line": 82,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageConversionWithHtmlAndContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(sender, times(1)).send(Mockito.any(MimeMessage.class));",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageConversionWithHtmlAndContentType",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— Other Methods\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 318,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "receiveAndMarkAsReadDontDeleteGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 319,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "receiveAndMarkAsReadDontDeleteGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 320,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "receiveAndMarkAsReadDontDeleteGuts",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "msg2",
    "variableType": "Message",
    "mockedClass": "Message",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Message msg2 = spy(GreenMailUtil.newMimeMessage(\"test2\"));",
        "line": 361,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndMarkAsReadDontDeleteFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "// should not be marked seen\r\ngiven(msg2.getSubject()).willReturn(\"foo\");",
        "line": 362,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndMarkAsReadDontDeleteFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "msg2",
    "variableType": "Message",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Message msg2 = mock(MimeMessage.class);",
        "line": 381,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(msg2, never()).isExpunged();",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(msg2, never()).getSubject();",
        "line": 389,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "msg1",
    "variableType": "Message",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Message msg1 = mock(MimeMessage.class);",
        "line": 380,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(msg1, never()).isExpunged();",
        "line": 386,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(msg1, never()).getSubject();",
        "line": 388,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(receiver, \"logger\", LogAccessor.class));",
        "line": 376,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isDebugEnabled()).thenReturn(false);",
        "line": 378,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, times(2)).isDebugEnabled();",
        "line": 385,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, never()).debug(Mockito.startsWith(\"Expunged message received\"));",
        "line": 390,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, never()).debug(org.mockito.ArgumentMatchers.contains(\"will be discarded by the matching filter\"));",
        "line": 391,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDebugIsDisabledNotLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "msg2",
    "variableType": "Message",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Message msg2 = mock(MimeMessage.class);",
        "line": 403,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(msg2.getSubject()).willReturn(\"msg2\");",
        "line": 406,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(msg2).isExpunged();",
        "line": 412,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(msg2).getSubject();",
        "line": 414,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "msg1",
    "variableType": "Message",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Message msg1 = mock(MimeMessage.class);",
        "line": 402,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(msg1.isExpunged()).willReturn(true);",
        "line": 404,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(msg1.getSubject()).willReturn(\"msg1\");",
        "line": 405,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(msg1).isExpunged();",
        "line": 411,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(msg1, never()).getSubject();",
        "line": 413,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(receiver, \"logger\", LogAccessor.class));",
        "line": 398,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(logger.isDebugEnabled()).thenReturn(true);",
        "line": 400,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, times(2)).isDebugEnabled();",
        "line": 410,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).debug(Mockito.startsWith(\"Expunged message discarded\"));",
        "line": 415,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).debug(org.mockito.ArgumentMatchers.contains(\"'msg2' will be discarded by the matching filter\"));",
        "line": 416,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveExpungedAndNotExpungedLogFiltered",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 431,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMarkAsReadAndDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 432,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMarkAsReadAndDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 433,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMarkAsReadAndDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "AbstractMailReceiver",
    "mockedClass": "AbstractMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractMailReceiver receiver = new ImapMailReceiver();",
        "line": 422,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMarkAsReadAndDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "receiver = spy(receiver);",
        "line": 425,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMarkAsReadAndDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(receiver, times(2)).deleteMessages(Mockito.any());",
        "line": 456,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveMarkAsReadAndDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 469,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontMarkAsRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 470,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontMarkAsRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 471,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontMarkAsRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "AbstractMailReceiver",
    "mockedClass": "AbstractMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractMailReceiver receiver = new ImapMailReceiver();",
        "line": 461,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontMarkAsRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "receiver = spy(receiver);",
        "line": 463,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontMarkAsRead",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 500,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontMarkAsReadButDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 501,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontMarkAsReadButDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 502,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontMarkAsReadButDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "AbstractMailReceiver",
    "mockedClass": "AbstractMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractMailReceiver receiver = new ImapMailReceiver();",
        "line": 491,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontMarkAsReadButDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "receiver = spy(receiver);",
        "line": 494,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontMarkAsReadButDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 538,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndIgnoreMarkAsReadDontDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 539,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndIgnoreMarkAsReadDontDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 540,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndIgnoreMarkAsReadDontDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "AbstractMailReceiver",
    "mockedClass": "AbstractMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractMailReceiver receiver = new ImapMailReceiver();",
        "line": 531,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndIgnoreMarkAsReadDontDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "receiver = spy(receiver);",
        "line": 532,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndIgnoreMarkAsReadDontDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(receiver, times(0)).deleteMessages(Mockito.any());",
        "line": 561,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndIgnoreMarkAsReadDontDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "IMAPFolder",
    "mockedClass": "IMAPFolder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "IMAPFolder folder = mock(IMAPFolder.class);",
        "line": 580,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistory",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 581,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistory",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.hasNewMessages()).willReturn(true);",
        "line": 582,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistory",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 583,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistory",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "AbstractMailReceiver",
    "mockedClass": "AbstractMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractMailReceiver receiver = new ImapMailReceiver();",
        "line": 569,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistory",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "receiver = spy(receiver);",
        "line": 570,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistory",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "IMAPFolder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(IMAPFolder.class);",
        "line": 633,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleChannelAdapterException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 634,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleChannelAdapterException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 635,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleChannelAdapterException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.exists()).willReturn(true);",
        "line": 636,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleChannelAdapterException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "store",
    "variableType": "Store",
    "mockedClass": "Store",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Store store = mock(Store.class);",
        "line": 641,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleChannelAdapterException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(store.isConnected()).willReturn(true);",
        "line": 642,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleChannelAdapterException",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "IMAPFolder",
    "mockedClass": "IMAPFolder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final IMAPFolder folder = mock(IMAPFolder.class);",
        "line": 673,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoInitialIdleDelayWhenRecentNotSupported",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 674,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoInitialIdleDelayWhenRecentNotSupported",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(false).willReturn(true);",
        "line": 675,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoInitialIdleDelayWhenRecentNotSupported",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.exists()).willReturn(true);",
        "line": 676,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoInitialIdleDelayWhenRecentNotSupported",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "store",
    "variableType": "Store",
    "mockedClass": "Store",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Store store = mock(Store.class);",
        "line": 680,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoInitialIdleDelayWhenRecentNotSupported",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(store.isConnected()).willReturn(true);",
        "line": 681,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoInitialIdleDelayWhenRecentNotSupported",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);",
        "line": 682,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoInitialIdleDelayWhenRecentNotSupported",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "IMAPFolder",
    "mockedClass": "IMAPFolder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "IMAPFolder folder = mock(IMAPFolder.class);",
        "line": 742,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInitialIdleDelayWhenRecentIsSupported",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.RECENT));",
        "line": 743,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInitialIdleDelayWhenRecentIsSupported",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(false).willReturn(true);",
        "line": 744,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInitialIdleDelayWhenRecentIsSupported",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.exists()).willReturn(true);",
        "line": 745,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInitialIdleDelayWhenRecentIsSupported",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "store",
    "variableType": "Store",
    "mockedClass": "Store",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Store store = mock(Store.class);",
        "line": 749,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInitialIdleDelayWhenRecentIsSupported",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(store.isConnected()).willReturn(true);",
        "line": 750,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInitialIdleDelayWhenRecentIsSupported",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);",
        "line": 751,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInitialIdleDelayWhenRecentIsSupported",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 810,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testImapLifecycleForRaceCondition",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.exists()).willReturn(true);",
        "line": 811,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testImapLifecycleForRaceCondition",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 812,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testImapLifecycleForRaceCondition",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.search(Mockito.any())).willReturn(new Message[] {});",
        "line": 813,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testImapLifecycleForRaceCondition",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 815,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testImapLifecycleForRaceCondition",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "i",
    "variableType": "int",
    "mockedClass": "int",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "for (int i = 0; i < 100; i++) {\r\n    final ImapMailReceiver receiver = new ImapMailReceiver(\"imap://foo\");\r\n    Store store = mock(Store.class);\r\n    Folder folder = mock(Folder.class);\r\n    given(folder.exists()).willReturn(true);\r\n    given(folder.isOpen()).willReturn(true);\r\n    given(folder.search(Mockito.any())).willReturn(new Message[] {});\r\n    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);\r\n    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));\r\n    DirectFieldAccessor df = new DirectFieldAccessor(receiver);\r\n    df.setPropertyValue(\"store\", store);\r\n    receiver.setBeanFactory(mock(BeanFactory.class));\r\n    receiver.afterPropertiesSet();\r\n    new Thread(() -> {\r\n        try {\r\n            receiver.receive();\r\n        } catch (jakarta.mail.MessagingException e) {\r\n            if (e.getCause() instanceof NullPointerException) {\r\n                failed.getAndIncrement();\r\n            }\r\n        }\r\n    }).start();\r\n    new Thread(() -> {\r\n        try {\r\n            receiver.destroy();\r\n        } catch (Exception ignore) {\r\n            // ignore\r\n        }\r\n    }).start();\r\n}",
        "line": 807,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testImapLifecycleForRaceCondition",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "store",
    "variableType": "Store",
    "mockedClass": "Store",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Store store = mock(Store.class);",
        "line": 809,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testImapLifecycleForRaceCondition",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);",
        "line": 814,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testImapLifecycleForRaceCondition",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 890,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAttachmentsGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.exists()).willReturn(true);",
        "line": 891,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAttachmentsGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 892,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAttachmentsGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.search(Mockito.any())).willReturn(new Message[] { message });",
        "line": 895,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAttachmentsGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 897,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAttachmentsGuts",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "store",
    "variableType": "Store",
    "mockedClass": "Store",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Store store = mock(Store.class);",
        "line": 889,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAttachmentsGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);",
        "line": 896,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAttachmentsGuts",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— @Override\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 923,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getFolder",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 924,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getFolder",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getMessages()).willReturn(!this.firstDone ? messages1 : messages2);",
        "line": 926,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getFolder",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "searchTermStrategy",
    "variableType": "SearchTermStrategy",
    "mockedClass": "SearchTermStrategy",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final SearchTermStrategy searchTermStrategy = mock(SearchTermStrategy.class);",
        "line": 912,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNullMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "IMAPFolder",
    "mockedClass": "IMAPFolder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "IMAPFolder folder = mock(IMAPFolder.class);",
        "line": 957,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));",
        "line": 958,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(false).willReturn(true);",
        "line": 959,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.exists()).willReturn(true);",
        "line": 960,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.hasNewMessages()).willReturn(true);",
        "line": 961,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "ImapMailReceiver",
    "mockedClass": "ImapMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ImapMailReceiver receiver = spy(new ImapMailReceiver(\"imap:foo\"));",
        "line": 954,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, \"logger\", LogAccessor.class));",
        "line": 970,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "store",
    "variableType": "Store",
    "mockedClass": "Store",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Store store = mock(Store.class);",
        "line": 964,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(store.isConnected()).willReturn(false);",
        "line": 965,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);",
        "line": 966,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(store, atLeast(3)).connect();",
        "line": 983,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testIdleReconnects",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "bf",
    "variableType": "BeanFactory",
    "mockedClass": "BeanFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BeanFactory bf = mock(BeanFactory.class);",
        "line": 991,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "setUpScheduler",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(bf.containsBean(\"taskScheduler\")).willReturn(true);",
        "line": 992,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "setUpScheduler",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(bf.getBean(\"taskScheduler\", TaskScheduler.class)).willReturn(taskScheduler);",
        "line": 993,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "setUpScheduler",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "msg1",
    "variableType": "MimeMessage",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "ImapMailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MimeMessage msg1 = spy(GreenMailUtil.newMimeMessage(\"test1\"));",
        "line": 1000,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndMarkAsReadDontDeleteWithThrowingWhenCopying",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(msg1, times(0)).setFlags(Mockito.any(), Mockito.anyBoolean());",
        "line": 1012,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndMarkAsReadDontDeleteWithThrowingWhenCopying",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// msg2 is marked with the user and seen flags\r\nverify(msg1, times(2)).setFlags(Mockito.any(), Mockito.anyBoolean());",
        "line": 1018,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndMarkAsReadDontDeleteWithThrowingWhenCopying",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— @Override\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "TestReceiver"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 923,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getFolder",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.isOpen()).willReturn(true);",
        "line": 924,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getFolder",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(folder.getMessages()).willReturn(!this.firstDone ? messages1 : messages2);",
        "line": 926,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getFolder",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "firstDone",
    "variableType": "boolean",
    "mockedClass": "boolean",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Declaration Attribute\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "TestReceiver"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "class TestReceiver extends ImapMailReceiver {\r\n\r\n    private boolean firstDone;\r\n\r\n    private TestReceiver() {\r\n        setSearchTermStrategy(searchTermStrategy);\r\n    }\r\n\r\n    @Override\r\n    protected Folder getFolder() {\r\n        Folder folder = mock(Folder.class);\r\n        given(folder.isOpen()).willReturn(true);\r\n        try {\r\n            given(folder.getMessages()).willReturn(!this.firstDone ? messages1 : messages2);\r\n        } catch (MessagingException ignored) {\r\n        }\r\n        return folder;\r\n    }\r\n\r\n    @Override\r\n    public Message[] receive() throws MessagingException {\r\n        Message[] messages = searchForNewMessages();\r\n        this.firstDone = true;\r\n        return messages;\r\n    }\r\n}",
        "line": 915,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "firstDone",
    "variableType": "boolean",
    "mockedClass": "boolean",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Declaration Attribute\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "TestReceiver"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "class TestReceiver extends ImapMailReceiver {\r\n\r\n    private boolean firstDone;\r\n\r\n    private TestReceiver() {\r\n        setSearchTermStrategy(searchTermStrategy);\r\n    }\r\n\r\n    @Override\r\n    protected Folder getFolder() {\r\n        Folder folder = mock(Folder.class);\r\n        given(folder.isOpen()).willReturn(true);\r\n        try {\r\n            given(folder.getMessages()).willReturn(!this.firstDone ? messages1 : messages2);\r\n        } catch (MessagingException ignored) {\r\n        }\r\n        return folder;\r\n    }\r\n\r\n    @Override\r\n    public Message[] receive() throws MessagingException {\r\n        Message[] messages = searchForNewMessages();\r\n        this.firstDone = true;\r\n        return messages;\r\n    }\r\n}",
        "line": 915,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "firstDone",
    "variableType": "boolean",
    "mockedClass": "boolean",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Declaration Attribute\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailReceiverTests.java",
      "className": "TestReceiver"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "class TestReceiver extends ImapMailReceiver {\r\n\r\n    private boolean firstDone;\r\n\r\n    private TestReceiver() {\r\n        setSearchTermStrategy(searchTermStrategy);\r\n    }\r\n\r\n    @Override\r\n    protected Folder getFolder() {\r\n        Folder folder = mock(Folder.class);\r\n        given(folder.isOpen()).willReturn(true);\r\n        try {\r\n            given(folder.getMessages()).willReturn(!this.firstDone ? messages1 : messages2);\r\n        } catch (MessagingException ignored) {\r\n        }\r\n        return folder;\r\n    }\r\n\r\n    @Override\r\n    public Message[] receive() throws MessagingException {\r\n        Message[] messages = searchForNewMessages();\r\n        this.firstDone = true;\r\n        return messages;\r\n    }\r\n}",
        "line": 915,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— Other Methods\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailSearchTermsTests.java",
      "className": "ImapMailSearchTermsTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 69,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "validateSearchTermsWhenShouldMarkAsReadNoExistingFlagsGuts",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));",
        "line": 70,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "validateSearchTermsWhenShouldMarkAsReadNoExistingFlagsGuts",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailSearchTermsTests.java",
      "className": "ImapMailSearchTermsTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSearchTermsWhenShouldMarkAsReadWithExistingFlags",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSearchTermsWhenShouldMarkAsReadWithExistingFlags",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\ImapMailSearchTermsTests.java",
      "className": "ImapMailSearchTermsTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSearchTermsWhenShouldNotMarkAsReadNoExistingFlags",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));",
        "line": 124,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSearchTermsWhenShouldNotMarkAsReadNoExistingFlags",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\MailReceiverTests.java",
      "className": "MailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 68,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoreConnectAndFolderCloseWhenNoMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(folder.exists()).thenReturn(true);",
        "line": 69,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoreConnectAndFolderCloseWhenNoMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(folder.isOpen()).thenReturn(false, true);",
        "line": 70,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoreConnectAndFolderCloseWhenNoMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(folder).close(anyBoolean());",
        "line": 80,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoreConnectAndFolderCloseWhenNoMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "store",
    "variableType": "Store",
    "mockedClass": "Store",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\MailReceiverTests.java",
      "className": "MailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Store store = session.getStore(\"imap\");",
        "line": 64,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoreConnectAndFolderCloseWhenNoMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "store = spy(store);",
        "line": 65,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoreConnectAndFolderCloseWhenNoMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(store.isConnected()).thenReturn(false);",
        "line": 67,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoreConnectAndFolderCloseWhenNoMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(store, times(2)).connect();",
        "line": 75,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStoreConnectAndFolderCloseWhenNoMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "message4",
    "variableType": "MimeMessage",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\MailReceivingMessageSourceTests.java",
      "className": "MailReceivingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MimeMessage message4 = Mockito.mock(MimeMessage.class);",
        "line": 43,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPolling",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "message3",
    "variableType": "MimeMessage",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\MailReceivingMessageSourceTests.java",
      "className": "MailReceivingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MimeMessage message3 = Mockito.mock(MimeMessage.class);",
        "line": 42,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPolling",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "message2",
    "variableType": "MimeMessage",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\MailReceivingMessageSourceTests.java",
      "className": "MailReceivingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MimeMessage message2 = Mockito.mock(MimeMessage.class);",
        "line": 41,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPolling",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "message1",
    "variableType": "MimeMessage",
    "mockedClass": "MimeMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\MailReceivingMessageSourceTests.java",
      "className": "MailReceivingMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MimeMessage message1 = Mockito.mock(MimeMessage.class);",
        "line": 40,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPolling",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\Pop3MailReceiverTests.java",
      "className": "Pop3MailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 55,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));",
        "line": 56,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "AbstractMailReceiver",
    "mockedClass": "AbstractMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\Pop3MailReceiverTests.java",
      "className": "Pop3MailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractMailReceiver receiver = new Pop3MailReceiver();",
        "line": 47,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "receiver = spy(receiver);",
        "line": 49,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\Pop3MailReceiverTests.java",
      "className": "Pop3MailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 91,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "AbstractMailReceiver",
    "mockedClass": "AbstractMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\Pop3MailReceiverTests.java",
      "className": "Pop3MailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractMailReceiver receiver = new Pop3MailReceiver();",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "receiver = spy(receiver);",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontDelete",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\Pop3MailReceiverTests.java",
      "className": "Pop3MailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 119,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontSetDeleteWithUrl",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));",
        "line": 120,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontSetDeleteWithUrl",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "AbstractMailReceiver",
    "mockedClass": "AbstractMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\Pop3MailReceiverTests.java",
      "className": "Pop3MailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractMailReceiver receiver = new Pop3MailReceiver(\"pop3://some.host\");",
        "line": 112,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontSetDeleteWithUrl",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "receiver = spy(receiver);",
        "line": 113,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontSetDeleteWithUrl",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "folder",
    "variableType": "Folder",
    "mockedClass": "Folder",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\Pop3MailReceiverTests.java",
      "className": "Pop3MailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Folder folder = mock(Folder.class);",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontSetDeleteWithoutUrl",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));",
        "line": 148,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontSetDeleteWithoutUrl",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "receiver",
    "variableType": "AbstractMailReceiver",
    "mockedClass": "AbstractMailReceiver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mail",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mail\\src\\test\\java\\org\\springframework\\integration\\mail\\Pop3MailReceiverTests.java",
      "className": "Pop3MailReceiverTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractMailReceiver receiver = new Pop3MailReceiver();",
        "line": 140,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontSetDeleteWithoutUrl",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "receiver = spy(receiver);",
        "line": 141,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "receiveAndDontSetDeleteWithoutUrl",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "converter",
    "variableType": "MappingMongoConverter",
    "mockedClass": "MappingMongoConverter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mongodb.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mongodb\\src\\test\\java\\org\\springframework\\integration\\mongodb\\inbound\\MongoDbMessageSourceTests.java",
      "className": "MongoDbMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MappingMongoConverter converter = new TestMongoConverter(MONGO_DATABASE_FACTORY, new MongoMappingContext());",
        "line": 227,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulQueryWithCustomConverter",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "converter = spy(converter);",
        "line": 230,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulQueryWithCustomConverter",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(converter, times(3)).read((Class<Person>) Mockito.any(), Mockito.any(Bson.class));",
        "line": 236,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulQueryWithCustomConverter",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "converter",
    "variableType": "MappingMongoConverter",
    "mockedClass": "MappingMongoConverter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mongodb.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mongodb\\src\\test\\java\\org\\springframework\\integration\\mongodb\\inbound\\MongoDbMessageSourceTests.java",
      "className": "MongoDbMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MappingMongoConverter converter = new TestMongoConverter(MONGO_DATABASE_FACTORY, new MongoMappingContext());",
        "line": 243,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulQueryWithMongoTemplateAndUpdate",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "converter = spy(converter);",
        "line": 245,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulQueryWithMongoTemplateAndUpdate",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(converter, times(3)).read((Class<Person>) Mockito.any(), Mockito.any(Bson.class));",
        "line": 261,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulQueryWithMongoTemplateAndUpdate",
          "methodAnnotations": [
            "@SuppressWarnings",
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "converter",
    "variableType": "MappingMongoConverter",
    "mockedClass": "MappingMongoConverter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mongodb.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mongodb\\src\\test\\java\\org\\springframework\\integration\\mongodb\\inbound\\ReactiveMongoDbMessageSourceTests.java",
      "className": "ReactiveMongoDbMessageSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MappingMongoConverter converter = new ReactiveTestMongoConverter(REACTIVE_MONGO_DATABASE_FACTORY, new MongoMappingContext());",
        "line": 168,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulQueryWithCustomConverter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "converter = spy(converter);",
        "line": 172,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulQueryWithCustomConverter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(converter, times(3)).read((Class<Person>) Mockito.any(), Mockito.any(Bson.class));",
        "line": 177,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateSuccessfulQueryWithCustomConverter",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "converter",
    "variableType": "MappingMongoConverter",
    "mockedClass": "MappingMongoConverter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mongodb.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mongodb\\src\\test\\java\\org\\springframework\\integration\\mongodb\\outbound\\MongoDbStoringMessageHandlerTests.java",
      "className": "MongoDbStoringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MappingMongoConverter converter = new TestMongoConverter(MONGO_DATABASE_FACTORY, new MongoMappingContext());",
        "line": 119,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageHandlingWithMongoConverter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "converter = spy(converter);",
        "line": 121,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageHandlingWithMongoConverter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(converter, times(1)).write(Mockito.any(), Mockito.any(Bson.class));",
        "line": 133,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageHandlingWithMongoConverter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "converter",
    "variableType": "MappingMongoConverter",
    "mockedClass": "MappingMongoConverter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mongodb.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mongodb\\src\\test\\java\\org\\springframework\\integration\\mongodb\\outbound\\MongoDbStoringMessageHandlerTests.java",
      "className": "MongoDbStoringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MappingMongoConverter converter = new TestMongoConverter(MONGO_DATABASE_FACTORY, new MongoMappingContext());",
        "line": 138,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageHandlingWithMongoTemplate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "converter = spy(converter);",
        "line": 140,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageHandlingWithMongoTemplate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(converter, times(1)).write(Mockito.any(), Mockito.any(Bson.class));",
        "line": 156,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageHandlingWithMongoTemplate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "converter",
    "variableType": "MappingMongoConverter",
    "mockedClass": "MappingMongoConverter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mongodb.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mongodb\\src\\test\\java\\org\\springframework\\integration\\mongodb\\outbound\\ReactiveMongoDbStoringMessageHandlerTests.java",
      "className": "ReactiveMongoDbStoringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MappingMongoConverter converter = new ReactiveTestMongoConverter(REACTIVE_MONGO_DATABASE_FACTORY, new MongoMappingContext());",
        "line": 151,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageHandlingWithMongoConverter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "converter = spy(converter);",
        "line": 154,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageHandlingWithMongoConverter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "converter",
    "variableType": "MappingMongoConverter",
    "mockedClass": "MappingMongoConverter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mongodb.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mongodb\\src\\test\\java\\org\\springframework\\integration\\mongodb\\outbound\\ReactiveMongoDbStoringMessageHandlerTests.java",
      "className": "ReactiveMongoDbStoringMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MappingMongoConverter converter = new ReactiveTestMongoConverter(REACTIVE_MONGO_DATABASE_FACTORY, new MongoMappingContext());",
        "line": 171,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageHandlingWithMongoTemplate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "converter = spy(converter);",
        "line": 174,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageHandlingWithMongoTemplate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\DownstreamExceptionTests.java",
      "className": "DownstreamExceptionTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(noErrorChannel, \"logger\", LogAccessor.class));",
        "line": 73,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoErrorChannel",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger).error(any(Throwable.class), ArgumentMatchers.<Supplier<String>>argThat(logMessage -> logMessage.get().startsWith(\"Unhandled exception for\")));",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNoErrorChannel",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "IMqttAsyncClient",
    "mockedClass": "IMqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final IMqttAsyncClient client = mock(IMqttAsyncClient.class);",
        "line": 116,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCloseOnBadConnectOut",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).close();",
        "line": 127,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCloseOnBadConnectOut",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "DefaultMqttPahoClientFactory",
    "mockedClass": "DefaultMqttPahoClientFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();",
        "line": 133,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOutboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "factory = spy(factory);",
        "line": 149,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOutboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "token",
    "variableType": "MqttToken",
    "mockedClass": "MqttToken",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final MqttToken token = mock(MqttToken.class);",
        "line": 159,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOutboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "deliveryToken",
    "variableType": "MqttDeliveryToken",
    "mockedClass": "MqttDeliveryToken",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final MqttDeliveryToken deliveryToken = mock(MqttDeliveryToken.class);",
        "line": 177,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOutboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "MqttAsyncClient",
    "mockedClass": "MqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final MqttAsyncClient client = mock(MqttAsyncClient.class);",
        "line": 150,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOutboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, times(1)).connect(any(MqttConnectOptions.class));",
        "line": 189,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testOutboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "deliveryToken",
    "variableType": "var",
    "mockedClass": "MqttDeliveryToken",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "var deliveryToken = mock(MqttDeliveryToken.class);",
        "line": 206,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "clientManager",
    "variableType": "var",
    "mockedClass": "Mqttv3ClientManager",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "// given\r\nvar clientManager = mock(Mqttv3ClientManager.class);",
        "line": 201,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(clientManager.getConnectionInfo()).thenReturn(new MqttConnectOptions());",
        "line": 202,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(clientManager.getClient()).willReturn(client);",
        "line": 204,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "var",
    "mockedClass": "MqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "var client = mock(MqttAsyncClient.class);",
        "line": 203,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(client.publish(anyString(), any(MqttMessage.class))).willReturn(deliveryToken);",
        "line": 207,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// then\r\nverify(client, never()).connect(any(MqttConnectOptions.class));",
        "line": 220,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).publish(anyString(), any(MqttMessage.class));",
        "line": 221,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, never()).disconnect();",
        "line": 222,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, never()).disconnect(anyLong());",
        "line": 223,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, never()).close();",
        "line": 224,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "subscribeToken",
    "variableType": "var",
    "mockedClass": "MqttToken",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "var subscribeToken = mock(MqttToken.class);",
        "line": 235,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(subscribeToken.getGrantedQos()).willReturn(new int[] { 2 });",
        "line": 236,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "clientManager",
    "variableType": "var",
    "mockedClass": "Mqttv3ClientManager",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "// given\r\nvar clientManager = mock(Mqttv3ClientManager.class);",
        "line": 230,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(clientManager.getConnectionInfo()).thenReturn(new MqttConnectOptions());",
        "line": 231,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(clientManager.getClient()).willReturn(client);",
        "line": 233,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "var",
    "mockedClass": "MqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "var client = mock(MqttAsyncClient.class);",
        "line": 232,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(client.subscribe(any(String[].class), any(int[].class), any())).willReturn(subscribeToken);",
        "line": 237,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// then\r\nverify(client, never()).connect(any(MqttConnectOptions.class));",
        "line": 250,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).subscribe(eq(new String[] { \"mqtt-foo\" }), any(int[].class), any());",
        "line": 251,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).unsubscribe(new String[] { \"mqtt-foo\" });",
        "line": 252,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, never()).disconnect();",
        "line": 253,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, never()).disconnect(anyLong());",
        "line": 254,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, never()).close();",
        "line": 255,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testClientManagerIsNotConnectedAndClosedInAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "DefaultMqttPahoClientFactory",
    "mockedClass": "DefaultMqttPahoClientFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();",
        "line": 260,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "factory = spy(factory);",
        "line": 276,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "token",
    "variableType": "IMqttToken",
    "mockedClass": "IMqttToken",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "IMqttToken token = mock(IMqttToken.class);",
        "line": 281,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(token.getGrantedQos()).willReturn(new int[] { 2 });",
        "line": 297,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "IMqttAsyncClient",
    "mockedClass": "IMqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final IMqttAsyncClient client = mock(IMqttAsyncClient.class);",
        "line": 277,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(client.subscribe(any(String[].class), any(int[].class), any())).willReturn(token);",
        "line": 296,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(client.isConnected()).willReturn(true);",
        "line": 305,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, times(1)).connect(any(MqttConnectOptions.class));",
        "line": 326,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).setManualAcks(true);",
        "line": 336,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).messageArrivedComplete(MqttHeaderAccessor.id(outMessage), MqttHeaderAccessor.receivedQos(outMessage));",
        "line": 337,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "applicationEventPublisher",
    "variableType": "ApplicationEventPublisher",
    "mockedClass": "ApplicationEventPublisher",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ApplicationEventPublisher applicationEventPublisher = mock(ApplicationEventPublisher.class);",
        "line": 315,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundOptionsApplied",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "IMqttAsyncClient",
    "mockedClass": "IMqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final IMqttAsyncClient client = mock(IMqttAsyncClient.class);",
        "line": 376,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStopActionDefault",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "IMqttAsyncClient",
    "mockedClass": "IMqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final IMqttAsyncClient client = mock(IMqttAsyncClient.class);",
        "line": 387,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStopActionDefaultNotClean",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "DefaultMqttPahoClientFactory",
    "mockedClass": "DefaultMqttPahoClientFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();",
        "line": 419,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSubscribeFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "factory = spy(factory);",
        "line": 434,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSubscribeFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "MqttAsyncClient",
    "mockedClass": "MqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final MqttAsyncClient client = mock(MqttAsyncClient.class);",
        "line": 435,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSubscribeFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(client.isConnected()).willReturn(true);",
        "line": 437,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSubscribeFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "eventPublisher",
    "variableType": "ApplicationEventPublisher",
    "mockedClass": "ApplicationEventPublisher",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ApplicationEventPublisher eventPublisher = mock(ApplicationEventPublisher.class);",
        "line": 458,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSubscribeFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(eventPublisher).publishEvent(any(MqttConnectionFailedEvent.class));",
        "line": 461,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSubscribeFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "token",
    "variableType": "IMqttToken",
    "mockedClass": "IMqttToken",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "IMqttToken token = mock(IMqttToken.class);",
        "line": 440,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSubscribeFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(token.getGrantedQos()).willReturn(new int[] { 0x80 });",
        "line": 441,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSubscribeFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "DefaultMqttPahoClientFactory",
    "mockedClass": "DefaultMqttPahoClientFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();",
        "line": 466,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDifferentQos",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "factory = spy(factory);",
        "line": 481,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDifferentQos",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, \"logger\", LogAccessor.class));",
        "line": 505,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDifferentQos",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(logger.isWarnEnabled()).willReturn(true);",
        "line": 507,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDifferentQos",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(logger, atLeastOnce()).warn(ArgumentMatchers.<Supplier<? extends CharSequence>>argThat(logMessage -> logMessage.get().equals(\"Granted QOS different to Requested QOS; topics: [baz, fix] \" + \"requested: [1, 1] granted: [2, 0]\")));",
        "line": 509,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDifferentQos",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "MqttAsyncClient",
    "mockedClass": "MqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final MqttAsyncClient client = mock(MqttAsyncClient.class);",
        "line": 482,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDifferentQos",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(client.isConnected()).willReturn(true);",
        "line": 484,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDifferentQos",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).disconnectForcibly(5_000L);",
        "line": 517,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDifferentQos",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "token",
    "variableType": "IMqttToken",
    "mockedClass": "IMqttToken",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "IMqttToken token = mock(IMqttToken.class);",
        "line": 487,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDifferentQos",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "given(token.getGrantedQos()).willReturn(new int[] { 2, 0 });",
        "line": 488,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDifferentQos",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "adapter",
    "variableType": "var",
    "mockedClass": "var",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "var adapter = new MqttPahoMessageDrivenChannelAdapter(\"client_id\", mock(MqttPahoClientFactory.class), \"topic1\");",
        "line": 527,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "emptyTopicNotAllowed",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "token",
    "variableType": "IMqttToken",
    "mockedClass": "IMqttToken",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\MqttAdapterTests.java",
      "className": "MqttAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "IMqttToken token = mock(IMqttToken.class);",
        "line": 551,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "buildAdapterIn",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(token.getGrantedQos()).willReturn(new int[] { 2 });",
        "line": 554,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "buildAdapterIn",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "IMqttAsyncClient",
    "mockedClass": "IMqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\Mqttv5AdapterTests.java",
      "className": "Mqttv5AdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final IMqttAsyncClient client = mock(IMqttAsyncClient.class);",
        "line": 53,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStop",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).connect(any(MqttConnectionOptions.class));",
        "line": 60,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStop",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).subscribe(any(MqttSubscription[].class), any(), any(), any(IMqttMessageListener.class), any());",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStop",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).unsubscribe(any(String[].class));",
        "line": 62,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStop",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "client",
    "variableType": "IMqttAsyncClient",
    "mockedClass": "IMqttAsyncClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\Mqttv5AdapterTests.java",
      "className": "Mqttv5AdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "final IMqttAsyncClient client = mock(IMqttAsyncClient.class);",
        "line": 67,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStopNotClean",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).connect(any(MqttConnectionOptions.class));",
        "line": 74,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStopNotClean",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client).subscribe(any(MqttSubscription[].class), any(), any(), any(IMqttMessageListener.class), any());",
        "line": 75,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStopNotClean",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(client, never()).unsubscribe(any(String[].class));",
        "line": 76,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStopNotClean",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "token",
    "variableType": "IMqttToken",
    "mockedClass": "IMqttToken",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.mqtt",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-mqtt\\src\\test\\java\\org\\springframework\\integration\\mqtt\\Mqttv5AdapterTests.java",
      "className": "Mqttv5AdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "IMqttToken token = mock(IMqttToken.class);",
        "line": 87,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "buildAdapterIn",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "boundListOperations",
    "variableType": "BoundListOperations<String,byte[]>",
    "mockedClass": "BoundListOperations<String,byte[]>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.redis.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-redis\\src\\test\\java\\org\\springframework\\integration\\redis\\inbound\\RedisQueueMessageDrivenEndpointTests.java",
      "className": "RedisQueueMessageDrivenEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BoundListOperations<String, byte[]> boundListOperations = TestUtils.getPropertyValue(endpoint, \"boundListOperations\", BoundListOperations.class);",
        "line": 261,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3442ProperlyStop",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "boundListOperations = Mockito.spy(boundListOperations);",
        "line": 263,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3442ProperlyStop",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(boundListOperations, atLeastOnce()).rightPush(any(byte[].class));",
        "line": 290,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3442ProperlyStop",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "DefaultSftpSessionFactory",
    "mockedClass": "DefaultSftpSessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— @Override\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\config\\SftpStreamingInboundChannelAdapterParserTests.java",
      "className": "TestSessionFactoryBean"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DefaultSftpSessionFactory factory = mock(DefaultSftpSessionFactory.class);",
        "line": 98,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getSession()).thenReturn(session);",
        "line": 100,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "SftpSession",
    "mockedClass": "SftpSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\config\\SftpStreamingInboundChannelAdapterParserTests.java",
      "className": "TestSessionFactoryBean"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SftpSession session = mock(SftpSession.class);",
        "line": 99,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "store",
    "variableType": "PropertiesPersistingMetadataStore",
    "mockedClass": "PropertiesPersistingMetadataStore",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\inbound\\SftpInboundRemoteFileSystemSynchronizerTests.java",
      "className": "SftpInboundRemoteFileSystemSynchronizerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "PropertiesPersistingMetadataStore store = spy(new PropertiesPersistingMetadataStore());",
        "line": 98,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCopyFileToLocalDir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(store).close();",
        "line": 163,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCopyFileToLocalDir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "synchronizer",
    "variableType": "SftpInboundFileSynchronizer",
    "mockedClass": "SftpInboundFileSynchronizer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\inbound\\SftpInboundRemoteFileSystemSynchronizerTests.java",
      "className": "SftpInboundRemoteFileSystemSynchronizerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SftpInboundFileSynchronizer synchronizer = spy(new SftpInboundFileSynchronizer(ftpSessionFactory));",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCopyFileToLocalDir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// two times because on the third receive (above) the internal queue will be empty, so it will attempt\r\nverify(synchronizer, times(2)).synchronizeToLocalDirectory(localDirectory, Integer.MIN_VALUE);",
        "line": 148,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCopyFileToLocalDir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(synchronizer).close();",
        "line": 162,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCopyFileToLocalDir",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "attributes",
    "variableType": "SftpClient.Attributes",
    "mockedClass": "SftpClient.Attributes",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\inbound\\SftpInboundRemoteFileSystemSynchronizerTests.java",
      "className": "TestSftpSessionFactory"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SftpClient.Attributes attributes = spy(new SftpClient.Attributes());",
        "line": 179,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "init",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "given(attributes.isRegularFile()).willReturn(true);",
        "line": 181,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "init",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "sftpClient",
    "variableType": "SftpClient",
    "mockedClass": "SftpClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— @Override\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\inbound\\SftpInboundRemoteFileSystemSynchronizerTests.java",
      "className": "TestSftpSessionFactory"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SftpClient sftpClient = mock(SftpClient.class);",
        "line": 194,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sftpClient.canonicalPath(\"remote-test-dir\")).thenReturn(\"/remote-test-dir\");",
        "line": 195,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sftpClient.canonicalPath(remoteFilePath)).thenReturn(\"/\" + remoteFilePath);",
        "line": 200,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sftpClient.read(\"/\" + remoteFilePath)).thenReturn(new FileInputStream(remoteFilePath));",
        "line": 202,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sftpClient.readDir(\"/remote-test-dir\")).thenReturn(this.sftpEntries);",
        "line": 205,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<SftpClient.DirEntry>",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\outbound\\SftpOutboundTests.java",
      "className": "SftpOutboundTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<SftpClient.DirEntry> session = mock(Session.class);",
        "line": 211,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMkDir",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.exists(anyString())).thenReturn(Boolean.FALSE);",
        "line": 212,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMkDir",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionFactory",
    "variableType": "SessionFactory<SftpClient.DirEntry>",
    "mockedClass": "SessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\outbound\\SftpOutboundTests.java",
      "className": "SftpOutboundTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SessionFactory<SftpClient.DirEntry> sessionFactory = mock(SessionFactory.class);",
        "line": 213,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMkDir",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sessionFactory.getSession()).thenReturn(session);",
        "line": 214,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMkDir",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sftpClient",
    "variableType": "SftpClient",
    "mockedClass": "SftpClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\outbound\\SftpOutboundTests.java",
      "className": "SftpOutboundTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SftpClient sftpClient = mock(SftpClient.class);",
        "line": 270,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExists",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sftpClient",
    "variableType": "SftpClient",
    "mockedClass": "SftpClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— @Override\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\outbound\\SftpOutboundTests.java",
      "className": "TestSftpSessionFactory"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SftpClient sftpClient = mock(SftpClient.class);",
        "line": 307,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sftpClient.getVersion()).thenReturn(SftpConstants.SFTP_V6);",
        "line": 309,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(sftpClient.readDir(\"/remote-test-dir\")).thenReturn(dirEntries);",
        "line": 329,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sftpClient",
    "variableType": "SftpClient",
    "mockedClass": "SftpClient",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\outbound\\SftpServerOutboundTests.java",
      "className": "SftpServerOutboundTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SftpClient sftpClient = spy(TestUtils.getPropertyValue(session, \"sftpClient\", SftpClient.class));",
        "line": 481,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3088MPutNotRecursive",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(sftpClient).setStat(eq(\"sftpTarget/localSource1.txt\"), any(SftpClient.Attributes.class));",
        "line": 500,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3088MPutNotRecursive",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(sftpClient).setStat(eq(\"sftpTarget/localSource2.txt\"), any(SftpClient.Attributes.class));",
        "line": 501,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt3088MPutNotRecursive",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session<?>",
    "mockedClass": "Session<?>",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\outbound\\SftpServerOutboundTests.java",
      "className": "SftpServerOutboundTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session<?> session = spy(this.sessionFactory.getSession());",
        "line": 652,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStream",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(session).close();",
        "line": 663,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testStream",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "manager",
    "variableType": "ClientFactoryManager",
    "mockedClass": "ClientFactoryManager",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\session\\ResourceKnownHostsServerKeyVerifierTests.java",
      "className": "ResourceKnownHostsServerKeyVerifierTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ClientFactoryManager manager = Mockito.mock(ClientFactoryManager.class);",
        "line": 79,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testServerKeys",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(manager.getRandomFactory()).thenReturn((Factory) JceRandomFactory.INSTANCE);",
        "line": 80,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testServerKeys",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "ClientSession",
    "mockedClass": "ClientSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\session\\ResourceKnownHostsServerKeyVerifierTests.java",
      "className": "ResourceKnownHostsServerKeyVerifierTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ClientSession session = Mockito.mock(ClientSession.class);",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testServerKeys",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(session.getFactoryManager()).thenReturn(manager);",
        "line": 84,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testServerKeys",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(session.getConnectAddress()).thenReturn(key);",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testServerKeys",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sftpSession",
    "variableType": "SftpSession",
    "mockedClass": "SftpSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.sftp.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-sftp\\src\\test\\java\\org\\springframework\\integration\\sftp\\session\\SftpTestSessionFactory.java",
      "className": "SftpTestSessionFactory"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SftpSession sftpSession = spy(new SftpSession(sftpClient));",
        "line": 37,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSftpSession",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "SmbSession",
    "mockedClass": "SmbSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\config\\SmbInboundChannelAdapterParserTests.java",
      "className": "TestSessionFactoryBean"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SmbSession session = mock(SmbSession.class);",
        "line": 128,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "smbFactory",
    "variableType": "SmbSessionFactory",
    "mockedClass": "SmbSessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— Other Methods\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\config\\SmbInboundChannelAdapterParserTests.java",
      "className": "TestSessionFactoryBean"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SmbSessionFactory smbFactory = mock(SmbSessionFactory.class);",
        "line": 127,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbFactory.getSession()).thenReturn(session);",
        "line": 129,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "factory",
    "variableType": "SmbSessionFactory",
    "mockedClass": "SmbSessionFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— @Override\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\config\\SmbStreamingInboundChannelAdapterParserTests.java",
      "className": "TestSessionFactoryBean"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SmbSessionFactory factory = mock(SmbSessionFactory.class);",
        "line": 104,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(factory.getSession()).thenReturn(session);",
        "line": 106,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "SmbSession",
    "mockedClass": "SmbSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\config\\SmbStreamingInboundChannelAdapterParserTests.java",
      "className": "TestSessionFactoryBean"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SmbSession session = mock(SmbSession.class);",
        "line": 105,
        "locate": "@Override",
        "locationContext": {
          "methodName": "getObject",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "smbFile1",
    "variableType": "SmbFile",
    "mockedClass": "SmbFile",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.filters",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\filters\\SmbLastModifiedFileListFilterTests.java",
      "className": "SmbLastModifiedFileListFilterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SmbFile smbFile1 = mock(SmbFile.class);",
        "line": 41,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAge",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());",
        "line": 42,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAge",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "smbFile3",
    "variableType": "SmbFile",
    "mockedClass": "SmbFile",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.filters",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\filters\\SmbLastModifiedFileListFilterTests.java",
      "className": "SmbLastModifiedFileListFilterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SmbFile smbFile3 = mock(SmbFile.class);",
        "line": 45,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAge",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());",
        "line": 47,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAge",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "smbFile2",
    "variableType": "SmbFile",
    "mockedClass": "SmbFile",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.filters",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\filters\\SmbLastModifiedFileListFilterTests.java",
      "className": "SmbLastModifiedFileListFilterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SmbFile smbFile2 = mock(SmbFile.class);",
        "line": 43,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAge",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());",
        "line": 44,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAge",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "smbSession",
    "variableType": "SmbSession",
    "mockedClass": "SmbSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\inbound\\SmbInboundRemoteFileSystemSynchronizerTests.java",
      "className": "SmbInboundRemoteFileSystemSynchronizerTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private SmbSession smbSession;",
        "line": 44,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "smbSession = mock(SmbSession.class);",
        "line": 57,
        "locate": "@Before",
        "locationContext": {
          "methodName": "prepare",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.list(testRemoteDir)).thenReturn(smbFiles.toArray(new SmbFile[] {}));",
        "line": 120,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.remove(Mockito.anyString())).thenReturn(true);",
        "line": 121,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "smbSession",
    "variableType": "SmbSession",
    "mockedClass": "SmbSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\inbound\\SmbInboundRemoteFileSystemSynchronizerTests.java",
      "className": "SmbInboundRemoteFileSystemSynchronizerTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private SmbSession smbSession;",
        "line": 44,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "smbSession = mock(SmbSession.class);",
        "line": 57,
        "locate": "@Before",
        "locationContext": {
          "methodName": "prepare",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.list(testRemoteDir)).thenReturn(smbFiles.toArray(new SmbFile[] {}));",
        "line": 120,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.remove(Mockito.anyString())).thenReturn(true);",
        "line": 121,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "smbSession",
    "variableType": "SmbSession",
    "mockedClass": "SmbSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\outbound\\SmbSendingMessageHandlerTests.java",
      "className": "SmbSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private SmbSession smbSession;",
        "line": 50,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "smbSession = mock(SmbSession.class);",
        "line": 56,
        "locate": "@Before",
        "locationContext": {
          "methodName": "prepare",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.remove(Mockito.anyString())).thenReturn(true);",
        "line": 117,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.list(Mockito.anyString())).thenReturn(new SmbFile[0]);",
        "line": 118,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.isOpen()).thenReturn(true);",
        "line": 153,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "smbSession",
    "variableType": "SmbSession",
    "mockedClass": "SmbSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\outbound\\SmbSendingMessageHandlerTests.java",
      "className": "SmbSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private SmbSession smbSession;",
        "line": 50,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "smbSession = mock(SmbSession.class);",
        "line": 56,
        "locate": "@Before",
        "locationContext": {
          "methodName": "prepare",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.remove(Mockito.anyString())).thenReturn(true);",
        "line": 117,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.list(Mockito.anyString())).thenReturn(new SmbFile[0]);",
        "line": 118,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.isOpen()).thenReturn(true);",
        "line": 153,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "smbSession",
    "variableType": "SmbSession",
    "mockedClass": "SmbSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\session\\SmbSessionFactoryWithCIFSContextTests.java",
      "className": "SmbSessionFactoryWithCIFSContextTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private SmbSession smbSession;",
        "line": 51,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "smbSession = mock(SmbSession.class);",
        "line": 57,
        "locate": "@Before",
        "locationContext": {
          "methodName": "prepare",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "// the rest has been copied from SmbSendingMessageHandlerTests\r\nwhen(smbSession.remove(Mockito.anyString())).thenReturn(true);",
        "line": 106,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.list(Mockito.anyString())).thenReturn(new SmbFile[0]);",
        "line": 107,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.isOpen()).thenReturn(true);",
        "line": 138,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "smbSession",
    "variableType": "SmbSession",
    "mockedClass": "SmbSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.smb.session",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-smb\\src\\test\\java\\org\\springframework\\integration\\smb\\session\\SmbSessionFactoryWithCIFSContextTests.java",
      "className": "SmbSessionFactoryWithCIFSContextTests"
    },
    "statements": [
      {
        "type": "FIELD_DECLARATION",
        "code": "private SmbSession smbSession;",
        "line": 51,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": []
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "smbSession = mock(SmbSession.class);",
        "line": 57,
        "locate": "@Before",
        "locationContext": {
          "methodName": "prepare",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "// the rest has been copied from SmbSendingMessageHandlerTests\r\nwhen(smbSession.remove(Mockito.anyString())).thenReturn(true);",
        "line": 106,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.list(Mockito.anyString())).thenReturn(new SmbFile[0]);",
        "line": 107,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(smbSession.isOpen()).thenReturn(true);",
        "line": 138,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createSession",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "stompSession",
    "variableType": "StompSession",
    "mockedClass": "StompSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Override\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.stomp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-stomp\\src\\test\\java\\org\\springframework\\integration\\stomp\\StompSessionManagerTests.java",
      "className": "StompSessionManagerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "StompSession stompSession = mock(StompSession.class);",
        "line": 58,
        "locate": "@Override",
        "locationContext": {
          "methodName": "doConnect",
          "methodAnnotations": [
            "@Override"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sessionManager",
    "variableType": "AbstractStompSessionManager",
    "mockedClass": "AbstractStompSessionManager",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.stomp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-stomp\\src\\test\\java\\org\\springframework\\integration\\stomp\\StompSessionManagerTests.java",
      "className": "StompSessionManagerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "AbstractStompSessionManager sessionManager = new AbstractStompSessionManager(stompClient) {\r\n\r\n    private final AtomicBoolean thrown = new AtomicBoolean();\r\n\r\n    @Override\r\n    protected CompletableFuture<StompSession> doConnect(StompSessionHandler handler) {\r\n        if (!this.thrown.getAndSet(true)) {\r\n            throw new RuntimeException(\"intentional\");\r\n        } else {\r\n            CompletableFuture<StompSession> future = new CompletableFuture<>();\r\n            StompSession stompSession = mock(StompSession.class);\r\n            future.complete(stompSession);\r\n            handler.afterConnected(stompSession, getConnectHeaders());\r\n            return future;\r\n        }\r\n    }\r\n};",
        "line": 47,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDoConnectFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "stompClient",
    "variableType": "StompClientSupport",
    "mockedClass": "StompClientSupport",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.stomp",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-stomp\\src\\test\\java\\org\\springframework\\integration\\stomp\\StompSessionManagerTests.java",
      "className": "StompSessionManagerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "StompClientSupport stompClient = mock(StompClientSupport.class);",
        "line": 45,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDoConnectFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "publisher",
    "variableType": "ApplicationEventPublisher",
    "mockedClass": "ApplicationEventPublisher",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.stream",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-stream\\src\\test\\java\\org\\springframework\\integration\\stream\\CharacterStreamSourceTests.java",
      "className": "CharacterStreamSourceTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEOF",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(publisher).publishEvent(any(StreamClosedEvent.class));",
        "line": 68,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEOF",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "bufferedWriter",
    "variableType": "BufferedWriter",
    "mockedClass": "BufferedWriter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.stream.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-stream\\src\\test\\java\\org\\springframework\\integration\\stream\\config\\ConsoleOutboundChannelAdapterParserTests.java",
      "className": "ConsoleOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BufferedWriter bufferedWriter = TestUtils.getPropertyValue(this.stdoutAdapterWithDefaultCharsetHandler, \"writer\", BufferedWriter.class);",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutAdapterWithDefaultCharset",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "bufferedWriter = Mockito.spy(bufferedWriter);",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutAdapterWithDefaultCharset",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(bufferedWriter, times(1)).write(eq(\"foo\"));",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutAdapterWithDefaultCharset",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "bufferedWriter",
    "variableType": "BufferedWriter",
    "mockedClass": "BufferedWriter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.stream.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-stream\\src\\test\\java\\org\\springframework\\integration\\stream\\config\\ConsoleOutboundChannelAdapterParserTests.java",
      "className": "ConsoleOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BufferedWriter bufferedWriter = TestUtils.getPropertyValue(this.stdoutAdapterWithProvidedCharsetHandler, \"writer\", BufferedWriter.class);",
        "line": 107,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutAdapterWithProvidedCharset",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "bufferedWriter = Mockito.spy(bufferedWriter);",
        "line": 116,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutAdapterWithProvidedCharset",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(bufferedWriter, times(1)).write(eq(\"bar\"));",
        "line": 123,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutAdapterWithProvidedCharset",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "bufferedWriter",
    "variableType": "BufferedWriter",
    "mockedClass": "BufferedWriter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.stream.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-stream\\src\\test\\java\\org\\springframework\\integration\\stream\\config\\ConsoleOutboundChannelAdapterParserTests.java",
      "className": "ConsoleOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BufferedWriter bufferedWriter = TestUtils.getPropertyValue(this.stderrAdapterHandler, \"writer\", BufferedWriter.class);",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stderrAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "bufferedWriter = Mockito.spy(bufferedWriter);",
        "line": 151,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stderrAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(bufferedWriter, times(1)).write(eq(\"bar\"));",
        "line": 159,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stderrAdapter",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "bufferedWriter",
    "variableType": "BufferedWriter",
    "mockedClass": "BufferedWriter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.stream.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-stream\\src\\test\\java\\org\\springframework\\integration\\stream\\config\\ConsoleOutboundChannelAdapterParserTests.java",
      "className": "ConsoleOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BufferedWriter bufferedWriter = TestUtils.getPropertyValue(this.newlineAdapterHandler, \"writer\", BufferedWriter.class);",
        "line": 166,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutAdatperWithAppendNewLine",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "bufferedWriter = Mockito.spy(bufferedWriter);",
        "line": 175,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutAdatperWithAppendNewLine",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(bufferedWriter, times(1)).write(eq(\"bar\"));",
        "line": 182,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutAdatperWithAppendNewLine",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(bufferedWriter, times(1)).newLine();",
        "line": 183,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutAdatperWithAppendNewLine",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "bufferedWriter",
    "variableType": "BufferedWriter",
    "mockedClass": "BufferedWriter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.stream.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-stream\\src\\test\\java\\org\\springframework\\integration\\stream\\config\\ConsoleOutboundChannelAdapterParserTests.java",
      "className": "ConsoleOutboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "BufferedWriter bufferedWriter = TestUtils.getPropertyValue(stdoutHandler, \"writer\", BufferedWriter.class);",
        "line": 198,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutInsideNestedChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "bufferedWriter = Mockito.spy(bufferedWriter);",
        "line": 207,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutInsideNestedChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(bufferedWriter, times(1)).write(eq(\"foobar\"));",
        "line": 213,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "stdoutInsideNestedChain",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.syslog.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-syslog\\src\\test\\java\\org\\springframework\\integration\\syslog\\inbound\\SyslogReceivingChannelAdapterTests.java",
      "className": "SyslogReceivingChannelAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, \"logger\", LogAccessor.class));",
        "line": 116,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTcp",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "publisher",
    "variableType": "ApplicationEventPublisher",
    "mockedClass": "ApplicationEventPublisher",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.syslog.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-syslog\\src\\test\\java\\org\\springframework\\integration\\syslog\\inbound\\SyslogReceivingChannelAdapterTests.java",
      "className": "SyslogReceivingChannelAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTcp",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "logger",
    "variableType": "LogAccessor",
    "mockedClass": "LogAccessor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.syslog.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-syslog\\src\\test\\java\\org\\springframework\\integration\\syslog\\inbound\\SyslogReceivingChannelAdapterTests.java",
      "className": "SyslogReceivingChannelAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, \"logger\", LogAccessor.class));",
        "line": 194,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTcpRFC5424",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "publisher",
    "variableType": "ApplicationEventPublisher",
    "mockedClass": "ApplicationEventPublisher",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.syslog.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-syslog\\src\\test\\java\\org\\springframework\\integration\\syslog\\inbound\\SyslogReceivingChannelAdapterTests.java",
      "className": "SyslogReceivingChannelAdapterTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);",
        "line": 178,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testTcpRFC5424",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageSource",
    "variableType": "MessageSource",
    "mockedClass": "MessageSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.test.mock",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-test\\src\\main\\java\\org\\springframework\\integration\\test\\mock\\MockIntegration.java",
      "className": "MockIntegration"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageSource messageSource = Mockito.mock(MessageSource.class);",
        "line": 90,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockMessageSource",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "BDDMockito.given(messageSource.receive()).willReturn(message);",
        "line": 92,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockMessageSource",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageSource",
    "variableType": "MessageSource",
    "mockedClass": "MessageSource",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.test.mock",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-test\\src\\main\\java\\org\\springframework\\integration\\test\\mock\\MockIntegration.java",
      "className": "MockIntegration"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageSource messageSource = Mockito.mock(MessageSource.class);",
        "line": 109,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockMessageSource",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "BDDMockito.given(messageSource.receive()).willReturn(message, messages);",
        "line": 111,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "mockMessageSource",
          "methodAnnotations": [
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.test.matcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-test-support\\src\\test\\java\\org\\springframework\\integration\\test\\matcher\\MockitoMessageMatchersTests.java",
      "className": "MockitoMessageMatchersTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nMessageHandler handler;",
        "line": 55,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.handler).handleMessage(MockitoMessageMatchers.messageWithPayload(SOME_PAYLOAD));",
        "line": 74,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "anyMatcher_withVerifyArgumentMatcherAndEqualPayload_matching",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.handler).handleMessage(MockitoMessageMatchers.messageWithPayload(Matchers.is(Matchers.instanceOf(Date.class))));",
        "line": 75,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "anyMatcher_withVerifyArgumentMatcherAndEqualPayload_matching",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(this.handler).handleMessage(MockitoMessageMatchers.messageWithPayload(Matchers.nullValue()));",
        "line": 84,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "anyMatcher_withVerifyAndDifferentPayload_notMatching",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "channel",
    "variableType": "MessageChannel",
    "mockedClass": "MessageChannel",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.test.matcher",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-test-support\\src\\test\\java\\org\\springframework\\integration\\test\\matcher\\MockitoMessageMatchersTests.java",
      "className": "MockitoMessageMatchersTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nMessageChannel channel;",
        "line": 58,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.channel.send(MockitoMessageMatchers.messageWithPayload(SOME_PAYLOAD))).thenReturn(true);",
        "line": 90,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "anyMatcher_withWhenArgumentMatcherAndEqualPayload_matching",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(this.channel.send(MockitoMessageMatchers.messageWithHeaderEntry(SOME_HEADER_KEY, Matchers.is(Matchers.instanceOf(Short.class))))).thenReturn(true);",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "anyMatcher_withWhenAndDifferentPayload_notMatching",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "serverWebSocketContainer",
    "variableType": "ServerWebSocketContainer",
    "mockedClass": "ServerWebSocketContainer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.websocket.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-websocket\\src\\test\\java\\org\\springframework\\integration\\websocket\\dsl\\WebSocketDslTests.java",
      "className": "WebSocketDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ServerWebSocketContainer serverWebSocketContainer = new ServerWebSocketContainer(\"/dynamic\").setHandshakeHandler(serverContext.getBean(HandshakeHandler.class)).setDecoratorFactories(handler -> {\r\n    WebSocketHandler spy = spy(handler);\r\n    decoratedHandler.set(spy);\r\n    return spy;\r\n}).withSockJs();",
        "line": 75,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDynamicServerEndpointRegistration",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "spy",
    "variableType": "WebSocketHandler",
    "mockedClass": "WebSocketHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.websocket.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-websocket\\src\\test\\java\\org\\springframework\\integration\\websocket\\dsl\\WebSocketDslTests.java",
      "className": "WebSocketDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebSocketHandler spy = spy(handler);",
        "line": 79,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testDynamicServerEndpointRegistration",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "webSocketInboundChannelAdapter",
    "variableType": "WebSocketInboundChannelAdapter",
    "mockedClass": "WebSocketInboundChannelAdapter",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.websocket.server",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-websocket\\src\\test\\java\\org\\springframework\\integration\\websocket\\server\\WebSocketServerTests.java",
      "className": "WebSocketServerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebSocketInboundChannelAdapter webSocketInboundChannelAdapter = new WebSocketInboundChannelAdapter(Mockito.mock(ServerWebSocketContainer.class));",
        "line": 162,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testBrokerIsNotPresented",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "defaultProtocolHandler",
    "variableType": "SubProtocolHandler",
    "mockedClass": "SubProtocolHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.websocket.support",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-websocket\\src\\test\\java\\org\\springframework\\integration\\websocket\\support\\SubProtocolHandlerRegistryTests.java",
      "className": "SubProtocolHandlerRegistryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SubProtocolHandler defaultProtocolHandler = mock(SubProtocolHandler.class);",
        "line": 45,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProtocolHandlers",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "WebSocketSession",
    "mockedClass": "WebSocketSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.websocket.support",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-websocket\\src\\test\\java\\org\\springframework\\integration\\websocket\\support\\SubProtocolHandlerRegistryTests.java",
      "className": "SubProtocolHandlerRegistryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebSocketSession session = mock(WebSocketSession.class);",
        "line": 50,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProtocolHandlers",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.getAcceptedProtocol()).thenReturn(\"v10.stomp\", (String) null);",
        "line": 51,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testProtocolHandlers",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "WebSocketSession",
    "mockedClass": "WebSocketSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.websocket.support",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-websocket\\src\\test\\java\\org\\springframework\\integration\\websocket\\support\\SubProtocolHandlerRegistryTests.java",
      "className": "SubProtocolHandlerRegistryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebSocketSession session = mock(WebSocketSession.class);",
        "line": 69,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSingleHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.getAcceptedProtocol()).thenReturn(\"foo\", (String) null);",
        "line": 70,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSingleHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "testProtocolHandler",
    "variableType": "SubProtocolHandler",
    "mockedClass": "SubProtocolHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.websocket.support",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-websocket\\src\\test\\java\\org\\springframework\\integration\\websocket\\support\\SubProtocolHandlerRegistryTests.java",
      "className": "SubProtocolHandlerRegistryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SubProtocolHandler testProtocolHandler = spy(new StompSubProtocolHandler());",
        "line": 65,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSingleHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(testProtocolHandler.getSupportedProtocols()).thenReturn(Collections.singletonList(\"foo\"));",
        "line": 66,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSingleHandler",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "WebSocketSession",
    "mockedClass": "WebSocketSession",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.websocket.support",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-websocket\\src\\test\\java\\org\\springframework\\integration\\websocket\\support\\SubProtocolHandlerRegistryTests.java",
      "className": "SubProtocolHandlerRegistryTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebSocketSession session = mock(WebSocketSession.class);",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHandlerSelection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(session.getAcceptedProtocol()).thenReturn(\"foo\", \"\", null);",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHandlerSelection",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "source",
    "variableType": "Source",
    "mockedClass": "Source",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\StubMessageFactory.java",
      "className": "StubMessageFactory"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Source source = mock(Source.class);",
        "line": 46,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createWebServiceMessage",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "message",
    "variableType": "WebServiceMessage",
    "mockedClass": "WebServiceMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Helper\n\nStubbing:\n— Helper Method\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\StubMessageFactory.java",
      "className": "StubMessageFactory"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceMessage message = mock(WebServiceMessage.class);",
        "line": 45,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createWebServiceMessage",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "when(message.getPayloadSource()).thenReturn(source);",
        "line": 47,
        "locate": "Helper Method",
        "locationContext": {
          "methodName": "createWebServiceMessage",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "webServiceTemplate",
    "variableType": "WebServiceTemplate",
    "mockedClass": "WebServiceTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\UriVariableTests.java",
      "className": "UriVariableTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceTemplate webServiceTemplate = TestUtils.getPropertyValue(this.httpOutboundGateway, \"webServiceTemplate\", WebServiceTemplate.class);",
        "line": 111,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHttpUriVariables",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "webServiceTemplate = Mockito.spy(webServiceTemplate);",
        "line": 113,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testHttpUriVariables",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "session",
    "variableType": "Session",
    "mockedClass": "Session",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\UriVariableTests.java",
      "className": "UriVariableTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Session session = Mockito.mock(Session.class);",
        "line": 144,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(session.createQueue(Mockito.anyString())).thenReturn(queue);",
        "line": 145,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(session.createBytesMessage()).thenReturn(Mockito.mock(BytesMessage.class));",
        "line": 146,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(session.createProducer(queue)).thenReturn(producer);",
        "line": 148,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "// For this test it's enough to not go ahead. Invoked in the 'JmsSenderConnection#onSendAfterWrite' on the\r\n// 'WebServiceTemplate#sendRequest' after invocation of our 'TestClientInterceptor'\r\nMockito.when(session.createTemporaryQueue()).thenThrow(new WebServiceIOException(\"intentional\"));",
        "line": 151,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(session).createQueue(destinationName);",
        "line": 173,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "producer",
    "variableType": "MessageProducer",
    "mockedClass": "MessageProducer",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\UriVariableTests.java",
      "className": "UriVariableTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageProducer producer = Mockito.mock(MessageProducer.class);",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(producer).setDeliveryMode(DeliveryMode.NON_PERSISTENT);",
        "line": 176,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "Mockito.verify(producer).setPriority(5);",
        "line": 177,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "Connection",
    "mockedClass": "Connection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\UriVariableTests.java",
      "className": "UriVariableTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Connection connection = Mockito.mock(Connection.class);",
        "line": 153,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(connection.createSession(Mockito.anyBoolean(), Mockito.anyInt())).thenReturn(session);",
        "line": 154,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "queue",
    "variableType": "Queue",
    "mockedClass": "Queue",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\UriVariableTests.java",
      "className": "UriVariableTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Queue queue = Mockito.mock(Queue.class);",
        "line": 140,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "// Need for 'QueueSession#createQueue()'\r\nMockito.when(queue.getQueueName()).thenReturn(destinationName);",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInt2720JmsUriVariables",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "unmarshaller",
    "variableType": "Unmarshaller",
    "mockedClass": "Unmarshaller",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\WebServiceInboundGatewayParserTests.java",
      "className": "WebServiceInboundGatewayParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Unmarshaller unmarshaller = mock(Unmarshaller.class);",
        "line": 136,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistoryWithMarshallingGateway",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(unmarshaller.unmarshal(Mockito.any())).thenReturn(\"hello\");",
        "line": 137,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testMessageHistoryWithMarshallingGateway",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "webServiceTemplate",
    "variableType": "WebServiceTemplate",
    "mockedClass": "WebServiceTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\WebServiceOutboundGatewayParserTests.java",
      "className": "WebServiceOutboundGatewayParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceTemplate webServiceTemplate = TestUtils.getPropertyValue(handler, \"webServiceTemplate\", WebServiceTemplate.class);",
        "line": 419,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "jmsUri",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "webServiceTemplate = spy(webServiceTemplate);",
        "line": 421,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "jmsUri",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(webServiceTemplate).sendAndReceive(eq(\"jms:wsQueue\"), any(WebServiceMessageCallback.class), ArgumentMatchers.<WebServiceMessageExtractor<Object>>any());",
        "line": 431,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "jmsUri",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageSender",
    "variableType": "WebServiceMessageSender",
    "mockedClass": "WebServiceMessageSender",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— Other Methods\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\WebServiceOutboundGatewayWithHeaderMapperTests.java",
      "className": "WebServiceOutboundGatewayWithHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceMessageSender messageSender = Mockito.mock(WebServiceMessageSender.class);",
        "line": 211,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "process",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageSender.createConnection(Mockito.any(URI.class))).thenReturn(wsConnection);",
        "line": 213,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "process",
          "methodAnnotations": []
        }
      },
      {
        "type": "STUBBING",
        "code": "Mockito.when(messageSender.supports(Mockito.any(URI.class))).thenReturn(true);",
        "line": 214,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "process",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "wsConnection",
    "variableType": "WebServiceConnection",
    "mockedClass": "WebServiceConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Other Methods\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\config\\WebServiceOutboundGatewayWithHeaderMapperTests.java",
      "className": "WebServiceOutboundGatewayWithHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceConnection wsConnection = Mockito.mock(WebServiceConnection.class);",
        "line": 212,
        "locate": "Other Methods",
        "locationContext": {
          "methodName": "process",
          "methodAnnotations": []
        }
      }
    ]
  },
  {
    "variableName": "soapMessage",
    "variableType": "SoapMessage",
    "mockedClass": "SoapMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\DefaultSoapHeaderMapperTests.java",
      "className": "DefaultSoapHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapMessage soapMessage = mock(SoapMessage.class);",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNullSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "elementIterator",
    "variableType": "Iterator<SoapHeaderElement>",
    "mockedClass": "Iterator",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\DefaultSoapHeaderMapperTests.java",
      "className": "DefaultSoapHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nIterator<SoapHeaderElement> elementIterator = mock(Iterator.class);",
        "line": 75,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(elementIterator.hasNext()).thenReturn(true).thenReturn(false);",
        "line": 86,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(elementIterator.next()).thenReturn(soapHeaderElement);",
        "line": 87,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "soapMessage",
    "variableType": "SoapMessage",
    "mockedClass": "SoapMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\DefaultSoapHeaderMapperTests.java",
      "className": "DefaultSoapHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapMessage soapMessage = mock(SoapMessage.class);",
        "line": 70,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(soapMessage.getSoapHeader()).thenReturn(soapHeader);",
        "line": 80,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "soapHeaderElement",
    "variableType": "SoapHeaderElement",
    "mockedClass": "SoapHeaderElement",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\DefaultSoapHeaderMapperTests.java",
      "className": "DefaultSoapHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapHeaderElement soapHeaderElement = mock(SoapHeaderElement.class);",
        "line": 77,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(soapHeaderElement.getName()).thenReturn(element);",
        "line": 88,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "soapHeader",
    "variableType": "SoapHeader",
    "mockedClass": "SoapHeader",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\DefaultSoapHeaderMapperTests.java",
      "className": "DefaultSoapHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapHeader soapHeader = mock(SoapHeader.class);",
        "line": 71,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(soapHeader.getAllAttributes()).thenReturn(attrIterator);",
        "line": 81,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(soapHeader.getAttributeValue(attribute)).thenReturn(\"attrValue\");",
        "line": 84,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(soapHeader.examineAllHeaderElements()).thenReturn(elementIterator);",
        "line": 85,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "attrIterator",
    "variableType": "Iterator<QName>",
    "mockedClass": "Iterator",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\DefaultSoapHeaderMapperTests.java",
      "className": "DefaultSoapHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "@SuppressWarnings(\"unchecked\")\r\nIterator<QName> attrIterator = mock(Iterator.class);",
        "line": 72,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(attrIterator.hasNext()).thenReturn(true).thenReturn(false);",
        "line": 82,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(attrIterator.next()).thenReturn(attribute);",
        "line": 83,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testCustomSoapHeader",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "soapMessage",
    "variableType": "SoapMessage",
    "mockedClass": "SoapMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\DefaultSoapHeaderMapperTests.java",
      "className": "DefaultSoapHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapMessage soapMessage = mock(SoapMessage.class);",
        "line": 145,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExtractStandardHeadersNullSoapAction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(soapMessage.getSoapAction()).thenReturn(null);",
        "line": 146,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExtractStandardHeadersNullSoapAction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "soapMessage",
    "variableType": "SoapMessage",
    "mockedClass": "SoapMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\DefaultSoapHeaderMapperTests.java",
      "className": "DefaultSoapHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapMessage soapMessage = mock(SoapMessage.class);",
        "line": 154,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExtractStandardHeadersEmptySoapAction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(soapMessage.getSoapAction()).thenReturn(\"\");",
        "line": 155,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExtractStandardHeadersEmptySoapAction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "soapMessage",
    "variableType": "SoapMessage",
    "mockedClass": "SoapMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\DefaultSoapHeaderMapperTests.java",
      "className": "DefaultSoapHeaderMapperTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapMessage soapMessage = mock(SoapMessage.class);",
        "line": 163,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExtractStandardHeadersNonEmptySoapAction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(soapMessage.getSoapAction()).thenReturn(\"foo\");",
        "line": 164,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExtractStandardHeadersNonEmptySoapAction",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "unmarshaller",
    "variableType": "Unmarshaller",
    "mockedClass": "Unmarshaller",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Unmarshaller unmarshaller = mock(Unmarshaller.class);",
        "line": 60,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingInbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "marshaller",
    "variableType": "Marshaller",
    "mockedClass": "Both",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Marshaller marshaller = mock(Marshaller.class);",
        "line": 59,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingInbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "marshaller = mock(Both.class);",
        "line": 67,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingInbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "destinationProvider",
    "variableType": "DestinationProvider",
    "mockedClass": "DestinationProvider",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DestinationProvider destinationProvider = mock(DestinationProvider.class);",
        "line": 89,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageFactory",
    "variableType": "WebServiceMessageFactory",
    "mockedClass": "WebServiceMessageFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceMessageFactory messageFactory = mock(WebServiceMessageFactory.class);",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageSender",
    "variableType": "WebServiceMessageSender",
    "mockedClass": "WebServiceMessageSender",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceMessageSender messageSender = mock(WebServiceMessageSender.class);",
        "line": 96,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "unmarshaller",
    "variableType": "Unmarshaller",
    "mockedClass": "Unmarshaller",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Unmarshaller unmarshaller = mock(Unmarshaller.class);",
        "line": 91,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "interceptor",
    "variableType": "ClientInterceptor",
    "mockedClass": "ClientInterceptor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ClientInterceptor interceptor = mock(ClientInterceptor.class);",
        "line": 95,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "marshaller",
    "variableType": "Marshaller",
    "mockedClass": "Marshaller",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "Marshaller marshaller = mock(Marshaller.class);",
        "line": 90,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "faultMessageResolver",
    "variableType": "FaultMessageResolver",
    "mockedClass": "FaultMessageResolver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FaultMessageResolver faultMessageResolver = mock(FaultMessageResolver.class);",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "headerMapper",
    "variableType": "SoapHeaderMapper",
    "mockedClass": "SoapHeaderMapper",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "destinationProvider",
    "variableType": "DestinationProvider",
    "mockedClass": "DestinationProvider",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "DestinationProvider destinationProvider = mock(DestinationProvider.class);",
        "line": 132,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "simpleOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageFactory",
    "variableType": "WebServiceMessageFactory",
    "mockedClass": "WebServiceMessageFactory",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceMessageFactory messageFactory = mock(WebServiceMessageFactory.class);",
        "line": 133,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "simpleOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "messageSender",
    "variableType": "WebServiceMessageSender",
    "mockedClass": "WebServiceMessageSender",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceMessageSender messageSender = mock(WebServiceMessageSender.class);",
        "line": 137,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "simpleOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "interceptor",
    "variableType": "ClientInterceptor",
    "mockedClass": "ClientInterceptor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ClientInterceptor interceptor = mock(ClientInterceptor.class);",
        "line": 136,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "simpleOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sourceExtractor",
    "variableType": "SourceExtractor<?>",
    "mockedClass": "SourceExtractor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SourceExtractor<?> sourceExtractor = mock(SourceExtractor.class);",
        "line": 142,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "simpleOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "faultMessageResolver",
    "variableType": "FaultMessageResolver",
    "mockedClass": "FaultMessageResolver",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "FaultMessageResolver faultMessageResolver = mock(FaultMessageResolver.class);",
        "line": 134,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "simpleOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "headerMapper",
    "variableType": "SoapHeaderMapper",
    "mockedClass": "SoapHeaderMapper",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);",
        "line": 135,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "simpleOutbound",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "template",
    "variableType": "WebServiceTemplate",
    "mockedClass": "WebServiceTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceTemplate template = mock(WebServiceTemplate.class);",
        "line": 179,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingOutboundTemplate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "headerMapper",
    "variableType": "SoapHeaderMapper",
    "mockedClass": "SoapHeaderMapper",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);",
        "line": 174,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "marshallingOutboundTemplate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "template",
    "variableType": "WebServiceTemplate",
    "mockedClass": "WebServiceTemplate",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceTemplate template = mock(WebServiceTemplate.class);",
        "line": 207,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "simpleOutboundTemplate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "sourceExtractor",
    "variableType": "SourceExtractor<?>",
    "mockedClass": "SourceExtractor",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SourceExtractor<?> sourceExtractor = mock(SourceExtractor.class);",
        "line": 206,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "simpleOutboundTemplate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "headerMapper",
    "variableType": "SoapHeaderMapper",
    "mockedClass": "SoapHeaderMapper",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws.dsl",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\dsl\\WsDslTests.java",
      "className": "WsDslTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);",
        "line": 201,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "simpleOutboundTemplate",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "request",
    "variableType": "WebServiceMessage",
    "mockedClass": "WebServiceMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\MarshallingWebServiceIntegrationTests.java",
      "className": "MarshallingWebServiceIntegrationTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate WebServiceMessage request;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(request.getPayloadSource()).thenReturn(stringSource);",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "response",
    "variableType": "WebServiceMessage",
    "mockedClass": "WebServiceMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\MarshallingWebServiceIntegrationTests.java",
      "className": "MarshallingWebServiceIntegrationTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate WebServiceMessage response;",
        "line": 67,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(response.getPayloadResult()).thenReturn(stringResult);",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "MessageContext",
    "mockedClass": "MessageContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\MarshallingWebServiceIntegrationTests.java",
      "className": "MarshallingWebServiceIntegrationTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageContext context;",
        "line": 64,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getResponse()).thenReturn(response);",
        "line": 91,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getRequest()).thenReturn(request);",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "request",
    "variableType": "WebServiceMessage",
    "mockedClass": "WebServiceMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\MarshallingWebServiceIntegrationTests.java",
      "className": "MarshallingWebServiceIntegrationTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate WebServiceMessage request;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(request.getPayloadSource()).thenReturn(stringSource);",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "response",
    "variableType": "WebServiceMessage",
    "mockedClass": "WebServiceMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\MarshallingWebServiceIntegrationTests.java",
      "className": "MarshallingWebServiceIntegrationTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate WebServiceMessage response;",
        "line": 67,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(response.getPayloadResult()).thenReturn(stringResult);",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "MessageContext",
    "mockedClass": "MessageContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\MarshallingWebServiceIntegrationTests.java",
      "className": "MarshallingWebServiceIntegrationTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageContext context;",
        "line": 64,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getResponse()).thenReturn(response);",
        "line": 91,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getRequest()).thenReturn(request);",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "request",
    "variableType": "WebServiceMessage",
    "mockedClass": "WebServiceMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\MarshallingWebServiceIntegrationTests.java",
      "className": "MarshallingWebServiceIntegrationTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate WebServiceMessage request;",
        "line": 70,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(request.getPayloadSource()).thenReturn(stringSource);",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "response",
    "variableType": "WebServiceMessage",
    "mockedClass": "WebServiceMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\MarshallingWebServiceIntegrationTests.java",
      "className": "MarshallingWebServiceIntegrationTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate WebServiceMessage response;",
        "line": 67,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(response.getPayloadResult()).thenReturn(stringResult);",
        "line": 94,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "MessageContext",
    "mockedClass": "MessageContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Attribute Mock Creation\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\MarshallingWebServiceIntegrationTests.java",
      "className": "MarshallingWebServiceIntegrationTests"
    },
    "statements": [
      {
        "type": "FIELD_MOCK_CREATION",
        "code": "@Mock\r\nprivate MessageContext context;",
        "line": 64,
        "locate": "Attribute",
        "locationContext": {
          "methodName": "[FieldDeclaration]",
          "methodAnnotations": [
            "@Mock"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getResponse()).thenReturn(response);",
        "line": 91,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getRequest()).thenReturn(request);",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "sendString",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "response",
    "variableType": "WebServiceMessage",
    "mockedClass": "WebServiceMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in @Before\n\nStubbing:\n— @Before\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\SimpleWebServiceInboundGatewayTests.java",
      "className": "SimpleWebServiceInboundGatewayTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "WebServiceMessage response = mock(WebServiceMessage.class);",
        "line": 83,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(response.getPayloadResult()).thenReturn(payloadResult);",
        "line": 85,
        "locate": "@Before",
        "locationContext": {
          "methodName": "setup",
          "methodAnnotations": [
            "@BeforeEach"
          ]
        }
      }
    ]
  },
  {
    "variableName": "request",
    "variableType": "SoapMessage",
    "mockedClass": "SoapMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\WebServiceInboundGatewayJavaConfigTests.java",
      "className": "WebServiceInboundGatewayJavaConfigTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapMessage request = mock(SoapMessage.class);",
        "line": 90,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "request = mock(SoapMessage.class);",
        "line": 117,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(request.getPayloadSource()).thenReturn(payloadSource);",
        "line": 103,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(request.getPayloadSource()).thenReturn(payloadSource);",
        "line": 122,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "response",
    "variableType": "SoapMessage",
    "mockedClass": "SoapMessage",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\WebServiceInboundGatewayJavaConfigTests.java",
      "className": "WebServiceInboundGatewayJavaConfigTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapMessage response = mock(SoapMessage.class);",
        "line": 91,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(response.getPayloadResult()).thenReturn(payloadResult);",
        "line": 100,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(response.getSoapBody()).thenReturn(soapBody);",
        "line": 101,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "soapBody",
    "variableType": "SoapBody",
    "mockedClass": "SoapBody",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\WebServiceInboundGatewayJavaConfigTests.java",
      "className": "WebServiceInboundGatewayJavaConfigTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "SoapBody soapBody = mock(SoapBody.class);",
        "line": 92,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(soapBody).addServerOrReceiverFault(eq(\"503 Service Unavailable\"), any(Locale.class));",
        "line": 107,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "context",
    "variableType": "MessageContext",
    "mockedClass": "MessageContext",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n— Local Assignment in Test Case\n\nStubbing:\n— Test Case\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.ws",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-ws\\src\\test\\java\\org\\springframework\\integration\\ws\\WebServiceInboundGatewayJavaConfigTests.java",
      "className": "WebServiceInboundGatewayJavaConfigTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageContext context = mock(MessageContext.class);",
        "line": 89,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "ASSIGNMENT",
        "code": "context = mock(MessageContext.class);",
        "line": 116,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getResponse()).thenReturn(response);",
        "line": 99,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getRequest()).thenReturn(request);",
        "line": 102,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "STUBBING",
        "code": "when(context.getRequest()).thenReturn(request);",
        "line": 121,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWebServiceInboundGatewayJavaConfig",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "xmppConnection",
    "variableType": "XMPPConnection",
    "mockedClass": "XMPPConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\config\\ChatMessageInboundChannelAdapterParserTests.java",
      "className": "ChatMessageInboundChannelAdapterParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "XMPPConnection xmppConnection = Mockito.mock(XMPPConnection.class);",
        "line": 93,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testInboundAdapterUsageWithHeaderMapper",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "xmppConnectionFactoryBean",
    "variableType": "XmppConnectionFactoryBean",
    "mockedClass": "XmppConnectionFactoryBean",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\config\\XmppConnectionFactoryBeanTests.java",
      "className": "XmppConnectionFactoryBeanTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "XmppConnectionFactoryBean xmppConnectionFactoryBean = new XmppConnectionFactoryBean() {\r\n\r\n    @Override\r\n    protected XMPPConnection createInstance() {\r\n        return mock(XMPPTCPConnection.class);\r\n    }\r\n};",
        "line": 61,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testXmppConnectionFactoryBeanNoRoster",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "xmppConnectionFactoryBean",
    "variableType": "XmppConnectionFactoryBean",
    "mockedClass": "XmppConnectionFactoryBean",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\config\\XmppConnectionFactoryBeanTests.java",
      "className": "XmppConnectionFactoryBeanTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "XmppConnectionFactoryBean xmppConnectionFactoryBean = new XmppConnectionFactoryBean() {\r\n\r\n    @Override\r\n    protected XMPPConnection createInstance() {\r\n        return mock(XMPPTCPConnection.class);\r\n    }\r\n};",
        "line": 81,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testXmppConnectionFactoryBeanWithRoster",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "MessageHandler",
    "mockedClass": "MessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.config",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\config\\XmppHeaderEnricherParserTests.java",
      "className": "XmppHeaderEnricherParserTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MessageHandler handler = mock(MessageHandler.class);",
        "line": 65,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "to",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(handler, times(1)).handleMessage(Mockito.any(Message.class));",
        "line": 79,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "to",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "XMPPConnection",
    "mockedClass": "XMPPConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\inbound\\PresenceListeningEndpointTests.java",
      "className": "PresenceListeningEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "XMPPConnection connection = mock(XMPPConnection.class);",
        "line": 55,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testEndpointLifecycle",
          "methodAnnotations": [
            "@Test",
            "@SuppressWarnings"
          ]
        }
      }
    ]
  },
  {
    "variableName": "rosterEndpoint",
    "variableType": "PresenceListeningEndpoint",
    "mockedClass": "PresenceListeningEndpoint",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\inbound\\PresenceListeningEndpointTests.java",
      "className": "PresenceListeningEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "PresenceListeningEndpoint rosterEndpoint = new PresenceListeningEndpoint(mock(XMPPConnection.class));",
        "line": 73,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testNonInitializedFailure",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "XMPPConnection",
    "mockedClass": "XMPPConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\inbound\\PresenceListeningEndpointTests.java",
      "className": "PresenceListeningEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "XMPPConnection connection = mock(XMPPConnection.class);",
        "line": 80,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testRosterPresenceChangeEvent",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "XMPPConnection",
    "mockedClass": "XMPPConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.inbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\inbound\\PresenceListeningEndpointTests.java",
      "className": "PresenceListeningEndpointTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "XMPPConnection connection = mock(XMPPConnection.class);",
        "line": 120,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWithErrorChannel",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "XMPPConnection",
    "mockedClass": "XMPPConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\outbound\\ChatMessageSendingMessageHandlerTests.java",
      "className": "ChatMessageSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "XMPPConnection connection = mock(XMPPConnection.class);",
        "line": 57,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSendMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection, times(1)).sendStanza(Mockito.argThat((org.jivesoftware.smack.packet.Message smackMessage) -> {\r\n    boolean bodyMatches = smackMessage.getBody().equals(\"Test Message\");\r\n    boolean toMatches = smackMessage.getTo().equals(\"kermit@frog.com\");\r\n    return bodyMatches & toMatches;\r\n}));",
        "line": 67,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSendMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// in threaded conversation we need to look for existing chat\r\nverify(connection, times(1)).sendStanza(Mockito.argThat((org.jivesoftware.smack.packet.Message smackMessage) -> {\r\n    boolean bodyMatches = smackMessage.getBody().equals(\"Hello Kitty\");\r\n    boolean toMatches = smackMessage.getTo().equals(\"kermit@frog.com\");\r\n    boolean threadIdMatches = smackMessage.getThread().equals(\"123\");\r\n    return bodyMatches & toMatches & threadIdMatches;\r\n}));",
        "line": 84,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSendMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection, times(1)).sendStanza(Mockito.argThat((org.jivesoftware.smack.packet.Message smackMessage) -> {\r\n    boolean bodyMatches = smackMessage.getBody() == null;\r\n    boolean toMatches = smackMessage.getTo().equals(\"kermit@frog.com\");\r\n    GcmPacketExtension gcmPacketExtension = GcmPacketExtension.from(smackMessage);\r\n    boolean jsonMatches = gcmPacketExtension != null && gcmPacketExtension.getJson().equals(json);\r\n    return bodyMatches & toMatches & jsonMatches;\r\n}));",
        "line": 99,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testSendMessages",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "XMPPConnection",
    "mockedClass": "XMPPConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\outbound\\ChatMessageSendingMessageHandlerTests.java",
      "className": "ChatMessageSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "XMPPConnection connection = mock(XMPPConnection.class);",
        "line": 111,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessagePostAsSmackMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection).isConnected();",
        "line": 126,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessagePostAsSmackMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection).sendStanza(Mockito.argThat((org.jivesoftware.smack.packet.Message m) -> {\r\n    boolean bodyMatches = \"Test Message\".equals(m.getBody());\r\n    boolean toMatches = m.getTo().toString().equals(\"kermit@frog.com\");\r\n    return bodyMatches && toMatches;\r\n}));",
        "line": 127,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessagePostAsSmackMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "// in threaded conversation we need to look for existing chat\r\nverify(connection).isConnected();",
        "line": 146,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessagePostAsSmackMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection).sendStanza(Mockito.argThat((org.jivesoftware.smack.packet.Message m) -> {\r\n    boolean bodyMatches = \"Hello Kitty\".equals(m.getBody());\r\n    boolean toMatches = \"kermit@frog.com\".equals(m.getTo().toString());\r\n    boolean threadMatches = \"123\".equals(m.getThread());\r\n    return bodyMatches && toMatches && threadMatches;\r\n}));",
        "line": 147,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessagePostAsSmackMessage",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "connection",
    "variableType": "XMPPConnection",
    "mockedClass": "XMPPConnection",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\outbound\\ChatMessageSendingMessageHandlerTests.java",
      "className": "ChatMessageSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "XMPPConnection connection = mock(XMPPConnection.class);",
        "line": 157,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExtensionProvider",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(connection).sendStanza(argumentCaptor.capture());",
        "line": 174,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExtensionProvider",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "extensionElementProvider",
    "variableType": "GcmExtensionProvider",
    "mockedClass": "GcmExtensionProvider",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— Test Case",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\outbound\\ChatMessageSendingMessageHandlerTests.java",
      "className": "ChatMessageSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "GcmExtensionProvider extensionElementProvider = spy(new GcmExtensionProvider());",
        "line": 159,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExtensionProvider",
          "methodAnnotations": [
            "@Test"
          ]
        }
      },
      {
        "type": "VERIFICATION",
        "code": "verify(extensionElementProvider).from(eq(json));",
        "line": 184,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testExtensionProvider",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "ChatMessageSendingMessageHandler",
    "mockedClass": "ChatMessageSendingMessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\outbound\\ChatMessageSendingMessageHandlerTests.java",
      "className": "ChatMessageSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ChatMessageSendingMessageHandler handler = new ChatMessageSendingMessageHandler(mock(XMPPConnection.class));",
        "line": 190,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateFailureNoChatToUser",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "ChatMessageSendingMessageHandler",
    "mockedClass": "ChatMessageSendingMessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\outbound\\ChatMessageSendingMessageHandlerTests.java",
      "className": "ChatMessageSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "ChatMessageSendingMessageHandler handler = new ChatMessageSendingMessageHandler(mock(XMPPConnection.class));",
        "line": 197,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "validateMessageWithUnsupportedPayload",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "PresenceSendingMessageHandler",
    "mockedClass": "PresenceSendingMessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\outbound\\PresenceSendingMessageHandlerTests.java",
      "className": "PresenceSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "PresenceSendingMessageHandler handler = new PresenceSendingMessageHandler(mock(XMPPConnection.class));",
        "line": 45,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testPresencePayload",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "handler",
    "variableType": "PresenceSendingMessageHandler",
    "mockedClass": "PresenceSendingMessageHandler",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.xmpp.outbound",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-xmpp\\src\\test\\java\\org\\springframework\\integration\\xmpp\\outbound\\PresenceSendingMessageHandlerTests.java",
      "className": "PresenceSendingMessageHandlerTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "PresenceSendingMessageHandler handler = new PresenceSendingMessageHandler(mock(XMPPConnection.class));",
        "line": 53,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testWrongPayload",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  },
  {
    "variableName": "mockListener",
    "variableType": "MetadataStoreListener",
    "mockedClass": "MetadataStoreListener",
    "isReuseableMock": false,
    "mockPattern": "Creation:\n— Local Mock Creation in Test Case\n\nStubbing:\n— None\n\nVerification:\n— None",
    "classContext": {
      "packageName": "org.springframework.integration.zookeeper.metadata",
      "filePath": "C:\\java tool\\Spring\\spring-integration\\spring-integration-zookeeper\\src\\test\\java\\org\\springframework\\integration\\zookeeper\\metadata\\ZookeeperMetadataStoreTests.java",
      "className": "ZookeeperMetadataStoreTests"
    },
    "statements": [
      {
        "type": "DECLARATION",
        "code": "MetadataStoreListener mockListener = Mockito.mock(MetadataStoreListener.class);",
        "line": 334,
        "locate": "Test Case",
        "locationContext": {
          "methodName": "testAddRemoveListener",
          "methodAnnotations": [
            "@Test"
          ]
        }
      }
    ]
  }
]